---- prefix Matches (2755 in 229 files) ----
BGP4-MIB.txt (bgpd):628
                    "Length in bits of the IP address prefix in the
                    Network Layer Reachability Information field."
            ::= { bgp4PathAttrEntry 2 }
BGP4-MIB.txt (bgpd):637
                    "An IP address prefix in the Network Layer
                    Reachability Information field.  This object
                    is an IP address containing the prefix with
                    length specified by bgp4PathAttrIpAddrPrefixLen.
                    Any bits beyond the length specified by
Bgpd.c (bgpd):23
#include "prefix.h"
#include "thread.h"
#include "buffer.h"
Bgpd.c (bgpd):639
  /* Clear neighbor maximum-prefix */
  peer->pmax[afi][safi] = 0;
  peer->pmax_threshold[afi][safi] = MAXIMUM_PREFIX_THRESHOLD_DEFAULT;
Bgpd.c (bgpd):1578
  /* maximum-prefix */
  peer->pmax[afi][safi] = conf->pmax[afi][safi];
  peer->pmax_threshold[afi][safi] = conf->pmax_threshold[afi][safi];
Bgpd.c (bgpd):2591
		zlog_debug ("%s Maximum-prefix restart timer canceled",
			    peer->host);
	    }
Bgpd.c (bgpd):3992
/* Set prefix list to the peer. */
int
peer_prefix_list_set (struct peer *peer, afi_t afi, safi_t safi, int direct, 
Bgpd.c (bgpd):4098
/* Update prefix-list list. */
static void
peer_prefix_list_update (struct prefix_list *plist)
Bgpd.c (bgpd):4668
		zlog_debug ("%s Maximum-prefix restart timer canceled",
			    peer->host);
	    }
Bgpd.c (bgpd):4838
  /* prefix-list. */
  if (filter->plist[in].name)
    if (! gfilter || ! gfilter->plist[in].name
Bgpd.c (bgpd):4842
    vty_out (vty, " neighbor %s prefix-list %s in%s", addr, 
	     filter->plist[in].name, VTY_NEWLINE);
  if (filter->plist[out].name && ! gfilter)
    vty_out (vty, " neighbor %s prefix-list %s out%s", addr, 
	     filter->plist[out].name, VTY_NEWLINE);

Bgpd.c (bgpd):5080
      vty_out (vty, " neighbor %s capability orf prefix-list", addr);

      if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_SM)
Bgpd.c (bgpd):5165
  /* maximum-prefix. */
  if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_MAX_PREFIX))
    if (! peer->af_group[afi][safi]
Bgpd.c (bgpd):5173
	vty_out (vty, " neighbor %s maximum-prefix %ld", addr, peer->pmax[afi][safi]);
	if (peer->pmax_threshold[afi][safi] != MAXIMUM_PREFIX_THRESHOLD_DEFAULT)
	  vty_out (vty, " %d", peer->pmax_threshold[afi][safi]);
Bgpd.h (bgpd):425
#define PEER_FLAG_MAX_PREFIX                (1 << 14) /* maximum prefix */
#define PEER_FLAG_MAX_PREFIX_WARNING        (1 << 15) /* maximum prefix warning-only */
#define PEER_FLAG_NEXTHOP_LOCAL_UNCHANGED   (1 << 16) /* leave link-local nexthop unchanged */
#define PEER_FLAG_NEXTHOP_SELF_ALL          (1 << 17) /* next-hop-self all */
Bgpd.h (bgpd):444
#define PEER_STATUS_PREFIX_OVERFLOW   (1 << 1) /* prefix-overflow */
#define PEER_STATUS_CAPABILITY_OPEN   (1 << 2) /* capability open send */
#define PEER_STATUS_OPEN_DEFERRED     (1 << 3) /* deferred to open_receive */
Bgpd.h (bgpd):453
#define PEER_STATUS_ORF_PREFIX_SEND   (1 << 0) /* prefix-list send peer */
#define PEER_STATUS_ORF_WAIT_REFRESH  (1 << 1) /* wait refresh received peer */
#define PEER_STATUS_DEFAULT_ORIGINATE (1 << 2) /* default-originate peer */
#define PEER_STATUS_PREFIX_THRESHOLD  (1 << 3) /* exceed prefix-threshold */
#define PEER_STATUS_PREFIX_LIMIT      (1 << 4) /* exceed prefix-limit */
#define PEER_STATUS_EOR_SEND          (1 << 5) /* end-of-rib send to peer */
#define PEER_STATUS_EOR_RECEIVED      (1 << 6) /* end-of-rib received from peer */
Bgpd.h (bgpd):520
  /* Send prefix count. */
  unsigned long scount[AFI_MAX][SAFI_MAX];

Bgpd.h (bgpd):541
  /* Max prefix count. */
  unsigned long pmax[AFI_MAX][SAFI_MAX];
  u_char pmax_threshold[AFI_MAX][SAFI_MAX];
Bgp_advertise.c (bgpd):25
#include "prefix.h"
#include "hash.h"
#include "thread.h"
Bgp_advertise.c (bgpd):165
bgp_adj_out_lookup (struct peer *peer, struct prefix *p,
		    afi_t afi, safi_t safi, struct bgp_node *rn)
{
Bgp_advertise.c (bgpd):221
bgp_adj_out_set (struct bgp_node *rn, struct peer *peer, struct prefix *p,
		 struct attr *attr, afi_t afi, safi_t safi,
		 struct bgp_info *binfo)
Bgp_advertise.c (bgpd):275
bgp_adj_out_unset (struct bgp_node *rn, struct peer *peer, struct prefix *p, 
		   afi_t afi, safi_t safi)
{
Bgp_advertise.h (bgpd):154
extern void bgp_adj_out_set (struct bgp_node *, struct peer *, struct prefix *,
		      struct attr *, afi_t, safi_t, struct bgp_info *);
extern void bgp_adj_out_unset (struct bgp_node *, struct peer *, struct prefix *,
			afi_t, safi_t);
extern void bgp_adj_out_remove (struct bgp_node *, struct bgp_adj_out *, 
Bgp_advertise.h (bgpd):160
extern int bgp_adj_out_lookup (struct peer *, struct prefix *, afi_t, safi_t,
			struct bgp_node *);

Bgp_attr.c (bgpd):24
#include "prefix.h"
#include "memory.h"
#include "vector.h"
Bgp_attr.c (bgpd):2449
int stream_put_prefix (struct stream *, struct prefix *);

size_t
Bgp_attr.c (bgpd):2547
			  struct prefix *p, struct prefix_rd *prd,
			  u_char *tag)
{
Bgp_attr.c (bgpd):2556
      stream_put (s, &p->u.prefix, PSIZE (p->prefixlen));
    }
  else
Bgp_attr.c (bgpd):2563
bgp_packet_mpattr_prefix_size (afi_t afi, safi_t safi, struct prefix *p)
{
  int size = PSIZE (p->prefixlen);
Bgp_attr.c (bgpd):2669
		      struct prefix *p, afi_t afi, safi_t safi,
		      struct peer *from, struct prefix_rd *prd, u_char *tag)
{
Bgp_attr.c (bgpd):3086
bgp_packet_mpunreach_prefix (struct stream *s, struct prefix *p,
			     afi_t afi, safi_t safi, struct prefix_rd *prd,
			     u_char *tag)
Bgp_attr.c (bgpd):3127
                      struct prefix *prefix)
{
  unsigned long cp;
Bgp_attr.c (bgpd):3156
  /* If it's an IPv6 prefix, don't dump the IPv4 nexthop to save space */
  if(prefix != NULL
     && prefix->family != AF_INET6
     )
    {
Bgp_attr.c (bgpd):3242
  if (prefix != NULL && prefix->family == AF_INET6 && attr->extra &&
     (attr->extra->mp_nexthop_len == 16 || attr->extra->mp_nexthop_len == 32) )
    {
Bgp_attr.c (bgpd):3267
      stream_put_prefix(s, prefix);

      /* Set MP attribute length. */
Bgp_attr.h (bgpd):177
					struct prefix *, afi_t, safi_t,
					struct peer *, struct prefix_rd *,
					u_char *);
Bgp_attr.h (bgpd):181
				  struct prefix *);
extern int attrhash_cmp (const void *, const void *);
extern unsigned int attrhash_key_make (void *);
Bgp_attr.h (bgpd):225
				     struct prefix *p, struct prefix_rd *prd,
				     u_char *tag);
extern size_t bgp_packet_mpattr_prefix_size(afi_t afi, safi_t safi,
                                            struct prefix *p);
extern void bgp_packet_mpattr_end(struct stream *s, size_t sizep);

Bgp_attr.h (bgpd):233
extern void bgp_packet_mpunreach_prefix (struct stream *s, struct prefix *p,
			     afi_t afi, safi_t safi, struct prefix_rd *prd,
			     u_char *tag);
Bgp_btoa.c (bgpd):26
#include "prefix.h"
#include "command.h"
#include "memory.h"
Bgp_btoa.c (bgpd):269
	      p.prefix.s_addr = stream_get_ipv4 (s);
	      p.prefixlen = stream_getc (s);
	      printf ("PREFIX: %s/%d\n", inet_ntoa (p.prefix), p.prefixlen);

	      status = stream_getc (s);
Bgp_clist.c (bgpd):24
#include "prefix.h"
#include "memory.h"
#include "filter.h"
Bgp_damp.c (bgpd):24
#include "prefix.h"
#include "memory.h"
#include "command.h"
Bgp_debug.c (bgpd):24
#include "prefix.h"
#include "linklist.h"
#include "stream.h"
Bgp_dump.c (bgpd):27
#include "prefix.h"
#include "thread.h"
#include "linklist.h"
Bgp_dump.c (bgpd):376
      /* Skip prefix & AFI/SAFI for MP_NLRI */
      bgp_dump_routes_attr (obuf, info->attr, &rn->p);

Bgp_ecommunity.c (bgpd):25
#include "prefix.h"
#include "command.h"
#include "filter.h"
Bgp_ecommunity.c (bgpd):600
  const char *prefix;
  int len = 0;
  int first = 1;
Bgp_ecommunity.c (bgpd):687
	  prefix = (type == ECOMMUNITY_ROUTE_TARGET ? "rt " : "soo ");
	  break;
	case ECOMMUNITY_FORMAT_DISPLAY:
	  prefix = (type == ECOMMUNITY_ROUTE_TARGET ? "RT:" : "SoO:");
	  break;
	case ECOMMUNITY_FORMAT_ROUTE_MAP:
	  prefix = "";
	  break;
	default:
	  prefix = "";
	  break;
	}
Bgp_ecommunity.c (bgpd):711
	  len = sprintf( str_buf + str_pnt, "%s%u:%u", prefix,
                        eas.as, eas.val );
	  str_pnt += len;
Bgp_ecommunity.c (bgpd):726
	  len = sprintf (str_buf + str_pnt, "%s%u:%u", prefix,
			 eas.as, eas.val);
	  str_pnt += len;
Bgp_ecommunity.c (bgpd):738
	  len = sprintf (str_buf + str_pnt, "%s%s:%u", prefix,
			 inet_ntoa (eip.ip), eip.val);
	  str_pnt += len;
Bgp_encap.c (bgpd):33
#include "prefix.h"
#include "log.h"
#include "memory.h"
Bgp_encap.c (bgpd):136
  struct prefix p;
  int psize = 0;
  int prefixlen;
Bgp_encap.c (bgpd):191
      /* Clear prefix structure. */
      memset (&p, 0, sizeof (struct prefix));

      /* Fetch prefix length. */
      prefixlen = *pnt++;
      p.family = afi2family(afi);
Bgp_encap.c (bgpd):205
      memcpy (&p.u.prefix, pnt, psize);

      if (pnt + psize > lim)
Bgp_encap.c (bgpd):212
	zlog_info ("rd-as %u:%u prefix %s/%d", rd_as.as, rd_as.val,
		   inet_ntop (p.family, &p.u.prefix, buf, BUFSIZ),
		   p.prefixlen);
      else if (rdtype == RD_TYPE_IP)
	zlog_info ("rd-ip %s:%u prefix %s/%d", inet_ntoa (rd_ip.ip),
		   rd_ip.val,
		   inet_ntop (p.family, &p.u.prefix, buf, BUFSIZ),
		   p.prefixlen);
      else if (rdtype == RD_TYPE_AS4)
	zlog_info ("rd-as4 %u:%u prefix %s/%d", rd_as.as, rd_as.val,
		   inet_ntop (p.family, &p.u.prefix, buf, BUFSIZ),
		   p.prefixlen);
      else
	zlog_info ("rd unknown, default to 0:0 prefix %s/%d",
	    inet_ntop (p.family, &p.u.prefix, buf, BUFSIZ),
	    p.prefixlen);

Bgp_encap.c (bgpd):253
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Specify Route Distinguisher\n"
       "ENCAP Route Distinguisher\n"
Bgp_encap.c (bgpd):268
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Specify Route Distinguisher\n"
       "ENCAP Route Distinguisher\n"
Bgp_encap_tlv.c (bgpd):23
#include "prefix.h"
#include "vty.h"
#include "filter.h"
Bgp_fsm.c (bgpd):25
#include "prefix.h"
#include "vty.h"
#include "sockunion.h"
Bgp_fsm.c (bgpd):554
	/* Received ORF prefix-filter */
	peer->orf_plist[afi][safi] = NULL;

        /* ORF received prefix-filter pnt */
        sprintf (orf_name, "%s.%d.%d", peer->host, afi, safi);
        prefix_bgp_orf_remove_all (afi, orf_name);
Bgp_fsm.c (bgpd):576
  /* Until we are sure that there is no problem about prefix count
     this should be commented out.*/
#if 0
  /* Reset prefix count */
  peer->pcount[AFI_IP][SAFI_UNICAST] = 0;
  peer->pcount[AFI_IP][SAFI_MULTICAST] = 0;
Bgp_lcommunity.c (bgpd):26
#include "prefix.h"
#include "command.h"
#include "filter.h"
Bgp_main.c (bgpd):30
#include "prefix.h"
#include "log.h"
#include "privs.h"
Bgp_mpath.c (bgpd):27
#include "prefix.h"
#include "linklist.h"
#include "sockunion.h"
Bgp_mplsvpn.c (bgpd):24
#include "prefix.h"
#include "log.h"
#include "memory.h"
Bgp_mplsvpn.c (bgpd):102
  struct prefix p;
  int psize = 0;
  int prefixlen;
Bgp_mplsvpn.c (bgpd):125
      /* Clear prefix structure. */
      memset (&p, 0, sizeof (struct prefix));

      /* Fetch prefix length. */
      prefixlen = *pnt++;
      p.family = afi2family (packet->afi);
Bgp_mplsvpn.c (bgpd):138
                     " (prefix length %d less than VPNv4 min length)",
                    peer->host, prefixlen);
          return -1;
Bgp_mplsvpn.c (bgpd):175
      /* Copyr label to prefix. */
      tagpnt = pnt;

Bgp_mplsvpn.c (bgpd):204
      memcpy (&p.u.prefix, pnt + VPN_PREFIXLEN_MIN_BYTES, 
              psize - VPN_PREFIXLEN_MIN_BYTES);

Bgp_mplsvpn.c (bgpd):354
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Specify Route Distinguisher\n"
       "VPN Route Distinguisher\n"
Bgp_mplsvpn.c (bgpd):367
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Specify Route Distinguisher\n"
       "VPN Route Distinguisher\n"
Bgp_mplsvpn.c (bgpd):384
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Specify Route Distinguisher\n"
       "VPN Route Distinguisher\n"
Bgp_network.c (bgpd):29
#include "prefix.h"
#include "command.h"
#include "privs.h"
Bgp_network.c (bgpd):320
  struct prefix *p, *sel, d;
  struct connected *connected;
  struct listnode *node;
Bgp_nexthop.c (bgpd):25
#include "prefix.h"
#include "zclient.h"
#include "stream.h"
Bgp_nexthop.c (bgpd):187
bgp_address_add (struct prefix *p)
{
  struct bgp_addr tmp;
Bgp_nexthop.c (bgpd):202
bgp_address_del (struct prefix *p)
{
  struct bgp_addr tmp;
Bgp_nexthop.c (bgpd):232
  struct prefix p;
  struct prefix *addr;
  struct interface *ifp;
  struct bgp_node *rn;
Bgp_nexthop.c (bgpd):258
      rn = bgp_node_get (bgp_connected_table[AFI_IP], (struct prefix *) &p);
      if (rn->info)
	{
Bgp_nexthop.c (bgpd):281
      rn = bgp_node_get (bgp_connected_table[AFI_IP6], (struct prefix *) &p);
      if (rn->info)
	{
Bgp_nexthop.c (bgpd):299
  struct prefix p;
  struct prefix *addr;
  struct interface *ifp;
  struct bgp_node *rn;
Bgp_nexthop.c (bgpd):346
      rn = bgp_node_lookup (bgp_connected_table[AFI_IP6], (struct prefix *) &p);
      if (! rn)
	return;
Bgp_nexthop.c (bgpd):381
  struct prefix p;
  int ret;

Bgp_nexthop.c (bgpd):434
			   inet_ntop (rn->p.family, &rn->p.u.prefix, buf, sizeof (buf)),
			   bnc->metric, bnc->path_count, VTY_NEWLINE);
		  if (detail)
Bgp_nexthop.c (bgpd):474
			 inet_ntop (AF_INET, &rn->p.u.prefix, buf, sizeof (buf)), VTY_NEWLINE);
#ifdef HAVE_CLOCK_MONOTONIC
	      tbuf = time(NULL) - (bgp_clock() - bnc->last_update);
Bgp_nexthop.h (bgpd):26
#include "prefix.h"

#define NEXTHOP_FAMILY(nexthop_len) ( \
Bgp_nht.c (bgpd):26
#include "prefix.h"
#include "zclient.h"
#include "stream.h"
Bgp_nht.c (bgpd):51
static int make_prefix(int afi, struct bgp_info *ri, struct prefix *p);
static void path_nh_map(struct bgp_info *path, struct bgp_nexthop_cache *bnc,
			int keep);
Bgp_nht.c (bgpd):87
  struct prefix p;
  afi_t afi;
  
Bgp_nht.c (bgpd):262
  struct prefix p;
  int i;

Bgp_nht.c (bgpd):267
  memset(&p, 0, sizeof(struct prefix));
  p.family = stream_getw(s);
  p.prefixlen = stream_getc(s);
Bgp_nht.c (bgpd):396
 * make_prefix - make a prefix structure from the path (essentially
 * path's node.
 */
Bgp_nht.c (bgpd):400
make_prefix (int afi, struct bgp_info *ri, struct prefix *p)
{
  memset (p, 0, sizeof (struct prefix));
  switch (afi)
    {
Bgp_nht.c (bgpd):440
  struct prefix *p;
  int ret;

Bgp_nht.h (bgpd):40
 *  the given prefix or peer.  If an existing one is not found,
 *  create a new object and register with ZEBRA for nexthop
 *  notification.
Bgp_open.c (bgpd):24
#include "prefix.h"
#include "stream.h"
#include "thread.h"
Bgp_packet.c (bgpd):26
#include "prefix.h"
#include "command.h"
#include "log.h"
Bgp_packet.c (bgpd):54
int stream_put_prefix (struct stream *, struct prefix *);

/* Set up BGP packet marker and packet type. */
Bgp_packet.c (bgpd):247
	  /* Encode the prefix in MP_REACH_NLRI attribute */
	  struct prefix_rd *prd = NULL;
	  u_char *tag = NULL;
Bgp_packet.c (bgpd):267
                inet_ntop (rn->p.family, &(rn->p.u.prefix), buf, INET6_BUFSIZ),
                rn->p.prefixlen);
        }
Bgp_packet.c (bgpd):430
                inet_ntop (rn->p.family, &(rn->p.u.prefix), buf, INET6_BUFSIZ),
                rn->p.prefixlen);
        }
Bgp_packet.c (bgpd):473
  struct prefix p;
  unsigned long pos;
  bgp_size_t total_attr_len;
Bgp_packet.c (bgpd):494
	    peer->host, inet_ntop(p.family, &(p.u.prefix), buf, INET6_BUFSIZ),
	    p.prefixlen, attrstr);
    }
Bgp_packet.c (bgpd):536
  struct prefix p;
  unsigned long attrlen_pos = 0;
  unsigned long cp;
Bgp_packet.c (bgpd):559
            peer->host, inet_ntop(p.family, &(p.u.prefix), buf, INET6_BUFSIZ),
            p.prefixlen);
    }
Bgp_packet.c (bgpd):1841
   * them. Instead we withdraw only the prefix concerned.
   * 
   * Complicates the flow a little though..
Bgp_packet.c (bgpd):2229
	      /* ORF prefix-list name */
	      sprintf (name, "%s.%d.%d", peer->host, afi, safi);

Bgp_packet.c (bgpd):2280
		    memcpy (&orfp.p.u.prefix, p_pnt, psize);
		  p_pnt += psize;

Bgp_packet.c (bgpd):2292
			         inet_ntop (orfp.p.family, &orfp.p.u.prefix, buf, INET6_BUFSIZ),
			         orfp.p.prefixlen, orfp.ge, orfp.le,
			         ok ? "" : " MALFORMED");
Bgp_route.c (bgpd):24
#include "prefix.h"
#include "linklist.h"
#include "memory.h"
Bgp_route.c (bgpd):67
bgp_afi_node_get (struct bgp_table *table, afi_t afi, safi_t safi, struct prefix *p,
		  struct prefix_rd *prd)
{
Bgp_route.c (bgpd):79
      prn = bgp_node_get (table, (struct prefix *) prd);

      if (prn->info == NULL)
Bgp_route.c (bgpd):263
          zlog_warn ("%s: Asked to decrement 0 prefix count for peer %s",
                     __func__, ri->peer->host);
          zlog_backtrace (LOG_WARNING);
Bgp_route.c (bgpd):279
 * This is here primarily to keep prefix-count in check.
 */
void
Bgp_route.c (bgpd):572
bgp_input_filter (struct peer *peer, struct prefix *p, struct attr *attr,
		  afi_t afi, safi_t safi)
{
Bgp_route.c (bgpd):593
    FILTER_EXIST_WARN(PREFIX_LIST, prefix, filter);
    
    if (prefix_list_apply (PREFIX_LIST_IN (filter), p) == PREFIX_DENY)
Bgp_route.c (bgpd):611
bgp_output_filter (struct peer *peer, struct prefix *p, struct attr *attr,
		   afi_t afi, safi_t safi)
{
Bgp_route.c (bgpd):632
    FILTER_EXIST_WARN(PREFIX_LIST, prefix, filter);
    
    if (prefix_list_apply (PREFIX_LIST_OUT (filter), p) == PREFIX_DENY)
Bgp_route.c (bgpd):693
bgp_input_modifier (struct peer *peer, struct prefix *p, struct attr *attr,
		    afi_t afi, safi_t safi)
{
Bgp_route.c (bgpd):729
        struct prefix *p, struct attr *attr, afi_t afi, safi_t safi)
{
  struct bgp_filter *filter;
Bgp_route.c (bgpd):763
        struct prefix *p, struct attr *attr, afi_t afi, safi_t safi)
{
  struct bgp_filter *filter;
Bgp_route.c (bgpd):800
bgp_announce_check (struct bgp_info *ri, struct peer *peer, struct prefix *p,
		    struct attr *attr, afi_t afi, safi_t safi)
{
Bgp_route.c (bgpd):863
		  inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
		  p->prefixlen);
	  return 0;
Bgp_route.c (bgpd):869
  /* ORF prefix-list filter check */
  if (CHECK_FLAG (peer->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_ADV)
      && (CHECK_FLAG (peer->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_RCV)
Bgp_route.c (bgpd):886
	      inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
	      p->prefixlen);
      return 0;
Bgp_route.c (bgpd):1111
        struct prefix *p, struct attr *attr, afi_t afi, safi_t safi)
{
  int ret;
Bgp_route.c (bgpd):1157
                 inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                 p->prefixlen);
         return 0;
Bgp_route.c (bgpd):1163
  /* ORF prefix-list filter check */
  if (CHECK_FLAG (rsclient->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_ADV)
      && (CHECK_FLAG (rsclient->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_RCV)
Bgp_route.c (bgpd):1180
             inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
             p->prefixlen);
      return 0;
Bgp_route.c (bgpd):1466
  struct prefix *p;
  struct attr attr;
  struct attr_extra extra;
Bgp_route.c (bgpd):1604
  struct prefix *p = &rn->p;
  struct bgp_info *new_select;
  struct bgp_info *old_select;
Bgp_route.c (bgpd):1633
  /* If the user did "clear ip bgp prefix x.x.x.x" this flag will be set */
  UNSET_FLAG(rn->flags, BGP_NODE_USER_CLEAR);

Bgp_route.c (bgpd):1653
        zlog_info("BGP announce prefix which is to ebgp peer %s", peer->host);
        bgp_process_announce_selected (peer, new_select, rn, afi, safi);
      }
Bgp_route.c (bgpd):1658
        zlog_info("BGP announce prefix which is to ibgp peer %s", peer->host);
        bgp_process_announce_selected (peer, new_select, rn, afi, safi);
      }
Bgp_route.c (bgpd):1698
  struct prefix *p = &rn->p;
  struct bgp_info *new_select;
  struct bgp_info *old_select;
Bgp_route.c (bgpd):1734
  /* If the user did "clear ip bgp prefix x.x.x.x" this flag will be set */
  UNSET_FLAG(rn->flags, BGP_NODE_USER_CLEAR);

Bgp_route.c (bgpd):1754
        zlog_info("BGP announce prefix which is to ebgp peer %s aspath is %s", peer->host, aspath_print(new_select->attr->aspath));
        bgp_process_announce_selected (peer, new_select, rn, afi, safi);
      }
Bgp_route.c (bgpd):1759
        zlog_info("BGP announce prefix which is to ibgp peer  %s aspath is %s", peer->host, aspath_print(new_select->attr->aspath));
        bgp_process_announce_selected (peer, new_select, rn, afi, safi);
      }
Bgp_route.c (bgpd):1978
    zlog_debug ("%s Maximum-prefix restart timer expired, restore peering",
		peer->host);

Bgp_route.c (bgpd):2000
	    "%%MAXPFXEXCEED: No. of %s prefix received from %s %ld exceed, "
	    "limit %ld", afi_safi_print (afi, safi), peer->host,
	    peer->pcount[afi][safi], peer->pmax[afi][safi]);
Bgp_route.c (bgpd):2033
	    zlog_debug ("%s Maximum-prefix restart timer started for %d secs",
			peer->host, peer->v_pmax_restart);

Bgp_route.c (bgpd):2052
	    "%%MAXPFX: No. of %s prefix received from %s reaches %ld, max %ld",
	    afi_safi_print (afi, safi), peer->host, peer->pcount[afi][safi],
	    peer->pmax[afi][safi]);
Bgp_route.c (bgpd):2117
      struct attr *attr, struct peer *peer, struct prefix *p, int type,
      int sub_type, struct prefix_rd *prd, u_char *tag)
{
Bgp_route.c (bgpd):2212
                    inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                    p->prefixlen, rsclient->host);

Bgp_route.c (bgpd):2229
                inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                p->prefixlen, rsclient->host);

Bgp_route.c (bgpd):2257
              inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
              p->prefixlen, rsclient->host);
    }
Bgp_route.c (bgpd):2287
        inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
        p->prefixlen, rsclient->host, reason);

Bgp_route.c (bgpd):2300
      struct peer *peer, struct prefix *p, int type, int sub_type,
      struct prefix_rd *prd, u_char *tag)
{
Bgp_route.c (bgpd):2323
          inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
          p->prefixlen);

Bgp_route.c (bgpd):2331
bgp_update_main (struct peer *peer, struct prefix *p, struct attr *attr,
	    afi_t afi, safi_t safi, int type, int sub_type,
	    struct prefix_rd *prd, u_char *tag, int soft_reconfig)
Bgp_route.c (bgpd):2468
		  inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
		  p->prefixlen);

Bgp_route.c (bgpd):2484
		inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
		p->prefixlen);

Bgp_route.c (bgpd):2509
            inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
            p->prefixlen);
          bgp_info_restore (rn, ri);
Bgp_route.c (bgpd):2518
	      inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
	      p->prefixlen);

Bgp_route.c (bgpd):2608
	    inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
	    p->prefixlen);
    }
Bgp_route.c (bgpd):2645
  /* Increment prefix */
  bgp_aggregate_increment (bgp, p, new, afi, safi);
  
Bgp_route.c (bgpd):2656
  /* If maximum prefix count is configured and current prefix
     count exeed it. */
  if (bgp_maximum_prefix_overflow (peer, afi, safi, 0))
Bgp_route.c (bgpd):2674
	  inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
	  p->prefixlen, reason);

Bgp_route.c (bgpd):2687
bgp_update (struct peer *peer, struct prefix *p, struct attr *attr,
            afi_t afi, safi_t safi, int type, int sub_type,
            struct prefix_rd *prd, u_char *tag, int soft_reconfig)
Bgp_route.c (bgpd):2717
bgp_withdraw (struct peer *peer, struct prefix *p, struct attr *attr, 
	     afi_t afi, safi_t safi, int type, int sub_type, 
	     struct prefix_rd *prd, u_char *tag)
Bgp_route.c (bgpd):2745
                inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                p->prefixlen);
        bgp_unlock_node (rn);
Bgp_route.c (bgpd):2762
	  inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
	  p->prefixlen);

Bgp_route.c (bgpd):2776
	  inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
	  p->prefixlen);

Bgp_route.c (bgpd):2791
  struct prefix p;
  struct peer *from;
  struct bgp_node *rn;
Bgp_route.c (bgpd):3192
       * Given that our per-peer prefix-counts now should be reliable,
       * this may actually be achievable. It doesn't seem to be a huge
       * problem at this time,
Bgp_route.c (bgpd):3481
  struct prefix p;
  int psize;
  int ret;
Bgp_route.c (bgpd):3497
      /* Clear prefix structure. */
      memset (&p, 0, sizeof (struct prefix));

      /* Fetch prefix length. */
      p.prefixlen = *pnt++;
      /* afi/safi validity already verified by caller, bgp_update_receive */
Bgp_route.c (bgpd):3510
                    " (wrong prefix length %u for afi %u)",
                    peer->host, p.prefixlen, packet->afi);
          return -1;
Bgp_route.c (bgpd):3523
                    " (prefix length %u overflows packet)",
                    peer->host, p.prefixlen);
          return -1;
Bgp_route.c (bgpd):3528
      /* Defensive coding, double-check the psize fits in a struct prefix */  
      if (psize > (ssize_t) sizeof(p.u))
        {
Bgp_route.c (bgpd):3533
                    " (prefix length %u too large for prefix storage %zu!?!!",
                    peer->host, p.prefixlen, sizeof(p.u));
          return -1;
Bgp_route.c (bgpd):3538
      /* Fetch prefix from NLRI packet. */
      memcpy (&p.u.prefix, pnt, psize);

      /* Check address. */
Bgp_route.c (bgpd):3549
	      * If a prefix in the NLRI field is semantically incorrect
	      * (e.g., an unexpected multicast IP address), an error SHOULD
	      * be logged locally, and the prefix SHOULD be ignored.
	      */
	      zlog (peer->log, LOG_ERR, 
Bgp_route.c (bgpd):3598
      /* Address family configuration mismatch or maximum-prefix count
         overflow. */
      if (ret < 0)
Bgp_route.c (bgpd):3609
                " (prefix length mismatch with total length)",
                peer->host);
      return -1;
Bgp_route.c (bgpd):3633
        struct prefix *p, afi_t afi, safi_t safi)
{
  struct bgp_node *rn;
Bgp_route.c (bgpd):3659
bgp_static_update_rsclient (struct peer *rsclient, struct prefix *p,
                            struct bgp_static *bgp_static,
                            afi_t afi, safi_t safi)
Bgp_route.c (bgpd):3735
              inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
              p->prefixlen, rsclient->host);

Bgp_route.c (bgpd):3846
bgp_static_update_main (struct bgp *bgp, struct prefix *p,
			struct bgp_static *bgp_static, afi_t afi, safi_t safi)
{
Bgp_route.c (bgpd):3999
bgp_static_update (struct bgp *bgp, struct prefix *p,
                  struct bgp_static *bgp_static, afi_t afi, safi_t safi)
{
Bgp_route.c (bgpd):4015
bgp_static_withdraw (struct bgp *bgp, struct prefix *p, afi_t afi,
		     safi_t safi)
{
Bgp_route.c (bgpd):4050
  struct prefix *p;

  bgp = rsclient->bgp;
Bgp_route.c (bgpd):4068
bgp_static_withdraw_safi (struct bgp *bgp, struct prefix *p, afi_t afi,
                          safi_t safi, struct prefix_rd *prd, u_char *tag)
{
Bgp_route.c (bgpd):4096
bgp_static_update_safi (struct bgp *bgp, struct prefix *p,
                        struct bgp_static *bgp_static, afi_t afi, safi_t safi)
{
Bgp_route.c (bgpd):4223
  struct prefix p;
  struct bgp_static *bgp_static;
  struct bgp_node *rn;
Bgp_route.c (bgpd):4228
  /* Convert IP prefix string to struct prefix. */
  ret = str2prefix (ip_str, &p);
  if (! ret)
Bgp_route.c (bgpd):4232
      vty_out (vty, "%% Malformed prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Bgp_route.c (bgpd):4237
      vty_out (vty, "%% Malformed prefix (link-local address)%s",
	       VTY_NEWLINE);
      return CMD_WARNING;
Bgp_route.c (bgpd):4310
  struct prefix p;
  struct bgp_static *bgp_static;
  struct bgp_node *rn;
Bgp_route.c (bgpd):4314
  /* Convert IP prefix string to struct prefix. */
  ret = str2prefix (ip_str, &p);
  if (! ret)
Bgp_route.c (bgpd):4318
      vty_out (vty, "%% Malformed prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Bgp_route.c (bgpd):4323
      vty_out (vty, "%% Malformed prefix (link-local address)%s",
	       VTY_NEWLINE);
      return CMD_WARNING;
Bgp_route.c (bgpd):4408
  struct prefix p;
  struct prefix_rd prd;
  struct bgp *bgp;
Bgp_route.c (bgpd):4422
      vty_out (vty, "%% Malformed prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Bgp_route.c (bgpd):4442
			(struct prefix *)&prd);
  if (prn->info == NULL)
    prn->info = bgp_table_init (AFI_IP, safi);
Bgp_route.c (bgpd):4490
  struct prefix p;
  struct prefix_rd prd;
  struct bgp_node *prn;
Bgp_route.c (bgpd):4500
  /* Convert IP prefix string to struct prefix. */
  ret = str2prefix (ip_str, &p);
  if (! ret)
Bgp_route.c (bgpd):4504
      vty_out (vty, "%% Malformed prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Bgp_route.c (bgpd):4524
			(struct prefix *)&prd);
  if (prn->info == NULL)
    prn->info = bgp_table_init (AFI_IP, safi);
Bgp_route.c (bgpd):4553
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  return bgp_static_set (vty, vty->index, argv[0],
Bgp_route.c (bgpd):4563
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Route-map to modify the attributes\n"
       "Name of the route map\n")
Bgp_route.c (bgpd):4575
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Specify a BGP backdoor route\n")
{
Bgp_route.c (bgpd):4719
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  return bgp_static_unset (vty, vty->index, argv[0], AFI_IP, 
Bgp_route.c (bgpd):4730
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Route-map to modify the attributes\n"
       "Name of the route map\n")
Bgp_route.c (bgpd):4739
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Specify a BGP backdoor route\n")

Bgp_route.c (bgpd):4828
       "IPv6 prefix <network>/<length>\n")
{
  return bgp_static_set (vty, vty->index, argv[0], AFI_IP6, bgp_node_safi(vty),
Bgp_route.c (bgpd):4838
       "IPv6 prefix <network>/<length>\n"
       "Route-map to modify the attributes\n"
       "Name of the route map\n")
Bgp_route.c (bgpd):4851
       "IPv6 prefix <network>/<length>\n")
{
  return bgp_static_unset (vty, vty->index, argv[0], AFI_IP6, bgp_node_safi(vty));
Bgp_route.c (bgpd):4861
       "IPv6 prefix <network>/<length>\n"
       "Route-map to modify the attributes\n"
       "Name of the route map\n")
Bgp_route.c (bgpd):4871
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n")

ALIAS (no_ipv6_bgp_network,
Bgp_route.c (bgpd):4880
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n")

/* stubs for removed AS-Pathlimit commands, kept for config compatibility */
Bgp_route.c (bgpd):4887
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "AS-Path hopcount limit attribute\n"
       "AS-Pathlimit TTL, in number of AS-Path hops\n")
Bgp_route.c (bgpd):4894
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Specify a BGP backdoor route\n"
       "AS-Path hopcount limit attribute\n"
Bgp_route.c (bgpd):4937
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "AS-Path hopcount limit attribute\n"
       "AS-Pathlimit TTL, in number of AS-Path hops\n")
Bgp_route.c (bgpd):4945
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Specify a BGP backdoor route\n"
       "AS-Path hopcount limit attribute\n"
Bgp_route.c (bgpd):4991
       "IPv6 prefix <network>/<length>\n"
       "AS-Path hopcount limit attribute\n"
       "AS-Pathlimit TTL, in number of AS-Path hops\n")
Bgp_route.c (bgpd):4999
       "IPv6 prefix <network>/<length>\n"
       "AS-Path hopcount limit attribute\n"
       "AS-Pathlimit TTL, in number of AS-Path hops\n")
Bgp_route.c (bgpd):5045
bgp_aggregate_route (struct bgp *bgp, struct prefix *p, struct bgp_info *rinew,
		     afi_t afi, safi_t safi, struct bgp_info *del, 
		     struct bgp_aggregate *aggregate)
Bgp_route.c (bgpd):5212
void bgp_aggregate_delete (struct bgp *, struct prefix *, afi_t, safi_t,
			   struct bgp_aggregate *);

Bgp_route.c (bgpd):5216
bgp_aggregate_increment (struct bgp *bgp, struct prefix *p,
			 struct bgp_info *ri, afi_t afi, safi_t safi)
{
Bgp_route.c (bgpd):5253
bgp_aggregate_decrement (struct bgp *bgp, struct prefix *p, 
			 struct bgp_info *del, afi_t afi, safi_t safi)
{
Bgp_route.c (bgpd):5288
bgp_aggregate_add (struct bgp *bgp, struct prefix *p, afi_t afi, safi_t safi,
		   struct bgp_aggregate *aggregate)
{
Bgp_route.c (bgpd):5410
bgp_aggregate_delete (struct bgp *bgp, struct prefix *p, afi_t afi, 
		      safi_t safi, struct bgp_aggregate *aggregate)
{
Bgp_route.c (bgpd):5489
  struct prefix p;
  struct bgp_node *rn;
  struct bgp *bgp;
Bgp_route.c (bgpd):5494
  /* Convert string to prefix structure. */
  ret = str2prefix (prefix_str, &p);
  if (!ret)
Bgp_route.c (bgpd):5498
      vty_out (vty, "Malformed prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Bgp_route.c (bgpd):5536
  struct prefix p;
  struct bgp_node *rn;
  struct bgp *bgp;
Bgp_route.c (bgpd):5541
  /* Convert string to prefix structure. */
  ret = str2prefix (prefix_str, &p);
  if (!ret)
Bgp_route.c (bgpd):5545
      vty_out (vty, "Malformed prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Bgp_route.c (bgpd):5589
       "Aggregate prefix\n")
{
  return bgp_aggregate_set (vty, argv[0], AFI_IP, bgp_node_safi (vty), 0, 0);
Bgp_route.c (bgpd):5620
       "Aggregate prefix\n"
       "Filter more specific routes from updates\n")
{
Bgp_route.c (bgpd):5654
       "Aggregate prefix\n"
       "Generate AS set path information\n")
{
Bgp_route.c (bgpd):5689
       "Aggregate prefix\n"
       "Generate AS set path information\n"
       "Filter more specific routes from updates\n")
Bgp_route.c (bgpd):5701
       "Aggregate prefix\n"
       "Filter more specific routes from updates\n"
       "Generate AS set path information\n")
Bgp_route.c (bgpd):5743
       "Aggregate prefix\n")
{
  return bgp_aggregate_unset (vty, argv[0], AFI_IP, bgp_node_safi (vty));
Bgp_route.c (bgpd):5753
       "Aggregate prefix\n"
       "Filter more specific routes from updates\n")

Bgp_route.c (bgpd):5761
       "Aggregate prefix\n"
       "Generate AS set path information\n")

Bgp_route.c (bgpd):5769
       "Aggregate prefix\n"
       "Generate AS set path information\n"
       "Filter more specific routes from updates\n")
Bgp_route.c (bgpd):5778
       "Aggregate prefix\n"
       "Filter more specific routes from updates\n"
       "Generate AS set path information\n")
Bgp_route.c (bgpd):5846
       "Aggregate prefix\n")
{
  return bgp_aggregate_set (vty, argv[0], AFI_IP6, SAFI_UNICAST, 0, 0);
Bgp_route.c (bgpd):5855
       "Aggregate prefix\n"
       "Filter more specific routes from updates\n")
{
Bgp_route.c (bgpd):5867
       "Aggregate prefix\n")
{
  return bgp_aggregate_unset (vty, argv[0], AFI_IP6, SAFI_UNICAST);
Bgp_route.c (bgpd):5877
       "Aggregate prefix\n"
       "Filter more specific routes from updates\n")
{
Bgp_route.c (bgpd):5889
       "Aggregate prefix\n")

ALIAS (ipv6_aggregate_address_summary_only,
Bgp_route.c (bgpd):5897
       "Aggregate prefix\n"
       "Filter more specific routes from updates\n")

Bgp_route.c (bgpd):5907
       "Aggregate prefix\n")

ALIAS (no_ipv6_aggregate_address_summary_only,
Bgp_route.c (bgpd):5916
       "Aggregate prefix\n"
       "Filter more specific routes from updates\n")

Bgp_route.c (bgpd):5921
bgp_redistribute_add (struct prefix *p, const struct in_addr *nexthop,
		      const struct in6_addr *nexthop6,
		      u_int32_t metric, u_char type, route_tag_t tag)
Bgp_route.c (bgpd):6056
bgp_redistribute_delete (struct prefix *p, u_char type)
{
  struct bgp *bgp;
Bgp_route.c (bgpd):6116
route_vty_out_route (struct prefix *p, struct vty *vty)
{
  int len;
Bgp_route.c (bgpd):6124
      len = vty_out (vty, "%s", inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ));
      destination = ntohl (p->u.prefix4.s_addr);

Bgp_route.c (bgpd):6138
    len = vty_out (vty, "%s/%d", inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
		   p->prefixlen);

Bgp_route.c (bgpd):6193
    struct prefix *p,
    struct bgp_info *binfo,
    int display,
Bgp_route.c (bgpd):6203
  /* print prefix and mask */
  if (!display)
    route_vty_out_route (p, vty);
Bgp_route.c (bgpd):6220
       * neccessarily the same as the prefix address family.
       * Both SAFI_MPLS_VPN and SAFI_ENCAP use the MP nexthop field
       */
Bgp_route.c (bgpd):6298
route_vty_out_tmp (struct vty *vty, struct prefix *p,
		   struct attr *attr, safi_t safi)
{
Bgp_route.c (bgpd):6306
  /* print prefix and mask */
  route_vty_out_route (p, vty);

Bgp_route.c (bgpd):6361
route_vty_out_tag (struct vty *vty, struct prefix *p,
		   struct bgp_info *binfo, int display, safi_t safi)
{
Bgp_route.c (bgpd):6373
  /* print prefix and mask */
  if (! display)
    route_vty_out_route (p, vty);
Bgp_route.c (bgpd):6419
damp_route_vty_out (struct vty *vty, struct prefix *p,
		    struct bgp_info *binfo, int display, safi_t safi)
{
Bgp_route.c (bgpd):6429
  /* print prefix and mask */
  if (! display)
    route_vty_out_route (p, vty);
Bgp_route.c (bgpd):6460
flap_route_vty_out (struct vty *vty, struct prefix *p,
		    struct bgp_info *binfo, int display, safi_t safi)
{
Bgp_route.c (bgpd):6476
  /* print prefix and mask */
  if (! display)
    route_vty_out_route (p, vty);
Bgp_route.c (bgpd):6520
route_vty_out_detail (struct vty *vty, struct bgp *bgp, struct prefix *p, 
		      struct bgp_info *binfo, afi_t afi, safi_t safi)
{
Bgp_route.c (bgpd):6858
		struct prefix *p = output_arg;

		if (! prefix_match (p, &rn->p))
Bgp_route.c (bgpd):6927
		struct prefix *p = output_arg;

		if (! prefix_match (&rn->p, p))
Bgp_route.c (bgpd):7032
  struct prefix *p;
  struct peer *peer;
  struct listnode *node, *nnode;
Bgp_route.c (bgpd):7050
	   inet_ntop (p->family, &p->u.prefix, buf2, INET6_ADDRSTRLEN),
	   p->prefixlen, VTY_NEWLINE);

Bgp_route.c (bgpd):7118
  struct prefix match;
  struct bgp_node *rn;
  struct bgp_node *rm;
Bgp_route.c (bgpd):7124
  memset (&match, 0, sizeof (struct prefix)); /* keep valgrind happy */
  /* Check IP address argument. */
  ret = str2prefix (ip_str, &match);
Bgp_route.c (bgpd):7292
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display only the bestpath\n"
       "Display only multipaths\n")
Bgp_route.c (bgpd):7310
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display only the bestpath\n"
       "Display only multipaths\n")
Bgp_route.c (bgpd):7386
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  return bgp_show_route (vty, NULL, argv[0], AFI_IP, SAFI_UNICAST, NULL, 1, BGP_PATH_ALL);
Bgp_route.c (bgpd):7397
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display only the bestpath\n"
       "Display only multipaths\n")
Bgp_route.c (bgpd):7416
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  if (strncmp (argv[0], "m", 1) == 0)
Bgp_route.c (bgpd):7433
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display only the bestpath\n"
       "Display only multipaths\n")
Bgp_route.c (bgpd):7457
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display only the bestpath\n"
       "Display only multipaths\n")
Bgp_route.c (bgpd):7469
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  return bgp_show_route (vty, NULL, argv[0], AFI_IP, SAFI_MPLS_VPN, NULL, 1, BGP_PATH_ALL);
Bgp_route.c (bgpd):7483
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  int ret;
Bgp_route.c (bgpd):7540
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  return bgp_show_route (vty, argv[0], argv[1], AFI_IP, SAFI_UNICAST, NULL, 1, BGP_PATH_ALL);
Bgp_route.c (bgpd):7740
       "IPv6 prefix <network>/<length>\n"
       "Display only the bestpath\n"
       "Display only multipaths\n")
Bgp_route.c (bgpd):7756
       "IPv6 prefix <network>/<length>\n"
       "Display only the bestpath\n"
       "Display only multipaths\n")
Bgp_route.c (bgpd):7768
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Display only the bestpath\n"
       "Display only multipaths\n")
Bgp_route.c (bgpd):7872
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  return bgp_show_route (vty, NULL, argv[0], AFI_IP, SAFI_UNICAST, NULL, 1, BGP_PATH_ALL);
Bgp_route.c (bgpd):7885
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  if (strncmp (argv[0], "m", 1) == 0)
Bgp_route.c (bgpd):7900
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  return bgp_show_route (vty, NULL, argv[0], AFI_IP, SAFI_MPLS_VPN, NULL, 1, BGP_PATH_ALL);
Bgp_route.c (bgpd):7912
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  return bgp_show_route (vty, NULL, argv[0], AFI_IP6, SAFI_MPLS_VPN, NULL, 1, BGP_PATH_ALL);
Bgp_route.c (bgpd):7925
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  return bgp_show_route (vty, NULL, argv[0], AFI_IP, SAFI_ENCAP, NULL, 1, BGP_PATH_ALL);
Bgp_route.c (bgpd):7938
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  return bgp_show_route (vty, NULL, argv[0], AFI_IP6, SAFI_ENCAP, NULL, 1, BGP_PATH_ALL);
Bgp_route.c (bgpd):7953
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  int ret;
Bgp_route.c (bgpd):7983
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  int ret;
Bgp_route.c (bgpd):8084
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  safi_t	safi;
Bgp_route.c (bgpd):8179
       "IPv6 prefix <network>/<length>\n")
{
  return bgp_show_route (vty, NULL, argv[0], AFI_IP6, SAFI_UNICAST, NULL, 1, BGP_PATH_ALL);
Bgp_route.c (bgpd):8192
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n")
{
  return bgp_show_route (vty, NULL, argv[0], AFI_IP6, SAFI_UNICAST, NULL, 1, BGP_PATH_ALL);
Bgp_route.c (bgpd):8204
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n")
{
  if (strncmp (argv[0], "m", 1) == 0)
Bgp_route.c (bgpd):8219
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n")
{
  return bgp_show_route (vty, NULL, argv[0], AFI_IP6, SAFI_UNICAST, NULL, 1, BGP_PATH_ALL);
Bgp_route.c (bgpd):8323
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n")
{
  return bgp_show_route (vty, NULL, argv[0], AFI_IP6, SAFI_MULTICAST, NULL, 1, BGP_PATH_ALL);
Bgp_route.c (bgpd):8335
       "IPv6 prefix <network>/<length>\n")
{
  return bgp_show_route (vty, argv[0], argv[1], AFI_IP6, SAFI_UNICAST, NULL, 1, BGP_PATH_ALL);
Bgp_route.c (bgpd):8348
       "IPv6 prefix <network>/<length>\n")  
{
  return bgp_show_route (vty, argv[0], argv[1], AFI_IP6, SAFI_UNICAST, NULL, 1, BGP_PATH_ALL);
Bgp_route.c (bgpd):8643
      vty_out (vty, "%% %s is not a valid prefix-list name%s",
               prefix_list_str, VTY_NEWLINE);	    
      return CMD_WARNING;
Bgp_route.c (bgpd):8652
       "show ip bgp prefix-list WORD",
       SHOW_STR
       IP_STR
Bgp_route.c (bgpd):8656
       "Display routes conforming to the prefix-list\n"
       "IP prefix-list name\n")
{
  return bgp_show_prefix_list (vty, argv[0], AFI_IP, SAFI_UNICAST,
Bgp_route.c (bgpd):8665
       "show ip bgp flap-statistics prefix-list WORD",
       SHOW_STR
       IP_STR
Bgp_route.c (bgpd):8670
       "Display routes conforming to the prefix-list\n"
       "IP prefix-list name\n")
{
  return bgp_show_prefix_list (vty, argv[0], AFI_IP, SAFI_UNICAST,
Bgp_route.c (bgpd):8679
       "show ip bgp dampening flap-statistics prefix-list WORD",
       SHOW_STR
       IP_STR
Bgp_route.c (bgpd):8685
       "Display routes conforming to the prefix-list\n"
       "IP prefix-list name\n")

DEFUN (show_ip_bgp_ipv4_prefix_list, 
Bgp_route.c (bgpd):8690
       "show ip bgp ipv4 (unicast|multicast) prefix-list WORD",
       SHOW_STR
       IP_STR
Bgp_route.c (bgpd):8697
       "Display routes conforming to the prefix-list\n"
       "IP prefix-list name\n")
{
  if (strncmp (argv[0], "m", 1) == 0)
Bgp_route.c (bgpd):8710
       "show bgp prefix-list WORD",
       SHOW_STR
       BGP_STR
       "Display routes conforming to the prefix-list\n"
       "IPv6 prefix-list name\n")
{
  return bgp_show_prefix_list (vty, argv[0], AFI_IP6, SAFI_UNICAST,
Bgp_route.c (bgpd):8722
       "show bgp ipv6 prefix-list WORD",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):8726
       "Display routes conforming to the prefix-list\n"
       "IPv6 prefix-list name\n")

/* old command */
Bgp_route.c (bgpd):8732
       "show ipv6 bgp prefix-list WORD",
       SHOW_STR
       IPV6_STR
Bgp_route.c (bgpd):8736
       "Display routes matching the prefix-list\n"
       "IPv6 prefix-list name\n")
{
  return bgp_show_prefix_list (vty, argv[0], AFI_IP6, SAFI_UNICAST,
Bgp_route.c (bgpd):8746
       "show ipv6 mbgp prefix-list WORD",
       SHOW_STR
       IPV6_STR
Bgp_route.c (bgpd):8750
       "Display routes matching the prefix-list\n"
       "IPv6 prefix-list name\n")
{
  return bgp_show_prefix_list (vty, argv[0], AFI_IP6, SAFI_MULTICAST,
Bgp_route.c (bgpd):8759
       "show bgp ipv4 prefix-list WORD",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):8763
       "Display routes conforming to the prefix-list\n"
       "IP prefix-list name\n")
{
  return bgp_show_prefix_list (vty, argv[0], AFI_IP, SAFI_UNICAST,
Bgp_route.c (bgpd):8772
       "show bgp ipv4 (encap|multicast|unicast|vpn) flap-statistics prefix-list WORD",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):8781
       "Display routes conforming to the prefix-list\n"
       "IP prefix-list name\n")
{
  safi_t	safi;
Bgp_route.c (bgpd):8795
       "show bgp ipv4 (encap|multicast|unicast|vpn) dampening flap-statistics prefix-list WORD",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):8805
       "Display routes conforming to the prefix-list\n"
       "IP prefix-list name\n")

DEFUN (show_bgp_ipv6_safi_flap_prefix_list, 
Bgp_route.c (bgpd):8810
       "show bgp ipv6 (encap|multicast|unicast|vpn) flap-statistics prefix-list WORD",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):8819
       "Display routes conforming to the prefix-list\n"
       "IP prefix-list name\n")
{
  safi_t	safi;
Bgp_route.c (bgpd):8832
       "show bgp ipv6 (encap|multicast|unicast|vpn) dampening flap-statistics prefix-list WORD",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):8842
       "Display routes conforming to the prefix-list\n"
       "IP prefix-list name\n")

DEFUN (show_bgp_ipv4_safi_prefix_list, 
Bgp_route.c (bgpd):8847
       "show bgp ipv4 (encap|multicast|unicast|vpn) prefix-list WORD",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):8855
       "Display routes conforming to the prefix-list\n"
       "IP prefix-list name\n")
{
  safi_t	safi;
Bgp_route.c (bgpd):8869
       "show bgp ipv6 (encap|multicast|unicast|vpn) prefix-list WORD",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):8877
       "Display routes conforming to the prefix-list\n"
       "IP prefix-list name\n")
{
  safi_t	safi;
Bgp_route.c (bgpd):12542
bgp_show_prefix_longer (struct vty *vty, const char *prefix, afi_t afi,
			safi_t safi, enum bgp_show_type type)
{
Bgp_route.c (bgpd):12546
  struct prefix *p;

  p = prefix_new();
Bgp_route.c (bgpd):12550
  ret = str2prefix (prefix, p);
  if (! ret)
    {
Bgp_route.c (bgpd):12568
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display route and more specific routes\n")
{
Bgp_route.c (bgpd):12582
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display route and more specific routes\n")
{
Bgp_route.c (bgpd):12597
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display route and more specific routes\n")

Bgp_route.c (bgpd):12609
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display route and more specific routes\n")
{
Bgp_route.c (bgpd):12650
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  return bgp_show_prefix_longer (vty, argv[0], AFI_IP, SAFI_UNICAST,
Bgp_route.c (bgpd):12664
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")

DEFUN (show_bgp_prefix_longer,
Bgp_route.c (bgpd):12671
       "IPv6 prefix <network>/<length>\n"
       "Display route and more specific routes\n")
{
Bgp_route.c (bgpd):12685
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Display route and more specific routes\n")
{
Bgp_route.c (bgpd):12699
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Display route and more specific routes\n")
{
Bgp_route.c (bgpd):12712
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display route and more specific routes\n")
{
Bgp_route.c (bgpd):12730
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display route and more specific routes\n")
{
Bgp_route.c (bgpd):12755
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display route and more specific routes\n")

Bgp_route.c (bgpd):12769
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display route and more specific routes\n")
{
Bgp_route.c (bgpd):12793
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display route and more specific routes\n")

Bgp_route.c (bgpd):12806
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display route and more specific routes\n")
{
Bgp_route.c (bgpd):12830
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display route and more specific routes\n")
{
Bgp_route.c (bgpd):12927
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  safi_t	safi;
Bgp_route.c (bgpd):12951
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")

DEFUN (show_bgp_ipv6_safi_flap_prefix,
Bgp_route.c (bgpd):12964
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  safi_t	safi;
Bgp_route.c (bgpd):12988
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")

DEFUN (show_bgp_ipv6_prefix_longer,
Bgp_route.c (bgpd):12996
       "IPv6 prefix <network>/<length>\n"
       "Display route and more specific routes\n")
{
Bgp_route.c (bgpd):13073
  [BGP_STATS_TOTPLEN]             = "Average prefix length",
  [BGP_STATS_RIB]                 = "Total Advertisements",
  [BGP_STATS_UNAGGREGATEABLE]     = "Unaggregateable prefixes",
Bgp_route.c (bgpd):13155
      /* check if the prefix is included by any other announcements */
      while (prn && !prn->info)
        prn = bgp_node_parent_nolock (prn);
Bgp_route.c (bgpd):13490
                           inet_ntop(rn->p.family, &rn->p.u.prefix,
                                     buf, SU_ADDRSTRLEN),
                           rn->p.prefixlen,
Bgp_route.c (bgpd):13501
                           inet_ntop(rn->p.family, &rn->p.u.prefix,
                                     buf, SU_ADDRSTRLEN),
                           rn->p.prefixlen,
Bgp_route.c (bgpd):13557
       "show ip bgp neighbors (A.B.C.D|X:X::X:X) prefix-counts",
       SHOW_STR
       IP_STR
Bgp_route.c (bgpd):13564
       "Display detailed prefix count information\n")
{
  struct peer *peer;
Bgp_route.c (bgpd):13577
       "show bgp ipv6 neighbors (A.B.C.D|X:X::X:X) prefix-counts",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):13584
       "Display detailed prefix count information\n")
{
  struct peer *peer;
Bgp_route.c (bgpd):13597
       "show ip bgp ipv4 (unicast|multicast) neighbors (A.B.C.D|X:X::X:X) prefix-counts",
       SHOW_STR
       IP_STR
Bgp_route.c (bgpd):13607
       "Display detailed prefix count information\n")
{
  struct peer *peer;
Bgp_route.c (bgpd):13623
       "show ip bgp vpnv4 all neighbors (A.B.C.D|X:X::X:X) prefix-counts",
       SHOW_STR
       IP_STR
Bgp_route.c (bgpd):13633
       "Display detailed prefix count information\n")
{
  struct peer *peer;
Bgp_route.c (bgpd):13646
       "show bgp ipv4 (unicast|multicast) neighbors (A.B.C.D|X:X::X:X) prefix-counts",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):13657
       "Display detailed prefix count information\n")
{
  struct peer *peer;
Bgp_route.c (bgpd):13676
       "show bgp ipv6 (unicast|multicast) neighbors (A.B.C.D|X:X::X:X) prefix-counts",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):13687
       "Display detailed prefix count information\n")
{
  struct peer *peer;
Bgp_route.c (bgpd):13706
       "show ip bgp encap all neighbors (A.B.C.D|X:X::X:X) prefix-counts",
       SHOW_STR
       IP_STR
Bgp_route.c (bgpd):13716
       "Display detailed prefix count information\n")
{
  struct peer *peer;
Bgp_route.c (bgpd):14055
       "show bgp neighbors (A.B.C.D|X:X::X:X) received prefix-filter",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):14126
       "show bgp view WORD neighbors (A.B.C.D|X:X::X:X) received prefix-filter",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):14403
       "show ip bgp neighbors (A.B.C.D|X:X::X:X) received prefix-filter",
       SHOW_STR
       IP_STR
Bgp_route.c (bgpd):14442
       "show ip bgp ipv4 (unicast|multicast) neighbors (A.B.C.D|X:X::X:X) received prefix-filter",
       SHOW_STR
       IP_STR
Bgp_route.c (bgpd):14507
       "show bgp ipv4 (encap|multicast|unicast|vpn) neighbors (A.B.C.D|X:X::X:X) received prefix-filter",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):14555
       "show bgp ipv6 (encap|multicast|unicast|vpn) neighbors (A.B.C.D|X:X::X:X) received prefix-filter",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):14603
       "show bgp ipv6 neighbors (A.B.C.D|X:X::X:X) received prefix-filter",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):14642
       "show bgp view WORD ipv6 neighbors (A.B.C.D|X:X::X:X) received prefix-filter",
       SHOW_STR
       BGP_STR
Bgp_route.c (bgpd):15248
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  struct bgp *bgp;
Bgp_route.c (bgpd):15315
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  struct bgp *bgp;
Bgp_route.c (bgpd):15376
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")

ALIAS (show_bgp_view_ipv4_safi_rsclient_prefix,
Bgp_route.c (bgpd):15388
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")

DEFUN (show_bgp_view_ipv6_neighbor_routes,
Bgp_route.c (bgpd):16090
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n")
{
  struct bgp *bgp;
Bgp_route.c (bgpd):16153
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n")
{
  struct bgp *bgp;
Bgp_route.c (bgpd):16213
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n")

ALIAS (show_bgp_view_ipv6_rsclient_prefix,
Bgp_route.c (bgpd):16222
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n")

DEFUN (show_bgp_view_ipv6_safi_rsclient_prefix,
Bgp_route.c (bgpd):16236
       "IP prefix <network>/<length>, e.g., 3ffe::/16\n")
{
  struct bgp *bgp;
Bgp_route.c (bgpd):16303
       "IP prefix <network>/<length>, e.g., 3ffe::/16\n")

struct bgp_table *bgp_distance_table;
Bgp_route.c (bgpd):16309
  /* Distance value for the IP source prefix. */
  u_char distance;

Bgp_route.c (bgpd):16333
  struct prefix p;
  u_char distance;
  struct bgp_node *rn;
Bgp_route.c (bgpd):16341
      vty_out (vty, "Malformed prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Bgp_route.c (bgpd):16348
  rn = bgp_node_get (bgp_distance_table, (struct prefix *) &p);
  if (rn->info)
    {
Bgp_route.c (bgpd):16380
  struct prefix p;
  u_char distance;
  struct bgp_node *rn;
Bgp_route.c (bgpd):16388
      vty_out (vty, "Malformed prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Bgp_route.c (bgpd):16394
  rn = bgp_node_lookup (bgp_distance_table, (struct prefix *)&p);
  if (! rn)
    {
      vty_out (vty, "Can't find specified prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Bgp_route.c (bgpd):16422
bgp_distance_apply (struct prefix *p, struct bgp_info *rinfo, struct bgp *bgp)
{
  struct bgp_node *rn;
Bgp_route.c (bgpd):16444
  q.prefix = peer->su.sin.sin_addr;
  q.prefixlen = IPV4_MAX_BITLEN;

Bgp_route.c (bgpd):16448
  rn = bgp_node_match (bgp_distance_table, (struct prefix *) &q);
  if (rn)
    {
Bgp_route.c (bgpd):16497
ipv6_bgp_distance_apply (struct prefix *p, struct bgp_info *rinfo, struct bgp *bgp)
{
  struct bgp_node *rn;
Bgp_route.c (bgpd):16519
  q.prefix = peer->su.sin6.sin6_addr;
  q.prefixlen = IPV6_MAX_BITLEN;

Bgp_route.c (bgpd):16523
  rn = bgp_node_match (bgp_distance_table, (struct prefix *) &q);
  if (rn)
    {
Bgp_route.c (bgpd):16620
       "IP source prefix\n")
{
  bgp_distance_set (vty, argv[0], argv[1], NULL);
Bgp_route.c (bgpd):16632
       "IP source prefix\n")
{
  bgp_distance_unset (vty, argv[0], argv[1], NULL);
Bgp_route.c (bgpd):16643
       "IP source prefix\n"
       "Access list name\n")
{
Bgp_route.c (bgpd):16656
       "IP source prefix\n"
       "Access list name\n")
{
Bgp_route.c (bgpd):16715
       "IP source prefix\n")
{
  bgp_distance_set (vty, argv[0], argv[1], NULL);
Bgp_route.c (bgpd):16727
       "IP source prefix\n")
{
  bgp_distance_unset (vty, argv[0], argv[1], NULL);
Bgp_route.c (bgpd):16738
       "IP source prefix\n"
       "Access list name\n")
{
Bgp_route.c (bgpd):16751
       "IP source prefix\n"
       "Access list name\n")
{
Bgp_route.c (bgpd):17023
  struct prefix match;
  struct bgp_node *rn;
  struct bgp_node *rm;
Bgp_route.c (bgpd):17137
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  return bgp_clear_damp_route (vty, NULL, argv[0], AFI_IP,
Bgp_route.c (bgpd):17188
  struct prefix *p;
  struct prefix_rd *prd;
  struct bgp_static *bgp_static;
Bgp_route.c (bgpd):17212
		     inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN), 
		     p->prefixlen,
		     rdbuf, label);
Bgp_route.c (bgpd):17227
  struct prefix *p;
  struct bgp_static *bgp_static;
  struct bgp_aggregate *bgp_aggregate;
Bgp_route.c (bgpd):17253
		     inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN));

	    if ((IN_CLASSC (destination) && p->prefixlen == 24)
Bgp_route.c (bgpd):17268
		     inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN), 
		     p->prefixlen);
	  }
Bgp_route.c (bgpd):17298
		     inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
		     inet_ntoa (netmask));
	  }
Bgp_route.c (bgpd):17304
		     inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
		     p->prefixlen);
	  }
Bgp_route.h (bgpd):57
  /* Back pointer to the prefix node */
  struct bgp_node *net;

Bgp_route.h (bgpd):226
extern void bgp_redistribute_add (struct prefix *, const struct in_addr *,
				  const struct in6_addr *,
				  u_int32_t, u_char, route_tag_t);
extern void bgp_redistribute_delete (struct prefix *, u_char);
extern void bgp_redistribute_withdraw (struct bgp *, afi_t, int);

Bgp_route.h (bgpd):233
extern void bgp_static_update (struct bgp *, struct prefix *, struct bgp_static *,
			afi_t, safi_t);
extern void bgp_static_withdraw (struct bgp *, struct prefix *, afi_t, safi_t);
                     
extern int bgp_static_set_safi (safi_t safi, struct vty *vty, const char *,
Bgp_route.h (bgpd):244
extern int bgp_update (struct peer *, struct prefix *, struct attr *,
		       afi_t, safi_t, int, int, struct prefix_rd *, 
		       u_char *, int);
extern int bgp_withdraw (struct peer *, struct prefix *, struct attr *,
			 afi_t, safi_t, int, int, struct prefix_rd *, u_char *);

Bgp_route.h (bgpd):256
extern void bgp_aggregate_increment (struct bgp *, struct prefix *, struct bgp_info *,
			      afi_t, safi_t);
extern void bgp_aggregate_decrement (struct bgp *, struct prefix *, struct bgp_info *,
			      afi_t, safi_t);

extern u_char bgp_distance_apply (struct prefix *, struct bgp_info *, struct bgp *);
extern u_char ipv6_bgp_distance_apply (struct prefix *, struct bgp_info *, struct bgp *);

extern afi_t bgp_node_afi (struct vty *);
Bgp_route.h (bgpd):267
extern void route_vty_out (struct vty *, struct prefix *, struct bgp_info *, int, safi_t);
extern void route_vty_out_tag (struct vty *, struct prefix *, struct bgp_info *, int, safi_t);
extern void route_vty_out_tmp (struct vty *, struct prefix *, struct attr *, safi_t);

extern void bgp_peer_clear_node_queue_drain_immediate (struct peer *peer);
Bgp_routemap.c (bgpd):23
#include "prefix.h"
#include "filter.h"
#include "routemap.h"
Bgp_routemap.c (bgpd):68
       ip prefix-list   :  Done
       ipv6 address     :  Done
       ipv6 next-hop    :  Done
Bgp_routemap.c (bgpd):72
       ipv6 prefix-list :  Done
       length           :  (This will not be implemented by bgpd)
       metric           :  Done
Bgp_routemap.c (bgpd):237
route_match_peer (void *rule, struct prefix *prefix, route_map_object_t type,
      void *object)
{
Bgp_routemap.c (bgpd):329
route_match_ip_address (void *rule, struct prefix *prefix, 
			route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):341
      return (access_list_apply (alist, prefix) == FILTER_DENY ?
	      RMAP_NOMATCH : RMAP_MATCH);
    }
Bgp_routemap.c (bgpd):375
route_match_ip_next_hop (void *rule, struct prefix *prefix, 
			 route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):386
      p.prefix = bgp_info->attr->nexthop;
      p.prefixlen = IPV4_MAX_BITLEN;

Bgp_routemap.c (bgpd):427
route_match_ip_route_source (void *rule, struct prefix *prefix, 
			     route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):444
      p.prefix = peer->su.sin.sin_addr;
      p.prefixlen = IPV4_MAX_BITLEN;

Bgp_routemap.c (bgpd):481
/* `match ip address prefix-list PREFIX_LIST' */

static route_map_result_t
route_match_ip_address_prefix_list (void *rule, struct prefix *prefix, 
				    route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):495
      return (prefix_list_apply (plist, prefix) == PREFIX_DENY ?
	      RMAP_NOMATCH : RMAP_MATCH);
    }
Bgp_routemap.c (bgpd):515
  "ip address prefix-list",
  route_match_ip_address_prefix_list,
  route_match_ip_address_prefix_list_compile,
Bgp_routemap.c (bgpd):521
/* `match ip next-hop prefix-list PREFIX_LIST' */

static route_map_result_t
route_match_ip_next_hop_prefix_list (void *rule, struct prefix *prefix,
                                    route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):535
      p.prefix = bgp_info->attr->nexthop;
      p.prefixlen = IPV4_MAX_BITLEN;

Bgp_routemap.c (bgpd):562
  "ip next-hop prefix-list",
  route_match_ip_next_hop_prefix_list,
  route_match_ip_next_hop_prefix_list_compile,
Bgp_routemap.c (bgpd):568
/* `match ip route-source prefix-list PREFIX_LIST' */

static route_map_result_t
route_match_ip_route_source_prefix_list (void *rule, struct prefix *prefix,
					 route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):588
      p.prefix = peer->su.sin.sin_addr;
      p.prefixlen = IPV4_MAX_BITLEN;

Bgp_routemap.c (bgpd):615
  "ip route-source prefix-list",
  route_match_ip_route_source_prefix_list,
  route_match_ip_route_source_prefix_list_compile,
Bgp_routemap.c (bgpd):625
route_match_local_pref (void *rule, struct prefix *prefix,
			route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):691
route_match_metric (void *rule, struct prefix *prefix, 
		    route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):719
route_match_aspath (void *rule, struct prefix *prefix, 
		    route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):772
route_match_community (void *rule, struct prefix *prefix, 
		       route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):849
route_match_lcommunity (void *rule, struct prefix *prefix,
		       route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):921
route_match_ecommunity (void *rule, struct prefix *prefix,
			route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):973
route_match_origin (void *rule, struct prefix *prefix, 
		    route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):1027
route_match_probability (void *rule, struct prefix *prefix,
		    route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):1085
route_match_tag (void *rule, struct prefix *prefix,
                 route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):1123
route_set_ip_nexthop (void *rule, struct prefix *prefix,
		      route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):1221
route_set_local_pref (void *rule, struct prefix *prefix,
		      route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):1258
route_set_weight (void *rule, struct prefix *prefix, route_map_object_t type,
		  void *object)
{
Bgp_routemap.c (bgpd):1295
route_set_metric (void *rule, struct prefix *prefix, 
		  route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):1330
route_set_aspath_prepend (void *rule, struct prefix *prefix, route_map_object_t type, void *object)
{
  struct aspath *aspath;
Bgp_routemap.c (bgpd):1398
route_set_aspath_exclude (void *rule, struct prefix *dummy, route_map_object_t type, void *object)
{
  struct aspath * new_path, * exclude_path;
Bgp_routemap.c (bgpd):1435
route_set_community (void *rule, struct prefix *prefix,
		     route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):1560
route_set_lcommunity (void *rule, struct prefix *prefix,
		     route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):1681
route_set_lcommunity_delete (void *rule, struct prefix *prefix,
			     route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):1772
route_set_community_delete (void *rule, struct prefix *prefix,
			    route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):1861
route_set_ecommunity (void *rule, struct prefix *prefix,
		      route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):1957
route_set_origin (void *rule, struct prefix *prefix, route_map_object_t type, void *object)
{
  u_char *origin;
Bgp_routemap.c (bgpd):2011
route_set_atomic_aggregate (void *rule, struct prefix *prefix,
			    route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):2056
route_set_aggregator_as (void *rule, struct prefix *prefix, 
			 route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):2109
route_set_tag (void *rule, struct prefix *prefix,
               route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):2143
route_match_ipv6_address (void *rule, struct prefix *prefix, 
			  route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):2154
      return (access_list_apply (alist, prefix) == FILTER_DENY ?
	      RMAP_NOMATCH : RMAP_MATCH);
    }
Bgp_routemap.c (bgpd):2184
route_match_ipv6_next_hop (void *rule, struct prefix *prefix, 
			   route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):2242
/* `match ipv6 address prefix-list PREFIX_LIST' */

static route_map_result_t
route_match_ipv6_address_prefix_list (void *rule, struct prefix *prefix, 
			      route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):2256
      return (prefix_list_apply (plist, prefix) == PREFIX_DENY ?
	      RMAP_NOMATCH : RMAP_MATCH);
    }
Bgp_routemap.c (bgpd):2276
  "ipv6 address prefix-list",
  route_match_ipv6_address_prefix_list,
  route_match_ipv6_address_prefix_list_compile,
Bgp_routemap.c (bgpd):2286
route_set_ipv6_nexthop_global (void *rule, struct prefix *prefix, 
			       route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):2350
route_set_ipv6_nexthop_local (void *rule, struct prefix *prefix, 
			      route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):2414
route_set_ipv6_nexthop_peer (void *rule, struct prefix *prefix,
			     route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):2496
route_set_vpnv4_nexthop (void *rule, struct prefix *prefix, 
			 route_map_object_t type, void *object)
{
Bgp_routemap.c (bgpd):2554
route_set_originator_id (void *rule, struct prefix *prefix, route_map_object_t type, void *object)
{
  struct in_addr *address;
Bgp_routemap.c (bgpd):3016
       "match ip address prefix-list WORD",
       MATCH_STR
       IP_STR
Bgp_routemap.c (bgpd):3020
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")
{
  return bgp_route_match_add (vty, vty->index, "ip address prefix-list", argv[0]);
}

Bgp_routemap.c (bgpd):3028
       "no match ip address prefix-list",
       NO_STR
       MATCH_STR
Bgp_routemap.c (bgpd):3033
       "Match entries of prefix-lists\n")
{
  if (argc == 0)
    return bgp_route_match_delete (vty, vty->index, "ip address prefix-list", NULL);

  return bgp_route_match_delete (vty, vty->index, "ip address prefix-list", argv[0]);
}

Bgp_routemap.c (bgpd):3043
       "no match ip address prefix-list WORD",
       NO_STR
       MATCH_STR
Bgp_routemap.c (bgpd):3048
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")

DEFUN (match_ip_next_hop_prefix_list, 
Bgp_routemap.c (bgpd):3053
       "match ip next-hop prefix-list WORD",
       MATCH_STR
       IP_STR
Bgp_routemap.c (bgpd):3057
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")
{
  return bgp_route_match_add (vty, vty->index, "ip next-hop prefix-list", argv[0]);
}

Bgp_routemap.c (bgpd):3065
       "no match ip next-hop prefix-list",
       NO_STR
       MATCH_STR
Bgp_routemap.c (bgpd):3070
       "Match entries of prefix-lists\n")
{
  if (argc == 0)
    return bgp_route_match_delete (vty, vty->index, "ip next-hop prefix-list", NULL);

  return bgp_route_match_delete (vty, vty->index, "ip next-hop prefix-list", argv[0]);
}

Bgp_routemap.c (bgpd):3080
       "no match ip next-hop prefix-list WORD",
       NO_STR
       MATCH_STR
Bgp_routemap.c (bgpd):3085
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")

DEFUN (match_ip_route_source_prefix_list, 
Bgp_routemap.c (bgpd):3090
       "match ip route-source prefix-list WORD",
       MATCH_STR
       IP_STR
Bgp_routemap.c (bgpd):3094
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")
{
  return bgp_route_match_add (vty, vty->index, "ip route-source prefix-list", argv[0]);
}

Bgp_routemap.c (bgpd):3102
       "no match ip route-source prefix-list",
       NO_STR
       MATCH_STR
Bgp_routemap.c (bgpd):3107
       "Match entries of prefix-lists\n")
{
  if (argc == 0)
    return bgp_route_match_delete (vty, vty->index, "ip route-source prefix-list", NULL);

  return bgp_route_match_delete (vty, vty->index, "ip route-source prefix-list", argv[0]);
}

Bgp_routemap.c (bgpd):3117
       "no match ip route-source prefix-list WORD",
       NO_STR
       MATCH_STR
Bgp_routemap.c (bgpd):3122
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")

DEFUN (match_metric, 
Bgp_routemap.c (bgpd):4254
       "match ipv6 address prefix-list WORD",
       MATCH_STR
       IPV6_STR
Bgp_routemap.c (bgpd):4258
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")
{
  return bgp_route_match_add (vty, vty->index, "ipv6 address prefix-list", argv[0]);
}

Bgp_routemap.c (bgpd):4266
       "no match ipv6 address prefix-list WORD",
       NO_STR
       MATCH_STR
Bgp_routemap.c (bgpd):4271
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")
{
  return bgp_route_match_delete (vty, vty->index, "ipv6 address prefix-list", argv[0]);
}

Bgp_snmp.c (bgpd):29
#include "prefix.h"
#include "command.h"
#include "thread.h"
Bgp_snmp.c (bgpd):635
      /* Set OID offset for prefix. */
      offset = name + v->namelen;
      oid2in_addr (offset, IN_ADDR_SIZE, &addr->prefix);
      offset += IN_ADDR_SIZE;

Bgp_snmp.c (bgpd):650
			      (struct prefix *) addr);
      if (rn)
	{
Bgp_snmp.c (bgpd):673
	  oid2in_addr (offset, len, &addr->prefix);

	  offset += IN_ADDR_SIZE;
Bgp_snmp.c (bgpd):684
			       (struct prefix *) addr);

	  offset++;
Bgp_snmp.c (bgpd):736
	      addr->prefix = rn->p.u.prefix4;
	      addr->prefixlen = rn->p.prefixlen;

Bgp_snmp.c (bgpd):781
      return SNMP_IPADDRESS (addr.prefix);
      break;
    case BGP4PATHATTRORIGIN:	/* 4 */
Bgp_table.c (bgpd):23
#include "prefix.h"
#include "memory.h"
#include "sockunion.h"
Bgp_table.h (bgpd):189
bgp_node_get (struct bgp_table *const table, struct prefix *p)
{
  return bgp_node_from_rnode (route_node_get (table->route_table, p));
Bgp_table.h (bgpd):198
bgp_node_lookup (const struct bgp_table *const table, struct prefix *p)
{
  return bgp_node_from_rnode (route_node_lookup (table->route_table, p));
Bgp_table.h (bgpd):216
bgp_node_match (const struct bgp_table *table, struct prefix *p)
{
  return bgp_node_from_rnode (route_node_match (table->route_table, p));
Bgp_table.h (bgpd):251
bgp_table_get_next (const struct bgp_table *table, struct prefix *p)
{
  return bgp_node_from_rnode (route_table_get_next (table->route_table, p));
Bgp_vty.c (bgpd):24
#include "prefix.h"
#include "plist.h"
#include "buffer.h"
Bgp_vty.c (bgpd):2217
/* neighbor capability orf prefix-list. */
DEFUN (neighbor_capability_orf_prefix,
       neighbor_capability_orf_prefix_cmd,
       NEIGHBOR_CMD2 "capability orf prefix-list (both|send|receive)",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR2
Bgp_vty.c (bgpd):2247
       NO_NEIGHBOR_CMD2 "capability orf prefix-list (both|send|receive)",
       NO_STR
       NEIGHBOR_STR
Bgp_vty.c (bgpd):3798
/* Set prefix list to the peer. */
static int
peer_prefix_list_set_vty (struct vty *vty, const char *ip_str, afi_t afi,
Bgp_vty.c (bgpd):3848
       NEIGHBOR_CMD2 "prefix-list WORD (in|out)",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR2
Bgp_vty.c (bgpd):3852
       "Name of a prefix list\n"
       "Filter incoming updates\n"
       "Filter outgoing updates\n")
Bgp_vty.c (bgpd):3862
       NO_NEIGHBOR_CMD2 "prefix-list WORD (in|out)",
       NO_STR
       NEIGHBOR_STR
Bgp_vty.c (bgpd):3867
       "Name of a prefix list\n"
       "Filter incoming updates\n"
       "Filter outgoing updates\n")
Bgp_vty.c (bgpd):4148
/* Maximum number of prefix configuration.  prefix count is different
   for each peer configuration.  So this configuration can be set for
   each peer configuration. */
Bgp_vty.c (bgpd):4153
       NEIGHBOR_CMD2 "maximum-prefix <1-4294967295>",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR2
       "Maximum number of prefix accept from this peer\n"
       "maximum no. of prefix limit\n")
{
  return peer_maximum_prefix_set_vty (vty, argv[0], bgp_node_afi (vty),
Bgp_vty.c (bgpd):4166
       NEIGHBOR_CMD2 "maximum-prefix <1-4294967295> <1-100>",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR2
       "Maximum number of prefix accept from this peer\n"
       "maximum no. of prefix limit\n"
       "Threshold value (%) at which to generate a warning msg\n")
{
Bgp_vty.c (bgpd):4180
       NEIGHBOR_CMD2 "maximum-prefix <1-4294967295> warning-only",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR2
       "Maximum number of prefix accept from this peer\n"
       "maximum no. of prefix limit\n"
       "Only give warning message when limit is exceeded\n")
{
Bgp_vty.c (bgpd):4194
       NEIGHBOR_CMD2 "maximum-prefix <1-4294967295> <1-100> warning-only",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR2
       "Maximum number of prefix accept from this peer\n"
       "maximum no. of prefix limit\n"
       "Threshold value (%) at which to generate a warning msg\n"
       "Only give warning message when limit is exceeded\n")
Bgp_vty.c (bgpd):4208
       NEIGHBOR_CMD2 "maximum-prefix <1-4294967295> restart <1-65535>",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR2
       "Maximum number of prefix accept from this peer\n"
       "maximum no. of prefix limit\n"
       "Restart bgp connection after limit is exceeded\n"
       "Restart interval in minutes")
Bgp_vty.c (bgpd):4222
       NEIGHBOR_CMD2 "maximum-prefix <1-4294967295> <1-100> restart <1-65535>",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR2
       "Maximum number of prefix accept from this peer\n"
       "maximum no. of prefix limit\n"
       "Threshold value (%) at which to generate a warning msg\n"
       "Restart bgp connection after limit is exceeded\n"
Bgp_vty.c (bgpd):4237
       NO_NEIGHBOR_CMD2 "maximum-prefix",
       NO_STR
       NEIGHBOR_STR
Bgp_vty.c (bgpd):4241
       "Maximum number of prefix accept from this peer\n")
{
  return peer_maximum_prefix_unset_vty (vty, argv[0], bgp_node_afi (vty),
Bgp_vty.c (bgpd):4249
       NO_NEIGHBOR_CMD2 "maximum-prefix <1-4294967295>",
       NO_STR
       NEIGHBOR_STR
Bgp_vty.c (bgpd):4253
       "Maximum number of prefix accept from this peer\n"
       "maximum no. of prefix limit\n")

ALIAS (no_neighbor_maximum_prefix,
Bgp_vty.c (bgpd):4258
       NO_NEIGHBOR_CMD2 "maximum-prefix <1-4294967295> warning-only",
       NO_STR
       NEIGHBOR_STR
Bgp_vty.c (bgpd):4262
       "Maximum number of prefix accept from this peer\n"
       "maximum no. of prefix limit\n"
       "Threshold value (%) at which to generate a warning msg\n")

Bgp_vty.c (bgpd):4268
       NO_NEIGHBOR_CMD2 "maximum-prefix <1-4294967295> warning-only",
       NO_STR
       NEIGHBOR_STR
Bgp_vty.c (bgpd):4272
       "Maximum number of prefix accept from this peer\n"
       "maximum no. of prefix limit\n"
       "Only give warning message when limit is exceeded\n")

Bgp_vty.c (bgpd):4278
       NO_NEIGHBOR_CMD2 "maximum-prefix <1-4294967295> <1-100> warning-only",
       NO_STR
       NEIGHBOR_STR
Bgp_vty.c (bgpd):4282
       "Maximum number of prefix accept from this peer\n"
       "maximum no. of prefix limit\n"
       "Threshold value (%) at which to generate a warning msg\n"
       "Only give warning message when limit is exceeded\n")
Bgp_vty.c (bgpd):4289
       NO_NEIGHBOR_CMD2 "maximum-prefix <1-4294967295> restart <1-65535>",
       NO_STR
       NEIGHBOR_STR
Bgp_vty.c (bgpd):4293
       "Maximum number of prefix accept from this peer\n"
       "maximum no. of prefix limit\n"
       "Restart bgp connection after limit is exceeded\n"
       "Restart interval in minutes")
Bgp_vty.c (bgpd):4300
       NO_NEIGHBOR_CMD2 "maximum-prefix <1-4294967295> <1-100> restart <1-65535>",
       NO_STR
       NEIGHBOR_STR
Bgp_vty.c (bgpd):4304
       "Maximum number of prefix accept from this peer\n"
       "maximum no. of prefix limit\n"
       "Threshold value (%) at which to generate a warning msg\n"
       "Restart bgp connection after limit is exceeded\n"
Bgp_vty.c (bgpd):4698
/* Recalculate bestpath and re-advertise a prefix */
static int
bgp_clear_prefix (struct vty *vty, char *view_name, const char *ip_str,
Bgp_vty.c (bgpd):4704
  struct prefix match;
  struct bgp_node *rn;
  struct bgp_node *rm;
Bgp_vty.c (bgpd):4943
       "clear ip bgp prefix A.B.C.D/M",
       CLEAR_STR
       IP_STR
Bgp_vty.c (bgpd):4948
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  return bgp_clear_prefix (vty, NULL, argv[0], AFI_IP, SAFI_UNICAST, NULL);
Bgp_vty.c (bgpd):4955
       "clear bgp prefix A.B.C.D/M",
       CLEAR_STR
       BGP_STR
Bgp_vty.c (bgpd):4959
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")


Bgp_vty.c (bgpd):5194
       "clear bgp ipv6 (unicast|multicast) prefix X:X::X:X/M",
       CLEAR_STR
       BGP_STR
Bgp_vty.c (bgpd):5200
       "IPv6 prefix <network>/<length>,  e.g.,  3ffe::/16\n")
{
  if (strncmp (argv[0], "m", 1) == 0)
Bgp_vty.c (bgpd):5754
       "clear ip bgp * in prefix-filter",
       CLEAR_STR
       IP_STR
Bgp_vty.c (bgpd):5760
       "Push out prefix-list ORF and do inbound soft reconfig\n")
{
  if (argc== 1)
Bgp_vty.c (bgpd):5772
       "clear ip bgp view WORD * in prefix-filter",
       CLEAR_STR
       IP_STR
Bgp_vty.c (bgpd):5780
       "Push out prefix-list ORF and do inbound soft reconfig\n")


Bgp_vty.c (bgpd):5841
       "clear ip bgp * ipv4 (unicast|multicast) in prefix-filter",
       CLEAR_STR
       IP_STR
Bgp_vty.c (bgpd):5850
       "Push out prefix-list ORF and do inbound soft reconfig\n")
{
  if (strncmp (argv[0], "m", 1) == 0)
Bgp_vty.c (bgpd):5862
       "clear ip bgp view WORD * ipv4 (unicast|multicast) in prefix-filter",
       CLEAR_STR
       IP_STR
Bgp_vty.c (bgpd):5871
       "Push out prefix-list ORF and do inbound soft reconfig\n")
{
  if (strncmp (argv[1], "m", 1) == 0)
Bgp_vty.c (bgpd):5992
       "clear bgp * in prefix-filter",
       CLEAR_STR
       BGP_STR
Bgp_vty.c (bgpd):5997
       "Push out prefix-list ORF and do inbound soft reconfig\n")
{
  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_all,
Bgp_vty.c (bgpd):6005
       "clear bgp ipv6 * in prefix-filter",
       CLEAR_STR
       BGP_STR
Bgp_vty.c (bgpd):6011
       "Push out prefix-list ORF and do inbound soft reconfig\n")

DEFUN (clear_ip_bgp_peer_soft_in,
Bgp_vty.c (bgpd):6038
       "clear ip bgp A.B.C.D in prefix-filter",
       CLEAR_STR
       IP_STR
Bgp_vty.c (bgpd):6044
       "Push out the existing ORF prefix-list\n")
{
  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,
Bgp_vty.c (bgpd):6085
       "clear ip bgp A.B.C.D ipv4 (unicast|multicast) in prefix-filter",
       CLEAR_STR
       IP_STR
Bgp_vty.c (bgpd):6094
       "Push out the existing ORF prefix-list\n")
{
  if (strncmp (argv[1], "m", 1) == 0)
Bgp_vty.c (bgpd):6204
       "clear bgp (A.B.C.D|X:X::X:X) in prefix-filter",
       CLEAR_STR
       BGP_STR
Bgp_vty.c (bgpd):6210
       "Push out the existing ORF prefix-list\n")
{
  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_peer,
Bgp_vty.c (bgpd):6218
       "clear bgp ipv6 (A.B.C.D|X:X::X:X) in prefix-filter",
       CLEAR_STR
       BGP_STR
Bgp_vty.c (bgpd):6225
       "Push out the existing ORF prefix-list\n")

DEFUN (clear_ip_bgp_peer_group_soft_in,
Bgp_vty.c (bgpd):6254
       "clear ip bgp peer-group WORD in prefix-filter",
       CLEAR_STR
       IP_STR
Bgp_vty.c (bgpd):6261
       "Push out prefix-list ORF and do inbound soft reconfig\n")
{
  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,
Bgp_vty.c (bgpd):6304
       "clear ip bgp peer-group WORD ipv4 (unicast|multicast) in prefix-filter",
       CLEAR_STR
       IP_STR
Bgp_vty.c (bgpd):6314
       "Push out prefix-list ORF and do inbound soft reconfig\n")
{
  if (strncmp (argv[1], "m", 1) == 0)
Bgp_vty.c (bgpd):6370
       "clear bgp peer-group WORD in prefix-filter",
       CLEAR_STR
       BGP_STR
Bgp_vty.c (bgpd):6376
       "Push out prefix-list ORF and do inbound soft reconfig\n")
{
  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_group,
Bgp_vty.c (bgpd):6384
       "clear bgp ipv6 peer-group WORD in prefix-filter",
       CLEAR_STR
       BGP_STR
Bgp_vty.c (bgpd):6391
       "Push out prefix-list ORF and do inbound soft reconfig\n")

DEFUN (clear_ip_bgp_external_soft_in,
Bgp_vty.c (bgpd):6418
       "clear ip bgp external in prefix-filter",
       CLEAR_STR
       IP_STR
Bgp_vty.c (bgpd):6424
       "Push out prefix-list ORF and do inbound soft reconfig\n")
{
  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,
Bgp_vty.c (bgpd):6465
       "clear ip bgp external ipv4 (unicast|multicast) in prefix-filter",
       CLEAR_STR
       IP_STR
Bgp_vty.c (bgpd):6474
       "Push out prefix-list ORF and do inbound soft reconfig\n")
{
  if (strncmp (argv[0], "m", 1) == 0)
Bgp_vty.c (bgpd):6526
       "clear bgp external in prefix-filter",
       CLEAR_STR
       BGP_STR
Bgp_vty.c (bgpd):6531
       "Push out prefix-list ORF and do inbound soft reconfig\n")
{
  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_external,
Bgp_vty.c (bgpd):6539
       "clear bgp ipv6 external in prefix-filter",
       CLEAR_STR
       BGP_STR
Bgp_vty.c (bgpd):6545
       "Push out prefix-list ORF and do inbound soft reconfig\n")

DEFUN (clear_ip_bgp_as_soft_in,
Bgp_vty.c (bgpd):6572
       "clear ip bgp " CMD_AS_RANGE " in prefix-filter",
       CLEAR_STR
       IP_STR
Bgp_vty.c (bgpd):6578
       "Push out prefix-list ORF and do inbound soft reconfig\n")
{
  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,
Bgp_vty.c (bgpd):6619
       "clear ip bgp " CMD_AS_RANGE " ipv4 (unicast|multicast) in prefix-filter",
       CLEAR_STR
       IP_STR
Bgp_vty.c (bgpd):6628
       "Push out prefix-list ORF and do inbound soft reconfig\n")
{
  if (strncmp (argv[1], "m", 1) == 0)
Bgp_vty.c (bgpd):6734
       "clear bgp " CMD_AS_RANGE " in prefix-filter",
       CLEAR_STR
       BGP_STR
Bgp_vty.c (bgpd):6739
       "Push out prefix-list ORF and do inbound soft reconfig\n")
{
  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_as,
Bgp_vty.c (bgpd):6747
       "clear bgp ipv6 " CMD_AS_RANGE " in prefix-filter",
       CLEAR_STR
       BGP_STR
Bgp_vty.c (bgpd):6753
       "Push out prefix-list ORF and do inbound soft reconfig\n")

/* Both soft-reconfiguration */
Bgp_vty.c (bgpd):8310
  /* prefix-list */
  if (filter->plist[FILTER_IN].name)
    vty_out (vty, "  Incoming update prefix filter list is %s%s%s",
	     filter->plist[FILTER_IN].plist ? "*" : "",
	     filter->plist[FILTER_IN].name,
Bgp_vty.c (bgpd):8317
    vty_out (vty, "  Outgoing update prefix filter list is %s%s%s",
	     filter->plist[FILTER_OUT].plist ? "*" : "",
	     filter->plist[FILTER_OUT].name,
Bgp_vty.c (bgpd):8374
  /* Receive prefix count */
  vty_out (vty, "  %ld accepted prefixes%s", p->pcount[afi][safi], VTY_NEWLINE);

  /* Maximum prefix */
  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_MAX_PREFIX))
    {
Bgp_vty.c (bgpd):8692
	vty_out (vty, "  Reduce the no. of prefix from %s, will restart in %ld seconds%s",
		 p->host, thread_timer_remain_second (p->t_pmax_restart),
		 VTY_NEWLINE);
Bgp_vty.c (bgpd):8696
	vty_out (vty, "  Reduce the no. of prefix and clear ip bgp %s to restore peering%s",
		 p->host, VTY_NEWLINE);
    }
Bgp_vty.c (bgpd):10609
  /* "neighbor capability orf prefix-list" commands.*/
  install_element (BGP_NODE, &neighbor_capability_orf_prefix_cmd);
  install_element (BGP_NODE, &no_neighbor_capability_orf_prefix_cmd);
Bgp_vty.c (bgpd):10731
  /* "neighbor prefix-list" commands. */
  install_element (BGP_NODE, &neighbor_prefix_list_cmd);
  install_element (BGP_NODE, &no_neighbor_prefix_list_cmd);
Bgp_vty.c (bgpd):10811
  /* "neighbor maximum-prefix" commands. */
  install_element (BGP_NODE, &neighbor_maximum_prefix_cmd);
  install_element (BGP_NODE, &neighbor_maximum_prefix_threshold_cmd);
Bgp_vty.c (bgpd):11085
  /* clear ip bgp prefix  */
  install_element (ENABLE_NODE, &clear_ip_bgp_prefix_cmd);
  install_element (ENABLE_NODE, &clear_bgp_ipv6_safi_prefix_cmd);
Bgp_zebra.c (bgpd):26
#include "prefix.h"
#include "log.h"
#include "sockunion.h"
Bgp_zebra.c (bgpd):60
  struct prefix router_id;

  zebra_router_id_update_read(zclient->ibuf,&router_id);
Bgp_zebra.c (bgpd):260
  /* IPv4 prefix. */
  memset (&p, 0, sizeof (struct prefix_ipv4));
  p.family = AF_INET;
Bgp_zebra.c (bgpd):265
  stream_get (&p.prefix, s, PSIZE (p.prefixlen));

  /* Nexthop, ifindex, distance, metric. */
Bgp_zebra.c (bgpd):297
		     inet_ntop(AF_INET, &p.prefix, buf[0], sizeof(buf[0])),
		     p.prefixlen,
		     inet_ntop(AF_INET, &nexthop, buf[1], sizeof(buf[1])),
Bgp_zebra.c (bgpd):303
      bgp_redistribute_add ((struct prefix *)&p, &nexthop, NULL,
			    api.metric, api.type, api.tag);
    }
Bgp_zebra.c (bgpd):314
		     inet_ntop(AF_INET, &p.prefix, buf[0], sizeof(buf[0])),
		     p.prefixlen,
		     inet_ntop(AF_INET, &nexthop, buf[1], sizeof(buf[1])),
Bgp_zebra.c (bgpd):320
      bgp_redistribute_delete((struct prefix *)&p, api.type);
    }

Bgp_zebra.c (bgpd):345
  /* IPv6 prefix. */
  memset (&p, 0, sizeof (struct prefix_ipv6));
  p.family = AF_INET6;
Bgp_zebra.c (bgpd):350
  stream_get (&p.prefix, s, PSIZE (p.prefixlen));

  /* Nexthop, ifindex, distance, metric. */
Bgp_zebra.c (bgpd):378
  if (IN6_IS_ADDR_LINKLOCAL (&p.prefix))
    return 0;

Bgp_zebra.c (bgpd):388
		     inet_ntop(AF_INET6, &p.prefix, buf[0], sizeof(buf[0])),
		     p.prefixlen,
		     inet_ntop(AF_INET, &nexthop, buf[1], sizeof(buf[1])),
Bgp_zebra.c (bgpd):394
      bgp_redistribute_add ((struct prefix *)&p, NULL, &nexthop,
			    api.metric, api.type, api.tag);
    }
Bgp_zebra.c (bgpd):405
		     inet_ntop(AF_INET6, &p.prefix, buf[0], sizeof(buf[0])),
		     p.prefixlen,
		     inet_ntop(AF_INET6, &nexthop, buf[1], sizeof(buf[1])),
Bgp_zebra.c (bgpd):411
      bgp_redistribute_delete ((struct prefix *) &p, api.type);
    }
  
Bgp_zebra.c (bgpd):425
  struct prefix *cp; 
  
  p.family = AF_INET;
  p.prefix = *addr;
  p.prefixlen = IPV4_MAX_BITLEN;

Bgp_zebra.c (bgpd):438
	    if (prefix_match (cp, (struct prefix *)&p))
	      return ifp;
	}
Bgp_zebra.c (bgpd):452
  struct prefix *cp; 
  
  for (ALL_LIST_ELEMENTS_RO (iflist, ifnode, ifp))
Bgp_zebra.c (bgpd):476
  struct prefix *cp; 
  
  p.family = AF_INET6;
  p.prefix = *addr;
  p.prefixlen = IPV6_MAX_BITLEN;

Bgp_zebra.c (bgpd):489
	    if (prefix_match (cp, (struct prefix *)&p))
	      return ifp;
	}
Bgp_zebra.c (bgpd):503
  struct prefix *cp; 

  for (ALL_LIST_ELEMENTS_RO (iflist, ifnode, ifp))
Bgp_zebra.c (bgpd):524
  struct prefix *cp; 
  
  for (ALL_LIST_ELEMENTS_RO (ifp->connected, cnode, connected))
Bgp_zebra.c (bgpd):545
  struct prefix *cp; 
  
  for (ALL_LIST_ELEMENTS_RO (ifp->connected, cnode, connected))
Bgp_zebra.c (bgpd):566
  struct prefix *cp;

  for (ALL_LIST_ELEMENTS_RO (ifp->connected, cnode, connected))
Bgp_zebra.c (bgpd):693
bgp_zebra_announce (struct prefix *p, struct bgp_info *info, struct bgp *bgp, safi_t safi)
{
  int flags;
Bgp_zebra.c (bgpd):976
bgp_zebra_withdraw (struct prefix *p, struct bgp_info *info, safi_t safi)
{
  int flags;
Bgp_zebra.h (bgpd):38
extern void bgp_zebra_announce (struct prefix *, struct bgp_info *, struct bgp *, safi_t);
extern void bgp_zebra_withdraw (struct prefix *, struct bgp_info *, safi_t);

extern int bgp_redistribute_set (struct bgp *, afi_t, int);
Command.h (lib):513
#define PREFIX_LIST_STR "Build a prefix list\n"
#define OSPF6_DUMP_TYPE_LIST \
"(neighbor|interface|area|lsa|zebra|config|dbex|spf|route|lsdb|redistribute|hook|asbr|prefix|abr)"
#define ISIS_STR "IS-IS information\n"
#define AREA_TAG_STR "[area tag]\n"
Connected.c (zebra):25
#include "prefix.h"
#include "linklist.h"
#include "if.h"
Connected.c (zebra):110
connected_check (struct interface *ifp, struct prefix *p)
{
  struct connected *ifc;
Connected.c (zebra):157
  if ((current = connected_check (ifp, (struct prefix *) ifc->address)))
    {
      if (CHECK_FLAG(current->conf, ZEBRA_IFC_CONFIGURED))
Connected.c (zebra):231
  p->prefix = *addr;
  p->prefixlen = prefixlen;
  ifc->address = (struct prefix *) p;
  
  /* If there is broadcast or peer address. */
Connected.c (zebra):240
      p->prefix = *broad;
      p->prefixlen = prefixlen;
      ifc->destination = (struct prefix *) p;

      /* validate the destination address */
Connected.c (zebra):334
  p.prefix = *addr;
  p.prefixlen = prefixlen;

  ifc = connected_check (ifp, (struct prefix *) &p);
  if (! ifc)
    return;
Connected.c (zebra):362
  if (IN6_IS_ADDR_UNSPECIFIED (&p.prefix))
    return;
#endif
Connected.c (zebra):392
  IPV6_ADDR_COPY (&p->prefix, addr);
  p->prefixlen = prefixlen;
  ifc->address = (struct prefix *) p;

  /* If there is broadcast or peer address. */
Connected.c (zebra):406
	  IPV6_ADDR_COPY (&p->prefix, broad);
	  p->prefixlen = prefixlen;
	  ifc->destination = (struct prefix *) p;
	}
    }
Connected.c (zebra):446
  if (IN6_IS_ADDR_UNSPECIFIED (&p.prefix))
    return;

Connected.c (zebra):464
  memcpy (&p.prefix, address, sizeof (struct in6_addr));
  p.prefixlen = prefixlen;

  ifc = connected_check (ifp, (struct prefix *) &p);
  if (! ifc)
    return;
Connected.h (zebra):27
connected_check (struct interface *ifp, struct prefix *p);

extern void
Distribute.c (lib):57
    if (dist->prefix[i])
      free(dist->prefix[i]);

  XFREE (MTYPE_DISTRIBUTE, dist);
Distribute.c (lib):68
    if (dist->list[i] != NULL || dist->prefix[i] != NULL)
      return;

Distribute.c (lib):204
  if (dist->prefix[type])
    free (dist->prefix[type]);
  dist->prefix[type] = strdup (plist_name);

  /* Apply this distribute-list to the interface. */
Distribute.c (lib):226
  if (!dist->prefix[type])
    return 0;
  if (strcmp (dist->prefix[type], plist_name) != 0)
    return 0;

  free (dist->prefix[type]);
  dist->prefix[type] = NULL;

  /* Apply this distribute-list to the interface. */
Distribute.c (lib):523
       "distribute-list prefix WORD (in|out)",
       "Filter networks in routing updates\n"
       "Filter prefixes in routing updates\n"
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n")
Distribute.c (lib):552
       "ipv6 distribute-list prefix WORD (in|out)",
       "Filter networks in routing updates\n"
       "Filter prefixes in routing updates\n"
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n")
Distribute.c (lib):581
       "distribute-list prefix WORD (in|out)",
       "Filter networks in routing updates\n"
       "Filter prefixes in routing updates\n"
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n")
Distribute.c (lib):590
       "no distribute-list prefix WORD (in|out)",
       NO_STR
       "Filter networks in routing updates\n"
Distribute.c (lib):594
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n")
Distribute.c (lib):624
       "no ipv6 distribute-list prefix WORD (in|out)",
       NO_STR
       "Filter networks in routing updates\n"
Distribute.c (lib):628
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n")
Distribute.c (lib):658
       "no distribute-list prefix WORD (in|out)",
       NO_STR
       "Filter networks in routing updates\n"
Distribute.c (lib):662
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n")
Distribute.c (lib):667
       "distribute-list prefix WORD (in|out) WORD",
       "Filter networks in routing updates\n"
       "Filter prefixes in routing updates\n"
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n"
Distribute.c (lib):697
       "ipv6 distribute-list prefix WORD (in|out) WORD",
       "Filter networks in routing updates\n"
       "Filter prefixes in routing updates\n"
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n"
Distribute.c (lib):727
       "distribute-list prefix WORD (in|out) WORD",
       "Filter networks in routing updates\n"
       "Filter prefixes in routing updates\n"
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n"
Distribute.c (lib):736
       "no distribute-list prefix WORD (in|out) WORD",
       NO_STR
       "Filter networks in routing updates\n"
Distribute.c (lib):740
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n"
Distribute.c (lib):771
       "no ipv6 distribute-list prefix WORD (in|out) WORD",
       NO_STR
       "Filter networks in routing updates\n"
Distribute.c (lib):775
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n"
Distribute.c (lib):806
       "no distribute-list prefix WORD (in|out) WORD",
       NO_STR
       "Filter networks in routing updates\n"
Distribute.c (lib):810
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n"
Distribute.c (lib):822
             is_prefix ? "(prefix-list) " : "",
             tab[type]);
    return 1;
Distribute.c (lib):845
      has_print = distribute_print(vty, dist->prefix, 1,
                                   DISTRIBUTE_V4_OUT, has_print);
      has_print = distribute_print(vty, dist->list,   0,
Distribute.c (lib):849
      has_print = distribute_print(vty, dist->prefix, 1,
                                   DISTRIBUTE_V6_OUT, has_print);
    }
Distribute.c (lib):867
            has_print = distribute_print(vty, dist->prefix, 1,
                                         DISTRIBUTE_V4_OUT, has_print);
            has_print = distribute_print(vty, dist->list,   0,
Distribute.c (lib):871
            has_print = distribute_print(vty, dist->prefix, 1,
                                         DISTRIBUTE_V6_OUT, has_print);
            if (has_print)
Distribute.c (lib):889
      has_print = distribute_print(vty, dist->prefix, 1,
                                   DISTRIBUTE_V4_IN, has_print);
      has_print = distribute_print(vty, dist->list,   0,
Distribute.c (lib):893
      has_print = distribute_print(vty, dist->prefix, 1,
                                   DISTRIBUTE_V6_IN, has_print);
    }
Distribute.c (lib):911
            has_print = distribute_print(vty, dist->prefix, 1,
                                         DISTRIBUTE_V4_IN, has_print);
            has_print = distribute_print(vty, dist->list,   0,
Distribute.c (lib):915
            has_print = distribute_print(vty, dist->prefix, 1,
                                         DISTRIBUTE_V6_IN, has_print);
            if (has_print)
Distribute.c (lib):957
	  if (dist->prefix[j]) {
	    output = j == DISTRIBUTE_V4_OUT || j == DISTRIBUTE_V6_OUT;
            v6 = j == DISTRIBUTE_V6_IN || j == DISTRIBUTE_V6_OUT;
	    vty_out (vty, " %sdistribute-list prefix %s %s %s%s",
                     v6 ? "ipv6 " : "",
		     dist->prefix[j],
		     output ? "out" : "in",
		     dist->ifname ? dist->ifname : "",
Distribute.h (lib):47
  /* prefix-list name of `in' and `out' */
  char *prefix[DISTRIBUTE_MAX];
};

Distribute.h (lib):60
extern enum filter_type distribute_apply_in (struct interface *, struct prefix *);
extern enum filter_type distribute_apply_out (struct interface *, struct prefix *);

#endif /* _ZEBRA_DISTRIBUTE_H */
Draft-zebra-00.txt (doc):91
   After above message there can be variale length IPv4 prefix data.
   Each IPv4 prefix is encoded as a two tuple of the form <masklength,
   prefix>


Draft-zebra-00.txt (doc):99
     |IPv4 prefix (variable)|
     +----------------------+

Draft-zebra-00.txt (doc):160
     |IPv6 prefix (variable)|
     +----------------------+

Filter.c (lib):24
#include "prefix.h"
#include "filter.h"
#include "memory.h"
Filter.c (lib):48
  struct prefix prefix;
};

Filter.c (lib):161
/* If filter match to the prefix then return 1. */
static int
filter_match_cisco (struct filter *mfilter, struct prefix *p)
{
  struct filter_cisco *filter;
Filter.c (lib):188
/* If filter match to the prefix then return 1. */
static int
filter_match_zebra (struct filter *mfilter, struct prefix *p)
{
  struct filter_zebra *filter;
Filter.c (lib):196
  if (filter->prefix.family == p->family)
    {
      if (filter->exact)
Filter.c (lib):200
	  if (filter->prefix.prefixlen == p->prefixlen)
	    return prefix_match (&filter->prefix, p);
	  else
	    return 0;
Filter.c (lib):206
	return prefix_match (&filter->prefix, p);
    }
  else
Filter.c (lib):398
/* Apply access list to object (which should be struct prefix *). */
enum filter_type
access_list_apply (struct access_list *access, void *object)
Filter.c (lib):403
  struct prefix *p;

  p = (struct prefix *) object;

  if (access == NULL)
Filter.c (lib):566
	  && prefix_same (&filter->prefix, &new->prefix))
	return mfilter;
    }
Filter.c (lib):1165
  struct prefix p;

  /* Check of filter type. */
Filter.c (lib):1178
  /* Check string format of prefix and prefixlen. */
  if (afi == AFI_IP)
    {
Filter.c (lib):1184
	  vty_out (vty, "IP address prefix/prefixlen is malformed%s",
		   VTY_NEWLINE);
	  return CMD_WARNING;
Filter.c (lib):1195
	  vty_out (vty, "IPv6 address prefix/prefixlen is malformed%s",
		   VTY_NEWLINE);
		   return CMD_WARNING;
Filter.c (lib):1207
  prefix_copy (&filter->prefix, &p);

  /* "exact-match" */
Filter.c (lib):1774
  struct prefix *p;
  char buf[BUFSIZ];

Filter.c (lib):1778
  p = &filter->prefix;

  if (p->prefixlen == 0 && ! filter->exact)
Filter.c (lib):1784
	     inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
	     p->prefixlen,
	     filter->exact ? " exact-match" : "");
Fpm.h (fpm):66
 * protocols for each prefix. This latter information comprises the
 * bulk of the Forwarding Information Base.
 *
Fpm.h (fpm):81
 * message for a prefix is followed by another 'route add' message, the
 * information in the second message is complete by itself, and replaces
 * the information sent in the first message.
Fpm_pb.h (fpm):43
fpm__route_key__create (qpb_allocator_t *allocator, struct prefix *prefix)
{
  Fpm__RouteKey *key;
Fpm_pb.h (fpm):54
  key->prefix = qpb__l3_prefix__create (allocator, prefix);
  if (!key->prefix)
    {
      return NULL;
If.c (lib):33
#include "prefix.h"
#include "memory.h"
#include "table.h"
If.c (lib):53
 * alphabetic prefix and a numeric suffix.  The primary sort key is
 * lexicographic by name, and then numeric by number.  No number sorts
 * before all numbers.  Examples: de0 < de1, de100 < fxp0 < xl0, devpty <
If.c (lib):295
  struct prefix *p;
  struct connected *c;

If.c (lib):325
  struct prefix addr;
  int bestlen = 0;
  struct listnode *cnode;
If.c (lib):360
/* Lookup interface by prefix */
struct interface *
if_lookup_prefix_vrf (struct prefix *prefix, vrf_id_t vrf_id)
{
  struct listnode *node;
If.c (lib):373
          if (prefix_cmp(c->address, prefix) == 0)
            {
              return ifp;
If.c (lib):383
if_lookup_prefix (struct prefix *prefix)
{
  return if_lookup_prefix_vrf (prefix, VRF_DEFAULT);
}

If.c (lib):725
  struct prefix *p;
  vrf_id_t vrf_id = VRF_DEFAULT;

If.c (lib):764
  struct prefix *p;
  vrf_iter_t iter;

If.c (lib):818
  struct prefix *p;
  struct interface *ifp;
  char logbuf[BUFSIZ];
If.c (lib):828
	    inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
	    p->prefixlen);

If.c (lib):834
      strncat (logbuf, inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
	       BUFSIZ - strlen(logbuf));
    }
If.c (lib):840
/* If two connected address has same prefix return 1. */
static int
connected_same_prefix (struct prefix *p1, struct prefix *p2)
{
  if (p1->family == p2->family)
If.c (lib):859
connected_delete_by_prefix (struct interface *ifp, struct prefix *p)
{
  struct listnode *node;
If.c (lib):865
  /* In case of same prefix come, replace it with new one. */
  for (node = listhead (ifp->connected); node; node = next)
    {
If.c (lib):885
  struct prefix addr;
  struct listnode *cnode;
  struct connected *c;
If.c (lib):907
connected_add_by_prefix (struct interface *ifp, struct prefix *p, 
                         struct prefix *destination)
{
  struct connected *ifc;
If.c (lib):918
  memcpy (ifc->address, p, sizeof(struct prefix));

  /* Fetch dest address */
If.c (lib):924
      memcpy (ifc->destination, destination, sizeof(struct prefix));
    }

If.c (lib):973
  p.prefix = *ifaddr;

  rn = route_node_get (ifaddr_ipv4_table, (struct prefix *) &p);
  if (rn)
    {
If.c (lib):994
  p.prefix = *ifaddr;

  rn = route_node_lookup (ifaddr_ipv4_table, (struct prefix *) &p);
  if (! rn)
    {
If.c (lib):1020
      p.prefix = *addr;

      rn = route_node_lookup (ifaddr_ipv4_table, (struct prefix *) &p);
      if (! rn)
	return NULL;
If.h (lib):294
  struct prefix *address;

  /* Peer or Broadcast address, depending on whether ZEBRA_IFA_PEER is set.
If.h (lib):298
  struct prefix *destination;

  /* Label for Linux 2.2.X and upper. */
If.h (lib):312
   local address is in the same prefix, then the local address may be unique. */
#define CONNECTED_ID(C)	\
	((CONNECTED_PEER(C) && !prefix_match((C)->destination, (C)->address)) ?\
If.h (lib):364
extern struct interface *if_lookup_prefix (struct prefix *prefix);

extern struct interface *if_create_vrf (const char *name, int namelen,
If.h (lib):373
extern struct interface *if_lookup_prefix_vrf (struct prefix *prefix,
                                vrf_id_t vrf_id);

If.h (lib):439
                                            struct prefix *,
                                            struct prefix *);
extern struct connected  *connected_delete_by_prefix (struct interface *, 
                                               struct prefix *);
extern struct connected  *connected_lookup_address (struct interface *, 
                                             struct in_addr);
If_ioctl.c (zebra):27
#include "prefix.h"
#include "ioctl.h"
#include "connected.h"
If_ioctl_solaris.c (zebra):27
#include "prefix.h"
#include "ioctl.h"
#include "connected.h"
If_sysctl.c (zebra):27
#include "prefix.h"
#include "connected.h"
#include "memory.h"
Interface.c (zebra):28
#include "prefix.h"
#include "command.h"
#include "memory.h"
Interface.c (zebra):180
  struct prefix cp;
  struct list *addr_list;

Interface.c (zebra):345
  struct prefix *p;
  int ret;

Interface.c (zebra):509
  struct prefix *p;
  struct route_node *rn;
  struct zebra_if *zebra_if;
Interface.c (zebra):635
  struct prefix *p;

  if_count_up(ifp->info);
Interface.c (zebra):670
  struct prefix *p;
  struct zebra_if *zif;

Interface.c (zebra):706
/* Output prefix string to vty. */
static int
prefix_vty_out (struct vty *vty, struct prefix *p)
{
  char str[INET6_ADDRSTRLEN];
Interface.c (zebra):712
  inet_ntop (p->family, &p->u.prefix, str, sizeof (str));
  vty_out (vty, "%s", str);
  return strlen (str);
Interface.c (zebra):721
  struct prefix *p;

  /* Print interface address. */
Interface.c (zebra):2283
  ifc = connected_check (ifp, (struct prefix *) &cp);
  if (! ifc)
    {
Interface.c (zebra):2292
      ifc->address = (struct prefix *) p;

      /* Broadcast. */
Interface.c (zebra):2299
	  p->prefix.s_addr = ipv4_broadcast_addr(p->prefix.s_addr,p->prefixlen);
	  ifc->destination = (struct prefix *) p;
	}

Interface.c (zebra):2353
  /* Convert to prefix structure. */
  ret = str2prefix_ipv4 (addr_str, &cp);
  if (ret <= 0)
Interface.c (zebra):2362
  ifc = connected_check (ifp, (struct prefix *) &cp);
  if (! ifc)
    {
Interface.c (zebra):2467
  ifc = connected_check (ifp, (struct prefix *) &cp);
  if (! ifc)
    {
Interface.c (zebra):2476
      ifc->address = (struct prefix *) p;

      /* Secondary. */
Interface.c (zebra):2532
  /* Convert to prefix structure. */
  ret = str2prefix_ipv6 (addr_str, &cp);
  if (ret <= 0)
Interface.c (zebra):2541
  ifc = connected_check (ifp, (struct prefix *) &cp);
  if (! ifc)
    {
Interface.c (zebra):2666
      struct prefix *p;

      if_data = ifp->info;
Interface.h (zebra):147
     advertisement is sent. The link-local prefix SHOULD NOT be
     included in the list of advertised prefixes. */
  struct list *AdvPrefixList;
Ioctl.c (zebra):27
#include "prefix.h"
#include "ioctl.h"
#include "log.h"
Ioctl.c (zebra):204
  addr.sin_addr = p->prefix;
  addr.sin_family = p->family;
#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN
Ioctl.c (zebra):242
  addr.sin_addr = p->prefix;
  addr.sin_family = p->family;
#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN
Ioctl.c (zebra):282
  addr.sin_addr = p->prefix;
  addr.sin_family = p->family;
  memcpy (&ifreq.ifr_addr, &addr, sizeof (struct sockaddr_in));
Ioctl.c (zebra):295
      addr.sin_addr = ifaddr.prefix;

      broad.sin_addr.s_addr = (addr.sin_addr.s_addr | ~mask.sin_addr.s_addr);
Ioctl.c (zebra):463
  memcpy (&ifreq.ifr6_addr, &p->prefix, sizeof (struct in6_addr));
  ifreq.ifr6_ifindex = ifp->ifindex;
  ifreq.ifr6_prefixlen = p->prefixlen;
Ioctl.c (zebra):483
  memcpy (&ifreq.ifr6_addr, &p->prefix, sizeof (struct in6_addr));
  ifreq.ifr6_ifindex = ifp->ifindex;
  ifreq.ifr6_prefixlen = p->prefixlen;
Ioctl.c (zebra):511
  addr.sin6_addr = p->prefix;
  addr.sin6_family = p->family;
#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN
Ioctl.c (zebra):555
  addr.sin6_addr = p->prefix;
  addr.sin6_family = p->family;
#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN
Ioctl_solaris.c (zebra):27
#include "prefix.h"
#include "ioctl.h"
#include "log.h"
Ioctl_solaris.c (zebra):223
  addr.sin_addr = p->prefix;
  addr.sin_family = p->family;
  memcpy (&ifreq.ifr_addr, &addr, sizeof (struct sockaddr_in));
Ioctl_solaris.c (zebra):238
      addr.sin_addr = ifaddr.prefix;

      broad.sin_addr.s_addr = (addr.sin_addr.s_addr | ~mask.sin_addr.s_addr);
Ipforward_solaris.c (zebra):25
#include "prefix.h"

#include "privs.h"
Irdp.h (zebra):154
			u_int32_t dst, struct prefix *p, u_int32_t ttl);


Irdp_interface.c (zebra):44
#include "prefix.h"
#include "command.h"
#include "memory.h"
Irdp_interface.c (zebra):82
static struct prefix *
irdp_get_prefix(struct interface *ifp)
{
Irdp_interface.c (zebra):103
  struct prefix *p;
  int ret;
  char b1[INET_ADDRSTRLEN];
Irdp_main.c (zebra):45
#include "prefix.h"
#include "command.h"
#include "memory.h"
Irdp_main.c (zebra):125
get_pref(struct irdp_interface *irdp, struct prefix *p)
{
  struct listnode *node;
Irdp_main.c (zebra):145
			   struct prefix *p,
			   struct stream *s)
{
Irdp_main.c (zebra):179
irdp_send(struct interface *ifp, struct prefix *p, struct stream *s)
{
  struct zebra_if *zi=ifp->info;
Irdp_main.c (zebra):204
static void irdp_advertisement (struct interface *ifp, struct prefix *p)
{
  struct stream *s;
Irdp_main.c (zebra):219
  struct prefix *p;
  struct listnode *node, *nnode;
  struct connected *ifc;
Irdp_main.c (zebra):259
  struct prefix *p;

  if(irdp->t_advertise)  thread_cancel(irdp->t_advertise);
Irdp_packet.c (zebra):45
#include "prefix.h"
#include "command.h"
#include "memory.h"
Irdp_packet.c (zebra):272
	    struct prefix *p,
	    u_int32_t ttl)
{
Isisd.c (isisd):35
#include "prefix.h"
#include "table.h"

Isis_circuit.c (isisd):41
#include "prefix.h"
#include "stream.h"

Isis_circuit.c (isisd):222
        if (prefix_same ((struct prefix *) ipv4, connected->address))
          return;

Isis_circuit.c (isisd):227
      ipv4->prefix = connected->address->u.prefix4;
      listnode_add (circuit->ip_addrs, ipv4);

Isis_circuit.c (isisd):231
      set_circuitparams_local_ipaddr (circuit->mtc, ipv4->prefix);

      if (circuit->area)
Isis_circuit.c (isisd):249
        if (prefix_same ((struct prefix *) ipv6, connected->address))
          return;
      for (ALL_LIST_ELEMENTS_RO (circuit->ipv6_non_link, node, ipv6))
        if (prefix_same ((struct prefix *) ipv6, connected->address))
          return;

Isis_circuit.c (isisd):257
      ipv6->prefix = connected->address->u.prefix6;

      if (IN6_IS_ADDR_LINKLOCAL (&ipv6->prefix))
	listnode_add (circuit->ipv6_link, ipv6);
      else
Isis_circuit.c (isisd):293
      ipv4->prefix = connected->address->u.prefix4;

      for (ALL_LIST_ELEMENTS_RO (circuit->ip_addrs, node, ip))
        if (prefix_same ((struct prefix *) ip, (struct prefix *) ipv4))
          break;

Isis_circuit.c (isisd):313
	      prefix2str((struct prefix*)ip, (char *)buf, BUFSIZ);
	      zlog_warn("  %s", buf);
	    }
Isis_circuit.c (isisd):326
      ipv6->prefix = connected->address->u.prefix6;

      if (IN6_IS_ADDR_LINKLOCAL (&ipv6->prefix))
	{
	  for (ALL_LIST_ELEMENTS_RO (circuit->ipv6_link, node, ip6))
Isis_circuit.c (isisd):332
	      if (prefix_same ((struct prefix *) ip6, (struct prefix *) ipv6))
		break;
	    }
Isis_circuit.c (isisd):345
	      if (prefix_same ((struct prefix *) ip6, (struct prefix *) ipv6))
		break;
	    }
Isis_circuit.c (isisd):363
	      prefix2str((struct prefix*)ip6, (char *)buf, BUFSIZ);
	      zlog_warn("  %s", buf);
	    }
Isis_circuit.c (isisd):369
	      prefix2str((struct prefix*)ip6, (char *)buf, BUFSIZ);
	      zlog_warn("  %s", buf);
	    }
Isis_circuit.c (isisd):878
      struct prefix *ip_addr;
      u_char buf[BUFSIZ];

Isis_csm.c (isisd):32
#include "prefix.h"
#include "stream.h"

Isis_events.c (isisd):31
#include "prefix.h"
#include "stream.h"
#include "table.h"
Isis_lsp.c (isisd):33
#include "prefix.h"
#include "command.h"
#include "hash.h"
Isis_lsp.c (isisd):936
      memcpy (ipv4_reach_prefix, inet_ntoa (ipv4_reach->prefix),
	      sizeof (ipv4_reach_prefix));
      memcpy (ipv4_reach_mask, inet_ntoa (ipv4_reach->mask),
Isis_lsp.c (isisd):950
      memcpy (ipv4_reach_prefix, inet_ntoa (ipv4_reach->prefix),
	      sizeof (ipv4_reach_prefix));
      memcpy (ipv4_reach_mask, inet_ntoa (ipv4_reach->mask),
Isis_lsp.c (isisd):965
      memcpy (in6.s6_addr, ipv6_reach->prefix,
	      PSIZE (ipv6_reach->prefix_len));
      inet_ntop (AF_INET6, &in6, (char *)buff, BUFSIZ);
Isis_lsp.c (isisd):1257
          ipreach->prefix.s_addr = ipv4->prefix.s_addr;
          masklen2ip(ipv4->prefixlen, &ipreach->mask);
          ipreach->prefix.s_addr &= ipreach->mask.s_addr;

          if ((info->metric & 0x3f) != info->metric)
Isis_lsp.c (isisd):1285
          memcpy(&te_ipreach->prefix_start, &ipv4->prefix.s_addr,
                 PSIZE(ipv4->prefixlen));
          listnode_add(tlv_data->te_ipv4_reachs, te_ipreach);
Isis_lsp.c (isisd):1326
      memcpy(ip6reach->prefix, ipv6->prefix.s6_addr, sizeof(ip6reach->prefix));
      listnode_add(tlv_data->ipv6_reachs, ip6reach);
    }
Isis_lsp.c (isisd):1552
		  ipreach->prefix.s_addr = ((ipreach->mask.s_addr) &
					    (ipv4->prefix.s_addr));
		  inet_ntop(AF_INET, &ipreach->prefix.s_addr, buf, sizeof(buf));
		  lsp_debug("ISIS (%s): Adding old-style IP reachability for %s/%d",
		            area->area_tag, buf, ipv4->prefixlen);
Isis_lsp.c (isisd):1580
		  memcpy (&te_ipreach->prefix_start, &ipv4->prefix.s_addr,
			  (ipv4->prefixlen + 7)/8);
		  inet_ntop(AF_INET, &ipv4->prefix.s_addr, buf, sizeof(buf));
		  lsp_debug("ISIS (%s): Adding te-style IP reachability for %s/%d",
		            area->area_tag, buf, ipv4->prefixlen);
Isis_lsp.c (isisd):1619
	      inet_ntop(AF_INET6, &ip6prefix.prefix.s6_addr, buf, sizeof(buf));
	      lsp_debug("ISIS (%s): Adding IPv6 reachability for %s/%d",
	                area->area_tag, buf, ipv6->prefixlen);
Isis_lsp.c (isisd):1623
	      memcpy (ip6reach->prefix, ip6prefix.prefix.s6_addr,
		      sizeof (ip6reach->prefix));
	      listnode_add (tlv_data.ipv6_reachs, ip6reach);
	    }
Isis_pdu.c (isisd):33
#include "prefix.h"
#include "if.h"
#include "checksum.h"
Isis_pdu.c (isisd):110
  addr1 = (u_char *) & ip1->prefix.s_addr;
  addr2 = (u_char *) & ip2->s_addr;
  len = ip1->prefixlen;
Isis_redist.c (isisd):28
#include "prefix.h"
#include "routemap.h"
#include "stream.h"
Isis_redist.c (isisd):59
is_default(struct prefix *p)
{
  if (p->family == AF_INET)
Isis_redist.c (isisd):123
                    struct prefix *p, struct isis_ext_info *info)
{
  int family = p->family;
Isis_redist.c (isisd):158
isis_redist_uninstall(struct isis_area *area, int level, struct prefix *p)
{
  int family = p->family;
Isis_redist.c (isisd):186
 * and prefix, using the given redistribution settings. */
static void
isis_redist_update_ext_reach(struct isis_area *area, int level,
                             struct isis_redist *redist, struct prefix *p,
                             struct isis_ext_info *info)
{
Isis_redist.c (isisd):220
  struct prefix p;
  struct route_table *ei_table = get_ext_info(isis, family);
  struct route_node *ei_node;
Isis_redist.c (isisd):257
isis_redist_add(int type, struct prefix *p, u_char distance, uint32_t metric)
{
  int family = p->family;
Isis_redist.c (isisd):307
isis_redist_delete(int type, struct prefix *p)
{
  int family = p->family;
Isis_redist.h (isisd):46
struct prefix;
struct vty;

Isis_redist.h (isisd):51
void isis_redist_add(int type, struct prefix *p,
                     u_char distance, uint32_t metric);
void isis_redist_delete(int type, struct prefix *p);
int isis_redist_config_write(struct vty *vty, struct isis_area *area,
                             int family);
Isis_route.c (isisd):32
#include "prefix.h"
#include "hash.h"
#include "if.h"
Isis_route.c (isisd):271
isis_route_info_new (struct prefix *prefix, uint32_t cost, uint32_t depth,
                     struct list *adjacencies)
{
Isis_route.c (isisd):280
  if (prefix->family == AF_INET)
    {
      rinfo->nexthops = list_new ();
Isis_route.c (isisd):289
          if (depth == 2 && prefix->prefixlen == 32)
            adj->router_address = prefix->u.prefix4;
          adjinfo2nexthop (rinfo->nexthops, adj);
        }
Isis_route.c (isisd):295
  if (prefix->family == AF_INET6)
    {
      rinfo->nexthops6 = list_new ();
Isis_route.c (isisd):304
          if (depth == 2 && prefix->prefixlen == 128)
            adj->router_address6 = prefix->u.prefix6;
          adjinfo2nexthop6 (rinfo->nexthops6, adj);
        }
Isis_route.c (isisd):400
isis_route_create (struct prefix *prefix, u_int32_t cost, u_int32_t depth,
		   struct list *adjacencies, struct isis_area *area,
		   int level)
Isis_route.c (isisd):409
  family = prefix->family;
  /* for debugs */
  prefix2str (prefix, (char *) buff, BUFSIZ);

  rinfo_new = isis_route_info_new (prefix, cost, depth, adjacencies);

  if (family == AF_INET)
    route_node = route_node_get (area->route_table[level - 1], prefix);
#ifdef HAVE_IPV6
  else if (family == AF_INET6)
    route_node = route_node_get (area->route_table6[level - 1], prefix);
#endif /* HAVE_IPV6 */
  else
Isis_route.c (isisd):466
isis_route_delete (struct prefix *prefix, struct route_table *table)
{
  struct route_node *rode;
Isis_route.c (isisd):473
  prefix2str (prefix, buff, BUFSIZ);


  rode = route_node_get (table, prefix);
  rinfo = rode->info;

Isis_route.c (isisd):491
      isis_zebra_route_update (prefix, rinfo);
    }
  isis_route_info_delete (rinfo);
Isis_route.c (isisd):572
 * merge table at first, then L2 paths are added if L1 path for same prefix
 * doesn't already exists there.
 *
Isis_route.h (isisd):48
#define ISIS_ROUTE_FLAG_ACTIVE       0x01  /* active route for the prefix */
#define ISIS_ROUTE_FLAG_ZEBRA_SYNCED 0x02  /* set when route synced to zebra */
#define ISIS_ROUTE_FLAG_ZEBRA_RESYNC 0x04  /* set when route needs to sync */
Isis_route.h (isisd):60
struct isis_route_info *isis_route_create (struct prefix *prefix,
					   u_int32_t cost, u_int32_t depth,
					   struct list *adjacencies,
Isis_routemap.c (isisd):30
#include "prefix.h"
#include "plist.h"
#include "routemap.h"
Isis_routemap.c (isisd):54
route_match_ip_address(void *rule, struct prefix *prefix,
                       route_map_object_t type, void *object)
{
Isis_routemap.c (isisd):63
  if (access_list_apply(alist, prefix) != FILTER_DENY)
    return RMAP_MATCH;

Isis_routemap.c (isisd):92
route_match_ip_address_prefix_list(void *rule, struct prefix *prefix,
                                   route_map_object_t type, void *object)
{
Isis_routemap.c (isisd):101
  if (prefix_list_apply(plist, prefix) != PREFIX_DENY)
    return RMAP_MATCH;

Isis_routemap.c (isisd):121
  "ip address prefix-list",
  route_match_ip_address_prefix_list,
  route_match_ip_address_prefix_list_compile,
Isis_routemap.c (isisd):130
route_match_ipv6_address(void *rule, struct prefix *prefix,
                         route_map_object_t type, void *object)
{
Isis_routemap.c (isisd):139
  if (access_list_apply(alist, prefix) != FILTER_DENY)
    return RMAP_MATCH;

Isis_routemap.c (isisd):168
route_match_ipv6_address_prefix_list(void *rule, struct prefix *prefix,
                                     route_map_object_t type, void *object)
{
Isis_routemap.c (isisd):177
  if (prefix_list_apply(plist, prefix) != PREFIX_DENY)
    return RMAP_MATCH;

Isis_routemap.c (isisd):197
  "ipv6 address prefix-list",
  route_match_ipv6_address_prefix_list,
  route_match_ipv6_address_prefix_list_compile,
Isis_routemap.c (isisd):206
route_set_metric(void *rule, struct prefix *prefix,
                 route_map_object_t type, void *object)
{
Isis_routemap.c (isisd):389
      "match ip address prefix-list WORD",
      MATCH_STR
      IP_STR
Isis_routemap.c (isisd):393
      "Match entries of prefix-lists\n"
      "IP prefix-list name\n")
{
  return isis_route_match_add(vty, vty->index, "ip address prefix-list", argv[0]);
}

Isis_routemap.c (isisd):401
      "no match ip address prefix-list",
      NO_STR
      MATCH_STR
Isis_routemap.c (isisd):406
      "Match entries of prefix-lists\n")
{
  if (argc == 0)
    return isis_route_match_delete (vty, vty->index, "ip address prefix-list", NULL);
  return isis_route_match_delete (vty, vty->index, "ip address prefix-list", argv[0]);
}

Isis_routemap.c (isisd):415
      "no match ip address prefix-list WORD",
      NO_STR
      MATCH_STR
Isis_routemap.c (isisd):420
      "Match entries of prefix-lists\n"
      "IP prefix-list name\n"
);

Isis_routemap.c (isisd):464
      "match ipv6 address prefix-list WORD",
      MATCH_STR
      IPV6_STR
Isis_routemap.c (isisd):468
      "Match entries of prefix-lists\n"
      "IP prefix-list name\n")
{
  return isis_route_match_add(vty, vty->index, "ipv6 address prefix-list", argv[0]);
}

Isis_routemap.c (isisd):476
      "no match ipv6 address prefix-list",
      NO_STR
      MATCH_STR
Isis_routemap.c (isisd):481
      "Match entries of prefix-lists\n")
{
  if (argc == 0)
    return isis_route_match_delete (vty, vty->index, "ipv6 address prefix-list", NULL);
  return isis_route_match_delete (vty, vty->index, "ipv6 address prefix-list", argv[0]);
}

Isis_routemap.c (isisd):490
      "no match ipv6 address prefix-list WORD",
      NO_STR
      MATCH_STR
Isis_routemap.c (isisd):495
      "Match entries of prefix-lists\n"
      "IP prefix-list name\n"
);

Isis_spf.c (isisd):32
#include "prefix.h"
#include "hash.h"
#include "if.h"
Isis_spf.c (isisd):177
      prefix2str ((struct prefix *) &vertex->N.prefix, (char *) buff, BUFSIZ);
      break;
    default:
Isis_spf.c (isisd):212
      memcpy (&vertex->N.prefix, (struct prefix *) id,
	      sizeof (struct prefix));
      break;
    default:
Isis_spf.c (isisd):456
  struct prefix *p1, *p2;

  for (ALL_LIST_ELEMENTS_RO (list, node, vertex))
Isis_spf.c (isisd):482
	  p1 = (struct prefix *) id;
	  p2 = (struct prefix *) &vertex->N.id;
	  if (p1->family == p2->family && p1->prefixlen == p2->prefixlen &&
	      memcmp (&p1->u.prefix, &p2->u.prefix,
		      PSIZE (p1->prefixlen)) == 0)
	    return vertex;
Isis_spf.c (isisd):720
  struct prefix prefix;
#ifdef HAVE_IPV6
  struct ipv6_reachability *ip6reach;
Isis_spf.c (isisd):779
    prefix.family = AF_INET;
    for (ALL_LIST_ELEMENTS_RO (lsp->tlv_data.ipv4_int_reachs, node, ipreach))
    {
Isis_spf.c (isisd):784
      prefix.u.prefix4 = ipreach->prefix;
      prefix.prefixlen = ip_masklen (ipreach->mask);
      apply_mask (&prefix);
      process_N (spftree, vtype, (void *) &prefix, dist, depth + 1,
                 family, parent);
    }
Isis_spf.c (isisd):793
    prefix.family = AF_INET;
    for (ALL_LIST_ELEMENTS_RO (lsp->tlv_data.ipv4_ext_reachs, node, ipreach))
    {
Isis_spf.c (isisd):798
      prefix.u.prefix4 = ipreach->prefix;
      prefix.prefixlen = ip_masklen (ipreach->mask);
      apply_mask (&prefix);
      process_N (spftree, vtype, (void *) &prefix, dist, depth + 1,
                 family, parent);
    }
Isis_spf.c (isisd):807
    prefix.family = AF_INET;
    for (ALL_LIST_ELEMENTS_RO (lsp->tlv_data.te_ipv4_reachs,
                               node, te_ipv4_reach))
Isis_spf.c (isisd):815
      prefix.u.prefix4 = newprefix2inaddr (&te_ipv4_reach->prefix_start,
                                           te_ipv4_reach->control);
      prefix.prefixlen = (te_ipv4_reach->control & 0x3F);
      apply_mask (&prefix);
      process_N (spftree, vtype, (void *) &prefix, dist, depth + 1,
                 family, parent);
    }
Isis_spf.c (isisd):826
    prefix.family = AF_INET6;
    for (ALL_LIST_ELEMENTS_RO (lsp->tlv_data.ipv6_reachs, node, ip6reach))
    {
Isis_spf.c (isisd):834
      prefix.prefixlen = ip6reach->prefix_len;
      memcpy (&prefix.u.prefix6.s6_addr, ip6reach->prefix,
              PSIZE (ip6reach->prefix_len));
      apply_mask (&prefix);
      process_N (spftree, vtype, (void *) &prefix, dist, depth + 1,
                 family, parent);
    }
Isis_spf.c (isisd):938
  struct prefix prefix;
  int retval = ISIS_OK;
  u_char lsp_id[ISIS_SYS_ID_LEN + 2];
Isis_spf.c (isisd):963
	  prefix.family = AF_INET;
          for (ALL_LIST_ELEMENTS_RO (circuit->ip_addrs, ipnode, ipv4))
	    {
	      prefix.u.prefix4 = ipv4->prefix;
	      prefix.prefixlen = ipv4->prefixlen;
              apply_mask (&prefix);
	      isis_spf_add_local (spftree, VTYPE_IPREACH_INTERNAL, &prefix,
				  NULL, 0, family, parent);
	    }
Isis_spf.c (isisd):976
	  prefix.family = AF_INET6;
	  for (ALL_LIST_ELEMENTS_RO (circuit->ipv6_non_link, ipnode, ipv6))
	    {
	      prefix.prefixlen = ipv6->prefixlen;
	      prefix.u.prefix6 = ipv6->prefix;
              apply_mask (&prefix);
	      isis_spf_add_local (spftree, VTYPE_IP6REACH_INTERNAL,
				  &prefix, NULL, 0, family, parent);
	    }
	}
Isis_spf.c (isisd):1146
	isis_route_create ((struct prefix *) &vertex->N.prefix, vertex->d_N,
			   vertex->depth, vertex->Adj_N, spftree->area, level);
      else if (isis->debugs & DEBUG_SPF_EVENTS)
Isis_spf.h (isisd):54
    struct prefix prefix;
  } N;

Isis_te.c (isisd):36
#include "prefix.h"
#include "command.h"
#include "hash.h"
Isis_te.c (isisd):561
              set_circuitparams_local_ipaddr (mtc, addr->prefix);
            }
        }
Isis_tlv.c (isisd):30
#include "prefix.h"
#include "vty.h"
#include "if.h"
Isis_tlv.c (isisd):609
				 "ability prefix length %d", areatag,
				 te_ipv4_reach->control & 0x3F);
		      retval = ISIS_WARNING;
Isis_tlv.c (isisd):681
				 "ability prefix length %d", areatag,
				 ipv6_reach->prefix_len);
		      retval = ISIS_WARNING;
Isis_tlv.c (isisd):957
      *(u_int32_t *) pos = ipv4->prefix.s_addr;
      pos += IPV4_MAX_BYTELEN;
    }
Isis_tlv.c (isisd):1043
      *(u_int32_t *) pos = reach->prefix.s_addr;
      pos += IPV4_MAX_BYTELEN;
      *(u_int32_t *) pos = reach->mask.s_addr;
Isis_tlv.c (isisd):1117
      memcpy (pos, ipv6->prefix.s6_addr, IPV6_MAX_BYTELEN);
      pos += IPV6_MAX_BYTELEN;
    }
Isis_tlv.c (isisd):1149
      memcpy (pos, ip6reach->prefix, prefix_octets);
      pos += prefix_octets;
    }
Isis_tlv.h (isisd):90
 * Management prefix color          117   RFC5120
 */

Isis_tlv.h (isisd):208
  struct in_addr prefix;
  struct in_addr mask;
};
Isis_tlv.h (isisd):240
  u_char prefix[16];
};

Isis_zebra.c (isisd):32
#include "prefix.h"
#include "zclient.h"
#include "stream.h"
Isis_zebra.c (isisd):62
  struct prefix router_id;

  /*
Isis_zebra.c (isisd):174
  struct prefix *p;
  char buf[BUFSIZ];

Isis_zebra.c (isisd):207
  struct prefix *p;
  u_char buf[BUFSIZ];
#endif /* EXTREME_DEBUG */
Isis_zebra.c (isisd):256
isis_zebra_route_add_ipv4 (struct prefix *prefix,
			   struct isis_route_info *route_info)
{
Isis_zebra.c (isisd):290
      /* prefix information */
      psize = PSIZE (prefix->prefixlen);
      stream_putc (stream, prefix->prefixlen);
      stream_write (stream, (u_char *) & prefix->u.prefix4, psize);

      stream_putc (stream, listcount (route_info->nexthops));
Isis_zebra.c (isisd):327
isis_zebra_route_del_ipv4 (struct prefix *prefix,
			   struct isis_route_info *route_info)
{
Isis_zebra.c (isisd):341
      prefix4.prefixlen = prefix->prefixlen;
      prefix4.prefix = prefix->u.prefix4;
      zapi_ipv4_route (ZEBRA_IPV4_ROUTE_DELETE, zclient, &prefix4, &api);
    }
Isis_zebra.c (isisd):352
isis_zebra_route_add_ipv6 (struct prefix *prefix,
			   struct isis_route_info *route_info)
{
Isis_zebra.c (isisd):424
      prefix6.prefixlen = prefix->prefixlen;
      memcpy (&prefix6.prefix, &prefix->u.prefix6, sizeof (struct in6_addr));
      zapi_ipv6_route (ZEBRA_IPV6_ROUTE_ADD, zclient, &prefix6, &api);
      SET_FLAG (route_info->flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED);
Isis_zebra.c (isisd):438
isis_zebra_route_del_ipv6 (struct prefix *prefix,
			   struct isis_route_info *route_info)
{
Isis_zebra.c (isisd):504
      prefix6.prefixlen = prefix->prefixlen;
      memcpy (&prefix6.prefix, &prefix->u.prefix6, sizeof (struct in6_addr));
      zapi_ipv6_route (ZEBRA_IPV6_ROUTE_DELETE, zclient, &prefix6, &api);
      UNSET_FLAG (route_info->flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED);
Isis_zebra.c (isisd):517
isis_zebra_route_update (struct prefix *prefix,
			 struct isis_route_info *route_info)
{
Isis_zebra.c (isisd):528
      if (prefix->family == AF_INET)
	isis_zebra_route_add_ipv4 (prefix, route_info);
#ifdef HAVE_IPV6
      else if (prefix->family == AF_INET6)
	isis_zebra_route_add_ipv6 (prefix, route_info);
#endif /* HAVE_IPV6 */
    }
Isis_zebra.c (isisd):537
      if (prefix->family == AF_INET)
	isis_zebra_route_del_ipv4 (prefix, route_info);
#ifdef HAVE_IPV6
      else if (prefix->family == AF_INET6)
	isis_zebra_route_del_ipv6 (prefix, route_info);
#endif /* HAVE_IPV6 */
    }
Isis_zebra.c (isisd):554
  struct prefix *p_generic = (struct prefix*)&p;
  unsigned long ifindex __attribute__ ((unused));
  struct in_addr nexthop __attribute__ ((unused));
Isis_zebra.c (isisd):572
  stream_get (&p.prefix, stream, PSIZE (p.prefixlen));

  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))
Isis_zebra.c (isisd):613
  struct prefix *p_generic = (struct prefix*)&p;
  struct in6_addr nexthop;
  unsigned long ifindex __attribute__((unused));
Isis_zebra.c (isisd):629
  stream_get(&p.prefix, stream, PSIZE(p.prefixlen));

  if (CHECK_FLAG(api.message, ZAPI_MESSAGE_NEXTHOP))
Isis_zebra.h (isisd):28
void isis_zebra_route_update (struct prefix *prefix,
			      struct isis_route_info *route_info);
int isis_distribute_list_update (int routetype);
Kernel_null.c (zebra):33
int kernel_route_rib (struct prefix *a, struct rib *old, struct rib *new) { return 0; }

int kernel_add_route (struct prefix_ipv4 *a, struct in_addr *b, int c, int d)
Kernel_socket.c (zebra):26
#include "prefix.h"
#include "sockunion.h"
#include "connected.h"
Kernel_socket.c (zebra):924
      p.prefix = dest.sin.sin_addr;
      if (flags & RTF_HOST)
	p.prefixlen = IPV4_MAX_PREFIXLEN;
Kernel_socket.c (zebra):1000
      /* Change, delete the old prefix, we have no further information
       * to specify the route really
       */
Kernel_socket.c (zebra):1028
      p.prefix = dest.sin6.sin6_addr;
      if (flags & RTF_HOST)
	p.prefixlen = IPV6_MAX_PREFIXLEN;
Kernel_socket.c (zebra):1042
      /* CHANGE: delete the old prefix, we have no further information
       * to specify the route really
       */
Main.c (zebra):30
#include "prefix.h"
#include "log.h"
#include "plist.h"
Memory.c (lib):83
 * Add an extra 'z' prefix to function name to avoid collision when linking
 * statically with zlib that exports the 'zcalloc' symbol.
 */
Memory.c (lib):290
log_memstats_stderr (const char *prefix)
{
  struct mlist *ml;
Memory.c (lib):307
                       prefix,
                       ml->name);
            fprintf (stderr,
Memory.c (lib):311
                     prefix,
                     m->format,
                     mstat[m->index].alloc,
Memory.c (lib):323
             prefix);
  else
    fprintf (stderr,
Memory.c (lib):327
             prefix);
}

Memtypes.c (lib):235
  { MTYPE_OSPF6_PREFIX,       "OSPF6 prefix"			},
  { MTYPE_OSPF6_MESSAGE,      "OSPF6 message"			},
  { MTYPE_OSPF6_LSA,          "OSPF6 LSA"			},
Misc_null.c (zebra):24
#include "prefix.h"
#include "zebra/rtadv.h"
#include "zebra/irdp.h"
Nexthop.c (lib):23
#include "prefix.h"
#include "table.h"
#include "memory.h"
Nexthop.c (lib):33
#include "prefix.h"
#include "nexthop.h"

Nexthop.h (lib):27
#include "prefix.h"

union g_addr {
Nhrpd.h (nhrpd):167
	struct prefix route_prefix;
	union sockunion src_nbma, src_proto, dst_proto;
};
Nhrpd.h (nhrpd):225
	struct prefix *p;
	union sockunion addr;

Nhrpd.h (nhrpd):312
void nhrp_route_update_nhrp(const struct prefix *p, struct interface *ifp);
void nhrp_route_announce(int add, enum nhrp_cache_type type, const struct prefix *p, struct interface *ifp, const union sockunion *nexthop, uint32_t mtu);
int nhrp_route_read(int command, struct zclient *zclient, zebra_size_t length, vrf_id_t vrf_id);
int nhrp_route_get_nexthop(const union sockunion *addr, struct prefix *p, union sockunion *via, struct interface **ifp);
enum nhrp_route_type nhrp_route_address(struct interface *in_ifp, union sockunion *addr, struct prefix *p, struct nhrp_peer **peer);

void nhrp_config_init(void);
Nhrpd.h (nhrpd):325
void nhrp_shortcut_prefix_change(const struct prefix *p, int deleted);

struct nhrp_cache *nhrp_cache_get(struct interface *ifp, union sockunion *remote_addr, int create);
Nhrp_cache.c (nhrpd):112
	struct prefix pfx;
	struct nhrp_peer *p = c->cur.peer;

Nhrp_interface.c (nhrpd):199
	/* On NHRP interfaces a host prefix is required */
	if (best && if_ad->configured && best->address->prefixlen != 8 * prefix_blen(best->address)) {
		zlog_notice("%s: %s is not a host prefix", ifp->name,
			prefix2str(best->address, buf, sizeof buf));
		best = NULL;
Nhrp_peer.c (nhrpd):415
		/* We currently support only unique prefix registrations */
		if (cie->prefix_length != 0xff) {
			cie->code = NHRP_CODE_ADMINISTRATIVELY_PROHIBITED;
Nhrp_route.c (nhrpd):32
static struct route_node *nhrp_route_update_get(const struct prefix *p, int create)
{
	struct route_node *rn;
Nhrp_route.c (nhrpd):64
static void nhrp_route_update_zebra(const struct prefix *p, union sockunion *nexthop, struct interface *ifp)
{
	struct route_node *rn;
Nhrp_route.c (nhrpd):78
void nhrp_route_update_nhrp(const struct prefix *p, struct interface *ifp)
{
	struct route_node *rn;
Nhrp_route.c (nhrpd):91
void nhrp_route_announce(int add, enum nhrp_cache_type type, const struct prefix *p, struct interface *ifp, const union sockunion *nexthop, uint32_t mtu)
{
	struct in_addr *nexthop_ipv4;
Nhrp_route.c (nhrpd):161
	struct prefix prefix;
	union sockunion nexthop_addr;
	unsigned char message, nexthop_num, ifindex_num;
Nhrp_route.c (nhrpd):169
	memset(&prefix, 0, sizeof(prefix));
	sockunion_family(&nexthop_addr) = AF_UNSPEC;

Nhrp_route.c (nhrpd):181
		prefix.family = AF_INET;
		break;
	case ZEBRA_IPV6_ROUTE_ADD:
Nhrp_route.c (nhrpd):185
		prefix.family = AF_INET6;
		break;
	default:
Nhrp_route.c (nhrpd):190
	afaddrlen = family2addrsize(prefix.family);
	prefix.prefixlen = stream_getc(s);
	stream_get(&prefix.u.val, s, PSIZE(prefix.prefixlen));

	/* Nexthop, ifindex, distance, metric. */
Nhrp_route.c (nhrpd):199
			if (i == 0) sockunion_set(&nexthop_addr, prefix.family, (u_char*) buf[0], afaddrlen);
		}
		ifindex_num = stream_getc(s);
Nhrp_route.c (nhrpd):216
		prefix2str(&prefix, buf[0], sizeof buf[0]),
		sockunion2str(&nexthop_addr, buf[1], sizeof buf[1]),
		ifp ? ifp->name : "(none)");
Nhrp_route.c (nhrpd):220
	nhrp_route_update_zebra(&prefix, &nexthop_addr, ifp);
	nhrp_shortcut_prefix_change(&prefix, !added);

	return 0;
Nhrp_route.c (nhrpd):226
int nhrp_route_get_nexthop(const union sockunion *addr, struct prefix *p, union sockunion *via, struct interface **ifp)
{
	struct route_node *rn;
Nhrp_route.c (nhrpd):230
	struct prefix lookup;
	afi_t afi = family2afi(sockunion_family(addr));
	char buf[PREFIX_STRLEN];
Nhrp_route.c (nhrpd):260
enum nhrp_route_type nhrp_route_address(struct interface *in_ifp, union sockunion *addr, struct prefix *p, struct nhrp_peer **peer)
{
	struct interface *ifp = in_ifp;
Nhrp_route.c (nhrpd):292
		/* Resolve via node, but return the prefix of first match */
		addr = &via[i];
		p = NULL;
Nhrp_shortcut.c (nhrpd):84
				/* Force renewal of Zebra announce on prefix change */
				s->route_installed = 0;
				nhrp_shortcut_cache_notify(&s->cache_notifier, NOTIFY_CACHE_UP);
Nhrp_shortcut.c (nhrpd):140
static struct nhrp_shortcut *nhrp_shortcut_get(struct prefix *p)
{
	struct nhrp_shortcut *s;
Nhrp_shortcut.c (nhrpd):174
	struct prefix prefix, route_prefix;
	struct zbuf extpl;
	char bufp[PREFIX_STRLEN], buf[3][SU_ADDRSTRLEN];
Nhrp_shortcut.c (nhrpd):223
	prefix = *s->p;
	prefix.prefixlen = cie->prefix_length;

	/* Sanity check prefix length */
	if (prefix.prefixlen >= 8*prefix_blen(&prefix)) {
		prefix.prefixlen = 8*prefix_blen(&prefix);
	} else if (nhrp_route_address(NULL, &pp->dst_proto, &route_prefix, NULL) == NHRP_ROUTE_NBMA_NEXTHOP) {
		if (prefix.prefixlen < route_prefix.prefixlen)
			prefix.prefixlen = route_prefix.prefixlen;
	}

Nhrp_shortcut.c (nhrpd):235
		prefix2str(&prefix, bufp, sizeof bufp),
		sockunion2str(proto, buf[0], sizeof buf[0]),
		sockunion2str(&cie_nbma, buf[1], sizeof buf[1]),
Nhrp_shortcut.c (nhrpd):261
		ps = nhrp_shortcut_get(&prefix);
		if (ps) {
			ps->addr = s->addr;
Nhrp_shortcut.c (nhrpd):298
	 *  - Prefix length: widest acceptable prefix we accept (if U set, 0xff)
	 *  - MTU: MTU of the source station
	 *  - Holding Time: Max time to cache the source information
Nhrp_shortcut.c (nhrpd):319
	struct prefix p;
	struct nhrp_shortcut *s;

Nhrp_shortcut.c (nhrpd):360
	const struct prefix *p;
	int deleted;
};
Nhrp_shortcut.c (nhrpd):394
void nhrp_shortcut_prefix_change(const struct prefix *p, int deleted)
{
	struct purge_ctx pctx = {
Ospf6d.c (ospf6d):156
  else if (! strcmp (argv[0], "intra-prefix"))
    type = htons (OSPF6_LSTYPE_INTRA_PREFIX);
  else if (! strcmp (argv[0], "inter-router"))
Ospf6d.c (ospf6d):160
  else if (! strcmp (argv[0], "inter-prefix"))
    type = htons (OSPF6_LSTYPE_INTER_PREFIX);
  else if (! strcmp (argv[0], "link"))
Ospf6d.c (ospf6d):224
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix)",
       SHOW_STR
       IPV6_STR
Ospf6d.c (ospf6d):294
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) "
       "(detail|dump|internal)",
       SHOW_STR
Ospf6d.c (ospf6d):510
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) A.B.C.D",
       SHOW_STR
       IPV6_STR
Ospf6d.c (ospf6d):592
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) A.B.C.D "
       "(detail|dump|internal)",
       SHOW_STR
Ospf6d.c (ospf6d):617
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) linkstate-id A.B.C.D",
       SHOW_STR
       IPV6_STR
Ospf6d.c (ospf6d):639
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) linkstate-id A.B.C.D "
       "(detail|dump|internal)",
       SHOW_STR
Ospf6d.c (ospf6d):665
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) * A.B.C.D",
       SHOW_STR
       IPV6_STR
Ospf6d.c (ospf6d):748
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) * A.B.C.D "
       "(detail|dump|internal)",
       SHOW_STR
Ospf6d.c (ospf6d):774
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) adv-router A.B.C.D",
       SHOW_STR
       IPV6_STR
Ospf6d.c (ospf6d):796
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) adv-router A.B.C.D "
       "(detail|dump|internal)",
       SHOW_STR
Ospf6d.c (ospf6d):988
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) A.B.C.D A.B.C.D",
       SHOW_STR
       IPV6_STR
Ospf6d.c (ospf6d):1082
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) A.B.C.D A.B.C.D "
       "(dump|internal)",
       SHOW_STR
Ospf6d.c (ospf6d):1107
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) "
       "adv-router A.B.C.D linkstate-id A.B.C.D",
       SHOW_STR
Ospf6d.c (ospf6d):1204
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) "
       "adv-router A.B.C.D linkstate-id A.B.C.D "
       "(dump|internal)",
Ospf6d.c (ospf6d):1290
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) self-originated",
       SHOW_STR
       IPV6_STR
Ospf6d.c (ospf6d):1364
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) self-originated "
       "(detail|dump|internal)",
       SHOW_STR
Ospf6d.c (ospf6d):1389
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) self-originated "
       "linkstate-id A.B.C.D",
       SHOW_STR
Ospf6d.c (ospf6d):1477
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) self-originated "
       "linkstate-id A.B.C.D (detail|dump|internal)",
       SHOW_STR
Ospf6d.c (ospf6d):1504
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) A.B.C.D self-originated",
       SHOW_STR
       IPV6_STR
Ospf6d.c (ospf6d):1590
       "(router|network|inter-prefix|inter-router|as-external|"
       "group-membership|type-7|link|intra-prefix) A.B.C.D self-originated "
       "(detail|dump|internal)",
       SHOW_STR
Ospf6d.c (ospf6d):1627
  struct prefix prefix;

  OSPF6_CMD_CHECK_RUNNING ();
Ospf6d.c (ospf6d):1648
      ospf6_linkstate_prefix (adv_router, 0, &prefix);
      ro = ospf6_route_lookup (&prefix, ospf6->brouter_table);
      if (!ro)
        {
Ospf6_abr.c (ospf6d):26
#include "prefix.h"
#include "table.h"
#include "vty.h"
Ospf6_abr.c (ospf6d):165
          inet_ntop (AF_INET, &(ADV_ROUTER_IN_PREFIX (&route->prefix)),
                     buf, sizeof (buf));
          zlog_debug ("Originating summary in area %s for ASBR %s",
Ospf6_abr.c (ospf6d):177
          prefix2str (&route->prefix, buf, sizeof (buf));
          zlog_debug ("Originating summary in area %s for %s",
		      area->name, buf);
Ospf6_abr.c (ospf6d):184
  summary = ospf6_route_lookup (&route->prefix, summary_table);
  if (summary)
    old = ospf6_lsdb_lookup (summary->path.origin.type,
Ospf6_abr.c (ospf6d):293
      range = ospf6_route_lookup_bestmatch (&route->prefix,
                                            route_area->range_table);

Ospf6_abr.c (ospf6d):304
              prefix2str (&range->prefix, buf, sizeof (buf));
              zlog_debug ("Suppressed by range %s of area %s",
                         buf, route_area->name);
Ospf6_abr.c (ospf6d):332
      /* Whether the route have active longer prefix */
      if (! CHECK_FLAG (route->flag, OSPF6_ROUTE_ACTIVE_SUMMARY))
        {
Ospf6_abr.c (ospf6d):354
                               &route->prefix) == FILTER_DENY)
          {
            if (is_debug)
Ospf6_abr.c (ospf6d):358
                inet_ntop (AF_INET, &(ADV_ROUTER_IN_PREFIX (&route->prefix)),
                           buf, sizeof(buf));
                zlog_debug ("prefix %s was denied by export list", buf);
              }
            return;
Ospf6_abr.c (ospf6d):375
                                &route->prefix) != PREFIX_PERMIT) 
           {
             if (is_debug)
Ospf6_abr.c (ospf6d):379
                 inet_ntop (AF_INET, &(ADV_ROUTER_IN_PREFIX (&route->prefix)),
                            buf, sizeof (buf));
                 zlog_debug ("prefix %s was denied by filter-list out", buf);
               }
             return;
Ospf6_abr.c (ospf6d):433
      router_lsa->router_id = ADV_ROUTER_IN_PREFIX (&route->prefix);
      type = htons (OSPF6_LSTYPE_INTER_ROUTER);
    }
Ospf6_abr.c (ospf6d):444
      prefix_lsa->prefix.prefix_length = route->prefix.prefixlen;
      prefix_lsa->prefix.prefix_options = route->path.prefix_options;

      /* set Prefix */
      memcpy (p, &route->prefix.u.prefix6,
              OSPF6_PREFIX_SPACE (route->prefix.prefixlen));
      ospf6_prefix_apply_mask (&prefix_lsa->prefix);
      p += OSPF6_PREFIX_SPACE (route->prefix.prefixlen);
      type = htons (OSPF6_LSTYPE_INTER_PREFIX);
    }
Ospf6_abr.c (ospf6d):484
  for (ro = ospf6_route_match_head (&range->prefix, ospf6->route_table);
       ro; ro = ospf6_route_match_next (&range->prefix, ro))
    {
      if (ro->path.area_id == range->path.area_id &&
Ospf6_abr.c (ospf6d):515
      range = ospf6_route_lookup_bestmatch (&route->prefix, oa->range_table);
      if (range)
        ospf6_abr_range_update (range);
Ospf6_abr.c (ospf6d):528
  struct prefix prefix, abr_prefix;
  struct ospf6_route_table *table = NULL;
  struct ospf6_route *range, *route, *old = NULL;
Ospf6_abr.c (ospf6d):543
  memset (&prefix, 0, sizeof (prefix));

  if (lsa->header->type == htons (OSPF6_LSTYPE_INTER_PREFIX))
Ospf6_abr.c (ospf6d):555
      prefix.family = AF_INET6;
      prefix.prefixlen = prefix_lsa->prefix.prefix_length;
      ospf6_prefix_in6_addr (&prefix.u.prefix6, &prefix_lsa->prefix);
      if (is_debug)
        prefix2str (&prefix, buf, sizeof (buf));
      table = oa->ospf6->route_table;
      type = OSPF6_DEST_TYPE_NETWORK;
      prefix_options = prefix_lsa->prefix.prefix_options;
      cost = OSPF6_ABR_SUMMARY_METRIC (prefix_lsa);
    }
Ospf6_abr.c (ospf6d):575
      ospf6_linkstate_prefix (router_lsa->router_id, htonl (0), &prefix);
      if (is_debug)
        inet_ntop (AF_INET, &router_lsa->router_id, buf, sizeof (buf));
Ospf6_abr.c (ospf6d):590
  route = ospf6_route_lookup (&prefix, table);
  if (route)
    ospf6_route_lock (route);
  while (route && ospf6_route_is_prefix (&prefix, route))
    {
      if (route->path.area_id == oa->area_id &&
Ospf6_abr.c (ospf6d):632
  /* (3) if the prefix is equal to an active configured address range */
  /*     or if the NU bit is set in the prefix */
  if (lsa->header->type == htons (OSPF6_LSTYPE_INTER_PREFIX))
    {
      range = ospf6_route_lookup (&prefix, oa->range_table);
      if (range)
        {
Ospf6_abr.c (ospf6d):646
      if (CHECK_FLAG (prefix_lsa->prefix.prefix_options,
		      OSPF6_PREFIX_OPTION_NU) ||
	  CHECK_FLAG (prefix_lsa->prefix.prefix_options,
		      OSPF6_PREFIX_OPTION_LA))
	{
Ospf6_abr.c (ospf6d):694
        if (access_list_apply (IMPORT_LIST (oa), &prefix) == FILTER_DENY)
          {
            if (is_debug)
Ospf6_abr.c (ospf6d):704
  /* Check input prefix-list */
  if (PREFIX_NAME_IN (oa))
    {
Ospf6_abr.c (ospf6d):711
        if (prefix_list_apply (PREFIX_LIST_IN (oa), &prefix) != PREFIX_PERMIT)
          {
            if (is_debug)
              zlog_debug ("Prefix was denied by prefix-list");
            if (old)
              ospf6_route_remove (old, table);
Ospf6_abr.c (ospf6d):730
  route->prefix = prefix;
  route->path.origin.type = lsa->header->type;
  route->path.origin.id = lsa->header->id;
Ospf6_abr.c (ospf6d):804
      ospf6_prefix_in6_addr (&in6, &prefix_lsa->prefix);
      if (buf)
	{
Ospf6_abr.c (ospf6d):808
	  sprintf (&buf[strlen(buf)], "/%d", prefix_lsa->prefix.prefix_length);
	}
    }
Ospf6_abr.c (ospf6d):827
  ospf6_prefix_options_printbuf (prefix_lsa->prefix.prefix_options,
                                 buf, sizeof (buf));
  vty_out (vty, "     Prefix Options: %s%s", buf, VNL);
Ospf6_abr.h (ospf6d):40
#define OSPF6_INTER_PREFIX_LSA_MIN_SIZE        4U /* w/o IPv6 prefix */
struct ospf6_inter_prefix_lsa
{
Ospf6_abr.h (ospf6d):44
  struct ospf6_prefix prefix;
};

Ospf6_area.c (ospf6d):31
#include "prefix.h"
#include "table.h"
#include "plist.h"
Ospf6_area.c (ospf6d):343
       "Specify IPv6 prefix\n"
       )
{
Ospf6_area.c (ospf6d):348
  struct prefix prefix;
  struct ospf6_route *range;

Ospf6_area.c (ospf6d):355
  ret = str2prefix (argv[0], &prefix);
  if (ret != 1 || prefix.family != AF_INET6)
    {
      vty_out (vty, "Malformed argument: %s%s", argv[0], VNL);
Ospf6_area.c (ospf6d):364
  range = ospf6_route_lookup (&prefix, oa->range_table);
  if (range == NULL)
    {
Ospf6_area.c (ospf6d):369
      range->prefix = prefix;
    }

Ospf6_area.c (ospf6d):396
       "Specify IPv6 prefix\n"
       )

Ospf6_area.c (ospf6d):405
       "Specify IPv6 prefix\n"
       )
{
Ospf6_area.c (ospf6d):410
  struct prefix prefix;
  struct ospf6_route *range;

Ospf6_area.c (ospf6d):417
  ret = str2prefix (argv[0], &prefix);
  if (ret != 1 || prefix.family != AF_INET6)
    {
      vty_out (vty, "Malformed argument: %s%s", argv[0], VNL);
Ospf6_area.c (ospf6d):424
  range = ospf6_route_lookup (&prefix, oa->range_table);
  if (range == NULL)
    {
Ospf6_area.c (ospf6d):449
          prefix2str (&range->prefix, buf, sizeof (buf));
          vty_out (vty, " area %s range %s%s", oa->name, buf, VNL);
        }
Ospf6_area.c (ospf6d):453
        vty_out (vty, " area %s filter-list prefix %s in%s",
                 oa->name, PREFIX_NAME_IN (oa), VNL);
      if (PREFIX_NAME_OUT (oa))
        vty_out (vty, " area %s filter-list prefix %s out%s",
                 oa->name, PREFIX_NAME_OUT (oa), VNL);
      if (IMPORT_NAME (oa))
Ospf6_area.c (ospf6d):469
       "area A.B.C.D filter-list prefix WORD (in|out)",
       "OSPFv6 area parameters\n"
       "OSPFv6 area ID in IP address format\n"
Ospf6_area.c (ospf6d):474
       "Name of an IPv6 prefix-list\n"
       "Filter networks sent to this area\n"
       "Filter networks sent from this area\n")
Ospf6_area.c (ospf6d):510
       "no area A.B.C.D filter-list prefix WORD (in|out)",
       NO_STR
       "OSPFv6 area parameters\n"
Ospf6_area.c (ospf6d):516
       "Name of an IPv6 prefix-list\n"
       "Filter networks sent to this area\n"
       "Filter networks sent from this area\n")
Ospf6_area.c (ospf6d):667
  struct prefix prefix;

  OSPF6_CMD_CHECK_RUNNING ();
Ospf6_area.c (ospf6d):671
  ospf6_linkstate_prefix (ospf6->router_id, htonl (0), &prefix);

  for (ALL_LIST_ELEMENTS_RO (ospf6->area_list, node, oa))
Ospf6_area.c (ospf6d):675
      route = ospf6_route_lookup (&prefix, oa->spf_table);
      if (route == NULL)
        {
Ospf6_area.c (ospf6d):704
  struct prefix prefix;

  OSPF6_CMD_CHECK_RUNNING ();
Ospf6_area.c (ospf6d):708
  ospf6_linkstate_prefix (ospf6->router_id, htonl (0), &prefix);

  if (inet_pton (AF_INET, argv[0], &area_id) != 1)
Ospf6_area.c (ospf6d):722
  route = ospf6_route_lookup (&prefix, oa->spf_table);
  if (route == NULL)
    {
Ospf6_area.c (ospf6d):749
  struct prefix prefix;
  u_int32_t router_id;
  struct ospf6_route_table *spf_table;
Ospf6_area.c (ospf6d):757
  ospf6_linkstate_prefix (router_id, htonl (0), &prefix);

  if (inet_pton (AF_INET, argv[1], &area_id) != 1)
Ospf6_area.c (ospf6d):779
  route = ospf6_route_lookup (&prefix, spf_table);
  if (route == NULL)
    {
Ospf6_area.h (ospf6d):84
  /* Type 3 LSA Area prefix-list */
  struct
  {
Ospf6_asbr.c (ospf6d):26
#include "prefix.h"
#include "command.h"
#include "vty.h"
Ospf6_asbr.c (ospf6d):70
      prefix2str (&route->prefix, buf, sizeof (buf));
      zlog_debug ("Originate AS-External-LSA for %s", buf);
    }
Ospf6_asbr.c (ospf6d):105
  as_external_lsa->prefix.prefix_length = route->prefix.prefixlen;

  /* PrefixOptions */
  as_external_lsa->prefix.prefix_options = route->path.prefix_options;

  /* don't use refer LS-type */
  as_external_lsa->prefix.prefix_refer_lstype = htons (0);

  /* set Prefix */
  memcpy (p, &route->prefix.u.prefix6,
          OSPF6_PREFIX_SPACE (route->prefix.prefixlen));
  ospf6_prefix_apply_mask (&as_external_lsa->prefix);
  p += OSPF6_PREFIX_SPACE (route->prefix.prefixlen);

  /* Forwarding address */
Ospf6_asbr.c (ospf6d):171
  tag_offset = sizeof(*external) + OSPF6_PREFIX_SPACE(external->prefix.prefix_length);
  if (CHECK_FLAG (external->bits_metric, OSPF6_ASBR_BIT_F))
    tag_offset += sizeof(struct in6_addr);
Ospf6_asbr.c (ospf6d):183
  struct prefix asbr_id;
  struct ospf6_route *asbr_entry, *route;
  char buf[64];
Ospf6_asbr.c (ospf6d):208
  if (CHECK_FLAG(external->prefix.prefix_options, OSPF6_PREFIX_OPTION_NU))
    {
      if (IS_OSPF6_DEBUG_EXAMIN (AS_EXTERNAL))
Ospf6_asbr.c (ospf6d):230
  route->prefix.family = AF_INET6;
  route->prefix.prefixlen = external->prefix.prefix_length;
  ospf6_prefix_in6_addr (&route->prefix.u.prefix6, &external->prefix);

  route->path.area_id = asbr_entry->path.area_id;
Ospf6_asbr.c (ospf6d):239
  route->path.prefix_options = external->prefix.prefix_options;
  if (CHECK_FLAG (external->bits_metric, OSPF6_ASBR_BIT_E))
    {
Ospf6_asbr.c (ospf6d):262
      prefix2str (&route->prefix, buf, sizeof (buf));
      zlog_debug ("AS-External route add: %s", buf);
    }
Ospf6_asbr.c (ospf6d):273
  struct prefix prefix;
  struct ospf6_route *route, *nroute;
  char buf[64];
Ospf6_asbr.c (ospf6d):290
  memset (&prefix, 0, sizeof (struct prefix));
  prefix.family = AF_INET6;
  prefix.prefixlen = external->prefix.prefix_length;
  ospf6_prefix_in6_addr (&prefix.u.prefix6, &external->prefix);

  route = ospf6_route_lookup (&prefix, ospf6->route_table);
  if (route == NULL)
    {
Ospf6_asbr.c (ospf6d):300
          prefix2str (&prefix, buf, sizeof (buf));
          zlog_debug ("AS-External route %s not found", buf);
        }
Ospf6_asbr.c (ospf6d):307
       route && ospf6_route_is_prefix (&prefix, route);
       route = nroute)
    {
Ospf6_asbr.c (ospf6d):322
          prefix2str (&route->prefix, buf, sizeof (buf));
          zlog_debug ("AS-External route remove: %s", buf);
        }
Ospf6_asbr.c (ospf6d):341
      inet_ntop (AF_INET, &ADV_ROUTER_IN_PREFIX (&asbr_entry->prefix),
                 buf, sizeof (buf));
       zlog_info ("ignore non-best path: lsentry %s add", buf);
Ospf6_asbr.c (ospf6d):348
  router = ospf6_linkstate_prefix_adv_router (&asbr_entry->prefix);
  for (lsa = ospf6_lsdb_type_router_head (type, router, ospf6->lsdb); lsa;
       lsa = ospf6_lsdb_type_router_next (type, router, lsa))
Ospf6_asbr.c (ospf6d):365
  router = ospf6_linkstate_prefix_adv_router (&asbr_entry->prefix);
  for (lsa = ospf6_lsdb_type_router_head (type, router, ospf6->lsdb);
       lsa; lsa = ospf6_lsdb_type_router_next (type, router, lsa))
Ospf6_asbr.c (ospf6d):439
                                      &route->prefix);
    }

Ospf6_asbr.c (ospf6d):446
ospf6_asbr_redistribute_add (int type, ifindex_t ifindex, struct prefix *prefix,
                             u_int nexthop_num, struct in6_addr *nexthop, route_tag_t tag)
{
Ospf6_asbr.c (ospf6d):454
  struct prefix prefix_id;
  struct route_node *node;
  char pbuf[64], ibuf[16];
Ospf6_asbr.c (ospf6d):465
      prefix2str (prefix, pbuf, sizeof (pbuf));
      zlog_debug ("Redistribute %s (%s)", pbuf, ZROUTE_NAME (type));
    }
Ospf6_asbr.c (ospf6d):491
      ret = route_map_apply (ospf6->rmap[type].map, prefix,
                             RMAP_OSPF6, &troute);
      if (ret == RMAP_DENYMATCH)
Ospf6_asbr.c (ospf6d):501
  match = ospf6_route_lookup (prefix, ospf6->external_table);
  if (match)
    {
Ospf6_asbr.c (ospf6d):550
  memcpy (&route->prefix, prefix, sizeof (struct prefix));

  info = (struct ospf6_external_info *)
Ospf6_asbr.c (ospf6d):606
                                struct prefix *prefix)
{
  struct ospf6_route *match;
Ospf6_asbr.c (ospf6d):612
  struct prefix prefix_id;
  char pbuf[64], ibuf[16];
  struct listnode *lnode, *lnnode;
Ospf6_asbr.c (ospf6d):617
  match = ospf6_route_lookup (prefix, ospf6->external_table);
  if (match == NULL)
    {
Ospf6_asbr.c (ospf6d):622
          prefix2str (prefix, pbuf, sizeof (pbuf));
          zlog_debug ("No such route %s to withdraw", pbuf);
        }
Ospf6_asbr.c (ospf6d):635
          prefix2str (prefix, pbuf, sizeof (pbuf));
          zlog_debug ("Original protocol mismatch: %s", pbuf);
        }
Ospf6_asbr.c (ospf6d):643
      prefix2str (prefix, pbuf, sizeof (pbuf));
      inet_ntop (AF_INET, &prefix_id.u.prefix4, ibuf, sizeof (ibuf));
      zlog_debug ("Withdraw %s (AS-External Id:%s)", pbuf, ibuf);
Ospf6_asbr.c (ospf6d):805
                                              struct prefix *prefix,
                                              route_map_object_t type,
                                              void *object)
Ospf6_asbr.c (ospf6d):818
  return (prefix_list_apply (plist, prefix) == PREFIX_DENY ?
          RMAP_NOMATCH : RMAP_MATCH);
}
Ospf6_asbr.c (ospf6d):837
  "ipv6 address prefix-list",
  ospf6_routemap_rule_match_address_prefixlist,
  ospf6_routemap_rule_match_address_prefixlist_compile,
Ospf6_asbr.c (ospf6d):847
ospf6_routemap_rule_match_interface (void *rule, struct prefix *prefix,
		       route_map_object_t type, void *object)
{
Ospf6_asbr.c (ospf6d):893
ospf6_routemap_rule_match_tag (void *rule, struct prefix *prefix,
                               route_map_object_t type, void *object)
{
Ospf6_asbr.c (ospf6d):916
ospf6_routemap_rule_set_metric_type (void *rule, struct prefix *prefix,
                                     route_map_object_t type, void *object)
{
Ospf6_asbr.c (ospf6d):957
ospf6_routemap_rule_set_metric (void *rule, struct prefix *prefix,
                                route_map_object_t type, void *object)
{
Ospf6_asbr.c (ospf6d):997
ospf6_routemap_rule_set_forwarding (void *rule, struct prefix *prefix,
                                    route_map_object_t type, void *object)
{
Ospf6_asbr.c (ospf6d):1041
ospf6_routemap_rule_set_tag (void *rule, struct prefix *prefix,
                             route_map_object_t type, void *object)
{
Ospf6_asbr.c (ospf6d):1088
       "match ipv6 address prefix-list WORD",
       "Match values\n"
       IPV6_STR
Ospf6_asbr.c (ospf6d):1092
       "Match entries of prefix-lists\n"
       "IPv6 prefix-list name\n")
{
  int ret = route_map_add_match ((struct route_map_index *) vty->index,
                                 "ipv6 address prefix-list", argv[0]);
  return route_map_command_status (vty, ret);
}
Ospf6_asbr.c (ospf6d):1103
       "no match ipv6 address prefix-list WORD",
       NO_STR
       "Match values\n"
Ospf6_asbr.c (ospf6d):1108
       "Match entries of prefix-lists\n"
       "IPv6 prefix-list name\n")
{
  int ret = route_map_delete_match ((struct route_map_index *) vty->index,
                                    "ipv6 address prefix-list", argv[0]);
  return route_map_command_status (vty, ret);
}
Ospf6_asbr.c (ospf6d):1330
  /* Match address prefix-list */
  install_element (RMAP_NODE, &ospf6_routemap_match_address_prefixlist_cmd);
  install_element (RMAP_NODE, &ospf6_routemap_no_match_address_prefixlist_cmd);
Ospf6_asbr.c (ospf6d):1380
	    ospf6_prefix_in6_addr (&in6, &external->prefix);
	    prefix_length = external->prefix.prefix_length;
	  }
	else {
Ospf6_asbr.c (ospf6d):1386
		   OSPF6_PREFIX_SPACE (external->prefix.prefix_length)));
	}
	if (buf)
Ospf6_asbr.c (ospf6d):1418
  ospf6_prefix_options_printbuf (external->prefix.prefix_options,
                                 buf, sizeof (buf));
  vty_out (vty, "     Prefix Options: %s%s", buf,
Ospf6_asbr.c (ospf6d):1424
           ntohs (external->prefix.prefix_refer_lstype),
           VNL);

Ospf6_asbr.c (ospf6d):1452
  char prefix[64], id[16], forwarding[64];
  u_int32_t tmp_id;

  prefix2str (&route->prefix, prefix, sizeof (prefix));
  tmp_id = ntohl (info->id);
  inet_ntop (AF_INET, &tmp_id, id, sizeof (id));
Ospf6_asbr.c (ospf6d):1466
           prefix, id, route->path.metric_type,
           (u_long) (route->path.metric_type == 2 ?
                     route->path.cost_e2 : route->path.cost),
Ospf6_asbr.h (ospf6d):57
#define OSPF6_AS_EXTERNAL_LSA_MIN_SIZE         4U /* w/o IPv6 prefix */
struct ospf6_as_external_lsa
{
Ospf6_asbr.h (ospf6d):62
  struct ospf6_prefix prefix;
  /* followed by none or one forwarding address */
  /* followed by none or one external route tag */
Ospf6_asbr.h (ospf6d):84
                                         struct prefix *prefix,
                                         u_int nexthop_num,
                                         struct in6_addr *nexthop,
Ospf6_asbr.h (ospf6d):89
                                            struct prefix *prefix);

extern int ospf6_redistribute_config_write (struct vty *vty);
Ospf6_interface.c (ospf6d):29
#include "prefix.h"
#include "plist.h"

Ospf6_interface.c (ospf6d):414
                zlog_debug ("%s on %s filtered by prefix-list %s ",
			    buf, oi->interface->name, oi->plist_name);
              continue;
Ospf6_interface.c (ospf6d):421
      memcpy (&route->prefix, c->address, sizeof (struct prefix));
      apply_mask (&route->prefix);
      route->type = OSPF6_DEST_TYPE_NETWORK;
      route->path.area_id = oi->area->area_id;
Ospf6_interface.c (ospf6d):842
  struct prefix *p;
  struct listnode *i;
  char strbuf[64], drouter[32], bdrouter[32];
Ospf6_interface.c (ospf6d):1001
       "show ipv6 ospf6 interface IFNAME prefix",
       SHOW_STR
       IP6_STR
Ospf6_interface.c (ospf6d):1036
       "show ipv6 ospf6 interface IFNAME prefix (X:X::X:X|X:X::X:X/M|detail)",
       SHOW_STR
       IP6_STR
Ospf6_interface.c (ospf6d):1050
       "show ipv6 ospf6 interface IFNAME prefix X:X::X:X/M (match|detail)",
       SHOW_STR
       IP6_STR
Ospf6_interface.c (ospf6d):1064
       "show ipv6 ospf6 interface prefix",
       SHOW_STR
       IP6_STR
Ospf6_interface.c (ospf6d):1090
       "show ipv6 ospf6 interface prefix (X:X::X:X|X:X::X:X/M|detail)",
       SHOW_STR
       IP6_STR
Ospf6_interface.c (ospf6d):1103
       "show ipv6 ospf6 interface prefix X:X::X:X/M (match|detail)",
       SHOW_STR
       IP6_STR
Ospf6_interface.c (ospf6d):1613
       "ipv6 ospf6 advertise prefix-list WORD",
       IP6_STR
       OSPF6_STR
Ospf6_interface.c (ospf6d):1617
       "Filter prefix using prefix-list\n"
       "Prefix list name\n"
       )
Ospf6_interface.c (ospf6d):1654
       "no ipv6 ospf6 advertise prefix-list",
       NO_STR
       IP6_STR
Ospf6_interface.c (ospf6d):1659
       "Filter prefix using prefix-list\n"
       )
{
Ospf6_interface.c (ospf6d):1825
        vty_out (vty, " ipv6 ospf6 advertise prefix-list %s%s",
                 oi->plist_name, VNL);

Ospf6_interface.h (ospf6d):114
  /* prefix-list name to filter connected prefix */
  char *plist_name;
};
Ospf6_intra.c (ospf6d):29
#include "prefix.h"
#include "table.h"
#include "vty.h"
Ospf6_intra.c (ospf6d):532
  struct ospf6_prefix *prefix;
  int cnt = 0, prefixnum;

Ospf6_intra.c (ospf6d):555
	  prefix = (struct ospf6_prefix *) current;
	  if (prefix->prefix_length == 0 ||
	      current + OSPF6_PREFIX_SIZE (prefix) > end)
	    {
	      return (NULL);
Ospf6_intra.c (ospf6d):564
	      current = start + pos*OSPF6_PREFIX_SIZE(prefix);
	      cnt++;
	    }
Ospf6_intra.c (ospf6d):570
	      memcpy (&in6, OSPF6_PREFIX_BODY (prefix),
		      OSPF6_PREFIX_SPACE (prefix->prefix_length));
	      inet_ntop (AF_INET6, &in6, buf, buflen);
	      return (buf);
Ospf6_intra.c (ospf6d):587
  struct ospf6_prefix *prefix;
  const char *p, *mc, *la, *nu;
  struct in6_addr in6;
Ospf6_intra.c (ospf6d):605
  for (current = start; current < end; current += OSPF6_PREFIX_SIZE (prefix))
    {
      prefix = (struct ospf6_prefix *) current;
      if (prefix->prefix_length == 0 ||
          current + OSPF6_PREFIX_SIZE (prefix) > end)
        break;

      p = (CHECK_FLAG (prefix->prefix_options, OSPF6_PREFIX_OPTION_P) ?
           "P" : "--");
      mc = (CHECK_FLAG (prefix->prefix_options, OSPF6_PREFIX_OPTION_MC) ?
           "MC" : "--");
      la = (CHECK_FLAG (prefix->prefix_options, OSPF6_PREFIX_OPTION_LA) ?
           "LA" : "--");
      nu = (CHECK_FLAG (prefix->prefix_options, OSPF6_PREFIX_OPTION_NU) ?
           "NU" : "--");
      vty_out (vty, "     Prefix Options: %s|%s|%s|%s%s",
Ospf6_intra.c (ospf6d):624
      memcpy (&in6, OSPF6_PREFIX_BODY (prefix),
              OSPF6_PREFIX_SPACE (prefix->prefix_length));
      inet_ntop (AF_INET6, &in6, buf, sizeof (buf));
      vty_out (vty, "     Prefix: %s/%d%s",
               buf, prefix->prefix_length, VNL);
    }

Ospf6_intra.c (ospf6d):694
  /* connected prefix to advertise */
  for (route = ospf6_route_head (oi->route_connected); route;
       route = ospf6_route_next (route))
Ospf6_intra.c (ospf6d):698
      op->prefix_length = route->prefix.prefixlen;
      op->prefix_options = route->path.prefix_options;
      op->prefix_metric = htons (0);
      memcpy (OSPF6_PREFIX_BODY (op), &route->prefix.u.prefix6,
              OSPF6_PREFIX_SPACE (op->prefix_length));
      op = OSPF6_PREFIX_NEXT (op);
Ospf6_intra.c (ospf6d):740
  struct ospf6_prefix *prefix;

  if (lsa)
Ospf6_intra.c (ospf6d):757
	  prefix = (struct ospf6_prefix *) current;
	  if (prefix->prefix_length == 0 ||
	      current + OSPF6_PREFIX_SIZE (prefix) > end)
	    {
	      return NULL;
Ospf6_intra.c (ospf6d):766
	      current = start + pos*OSPF6_PREFIX_SIZE(prefix);
	      cnt++;
	    }
Ospf6_intra.c (ospf6d):772
	      memcpy (&in6, OSPF6_PREFIX_BODY (prefix),
		      OSPF6_PREFIX_SPACE (prefix->prefix_length));
	      inet_ntop (AF_INET6, &in6, buf, buflen);
	      sprintf(&buf[strlen(buf)], "/%d", prefix->prefix_length);
	      return (buf);
	    }
Ospf6_intra.c (ospf6d):790
  struct ospf6_prefix *prefix;
  char id[16], adv_router[16];
  const char *p, *mc, *la, *nu;
Ospf6_intra.c (ospf6d):811
  for (current = start; current < end; current += OSPF6_PREFIX_SIZE (prefix))
    {
      prefix = (struct ospf6_prefix *) current;
      if (prefix->prefix_length == 0 ||
          current + OSPF6_PREFIX_SIZE (prefix) > end)
        break;

      p = (CHECK_FLAG (prefix->prefix_options, OSPF6_PREFIX_OPTION_P) ?
           "P" : "--");
      mc = (CHECK_FLAG (prefix->prefix_options, OSPF6_PREFIX_OPTION_MC) ?
           "MC" : "--");
      la = (CHECK_FLAG (prefix->prefix_options, OSPF6_PREFIX_OPTION_LA) ?
           "LA" : "--");
      nu = (CHECK_FLAG (prefix->prefix_options, OSPF6_PREFIX_OPTION_NU) ?
           "NU" : "--");
      vty_out (vty, "     Prefix Options: %s|%s|%s|%s%s",
Ospf6_intra.c (ospf6d):830
      memcpy (&in6, OSPF6_PREFIX_BODY (prefix),
              OSPF6_PREFIX_SPACE (prefix->prefix_length));
      inet_ntop (AF_INET6, &in6, buf, sizeof (buf));
      vty_out (vty, "     Prefix: %s/%d%s",
               buf, prefix->prefix_length, VNL);
    }

Ospf6_intra.c (ospf6d):875
    zlog_debug ("Originate Intra-Area-Prefix-LSA for area %s's stub prefix",
               oa->name);

Ospf6_intra.c (ospf6d):919
      /* connected prefix to advertise */
      for (route = ospf6_route_head (oi->route_connected); route;
           route = ospf6_route_best_next (route))
Ospf6_intra.c (ospf6d):925
              prefix2str (&route->prefix, buf, sizeof (buf));
              zlog_debug ("    include %s", buf);
            }
Ospf6_intra.c (ospf6d):947
      op->prefix_length = route->prefix.prefixlen;
      op->prefix_options = route->path.prefix_options;
      op->prefix_metric = htons (route->path.cost);
      memcpy (OSPF6_PREFIX_BODY (op), &route->prefix.u.prefix6,
              OSPF6_PREFIX_SPACE (op->prefix_length));
      op = OSPF6_PREFIX_NEXT (op);
Ospf6_intra.c (ospf6d):1030
    zlog_debug ("Originate Intra-Area-Prefix-LSA for interface %s's prefix",
               oi->interface->name);

Ospf6_intra.c (ospf6d):1067
  /* connected prefix to advertise */
  route_advertise = ospf6_route_table_create (0, 0);

Ospf6_intra.c (ospf6d):1078
        zlog_debug ("  include prefix from %s", lsa->name);

      if (lsa->header->adv_router != oi->area->ospf6->router_id)
Ospf6_intra.c (ospf6d):1108
          route->prefix.family = AF_INET6;
          route->prefix.prefixlen = op->prefix_length;
          memset (&route->prefix.u.prefix6, 0, sizeof (struct in6_addr));
          memcpy (&route->prefix.u.prefix6, OSPF6_PREFIX_BODY (op),
                  OSPF6_PREFIX_SPACE (op->prefix_length));

Ospf6_intra.c (ospf6d):1126
              prefix2str (&route->prefix, buf, sizeof (buf));
              zlog_debug ("    include %s", buf);
            }
Ospf6_intra.c (ospf6d):1144
      op->prefix_length = route->prefix.prefixlen;
      op->prefix_options = route->path.prefix_options;
      op->prefix_metric = htons (0);
      memcpy (OSPF6_PREFIX_BODY (op), &route->prefix.u.prefix6,
              OSPF6_PREFIX_SPACE (op->prefix_length));
      op = OSPF6_PREFIX_NEXT (op);
Ospf6_intra.c (ospf6d):1191
  struct prefix ls_prefix;
  struct ospf6_route *route, *ls_entry;
  int i, prefix_num;
Ospf6_intra.c (ospf6d):1237
      /* the intra-prefix are directly connected */
      direct_connect = 1;
    }
Ospf6_intra.c (ospf6d):1258
	      ospf6_linkstate_prefix2str ((struct prefix *)OSPF6_PREFIX_BODY(op),
					  buf, sizeof (buf));
	      zlog_debug ("%s: Skipping Prefix %s has NU option set",
Ospf6_intra.c (ospf6d):1268
      memset (&route->prefix, 0, sizeof (struct prefix));
      route->prefix.family = AF_INET6;
      route->prefix.prefixlen = op->prefix_length;
      ospf6_prefix_in6_addr (&route->prefix.u.prefix6, op);

      route->type = OSPF6_DEST_TYPE_NETWORK;
Ospf6_intra.c (ospf6d):1286
          ifp = if_lookup_prefix(&route->prefix);
          if (ifp)
            route->nexthop[0].ifindex = ifp->ifindex;
Ospf6_intra.c (ospf6d):1299
          prefix2str (&route->prefix, buf, sizeof (buf));
          zlog_debug ("  add %s", buf);
        }
Ospf6_intra.c (ospf6d):1316
  struct prefix prefix;
  struct ospf6_route *route, *nroute;
  int prefix_num;
Ospf6_intra.c (ospf6d):1344
      memset (&prefix, 0, sizeof (struct prefix));
      prefix.family = AF_INET6;
      prefix.prefixlen = op->prefix_length;
      ospf6_prefix_in6_addr (&prefix.u.prefix6, op);

      route = ospf6_route_lookup (&prefix, oa->route_table);
      if (route == NULL)
        continue;
Ospf6_intra.c (ospf6d):1354
           route && ospf6_route_is_prefix (&prefix, route);
           route = nroute)
        {
Ospf6_intra.c (ospf6d):1371
              prefix2str (&route->prefix, buf, sizeof (buf));
              zlog_debug ("remove %s", buf);
            }
Ospf6_intra.c (ospf6d):1452
  brouter_id = ADV_ROUTER_IN_PREFIX (&brouter->prefix);
  inet_ntop (AF_INET, &brouter_id, brouter_name, sizeof (brouter_name));
  inet_ntop (AF_INET, &brouter->path.area_id, area_name, sizeof (area_name));
  ospf6_linkstate_prefix2str (&brouter->prefix, destination,
                              sizeof (destination));

Ospf6_intra.c (ospf6d):1477
  zlog_info ("  type: %d prefix: %s installed: %s changed: %s",
             brouter->type, destination, installed, changed);
  zlog_info ("  lock: %d flags: %s%s%s%s", brouter->lock,
Ospf6_intra.c (ospf6d):1514
      brouter_id = ADV_ROUTER_IN_PREFIX (&brouter->prefix);
      inet_ntop (AF_INET, &brouter_id, brouter_name, sizeof (brouter_name));
      if (brouter->path.area_id != oa->area_id)
Ospf6_intra.c (ospf6d):1532
      brouter_id = ADV_ROUTER_IN_PREFIX (&brouter->prefix);
      inet_ntop (AF_INET, &brouter_id, brouter_name, sizeof (brouter_name));

Ospf6_intra.c (ospf6d):1537
      if (ospf6_linkstate_prefix_id (&brouter->prefix) != htonl (0))
        continue;
      if (! CHECK_FLAG (brouter->path.router_bits, OSPF6_ROUTER_BIT_E) &&
Ospf6_intra.c (ospf6d):1568
      brouter_id = ADV_ROUTER_IN_PREFIX (&brouter->prefix);
      inet_ntop (AF_INET, &brouter_id, brouter_name, sizeof (brouter_name));
      
Ospf6_intra.h (ospf6d):135
#define OSPF6_LINK_LSA_MIN_SIZE               24U /* w/o 1st IPv6 prefix */
struct ospf6_link_lsa
{
Ospf6_intra.h (ospf6d):142
  /* followed by ospf6 prefix(es) */
};

Ospf6_intra.h (ospf6d):146
#define OSPF6_INTRA_PREFIX_LSA_MIN_SIZE       12U /* w/o 1st IPv6 prefix */
struct ospf6_intra_prefix_lsa
{
Ospf6_intra.h (ospf6d):153
  /* followed by ospf6 prefix(es) */
};

Ospf6_lsa.c (ospf6d):821
       "debug ospf6 lsa (router|network|inter-prefix|inter-router|as-ext|grp-mbr|type7|link|intra-prefix|unknown)",
       DEBUG_STR
       OSPF6_STR
Ospf6_lsa.c (ospf6d):865
       "debug ospf6 lsa (router|network|inter-prefix|inter-router|as-ext|grp-mbr|type7|link|intra-prefix|unknown) (originate|examine|flooding)",
       DEBUG_STR
       OSPF6_STR
Ospf6_lsa.c (ospf6d):874
       "no debug ospf6 lsa (router|network|inter-prefix|inter-router|as-ext|grp-mbr|type7|link|intra-prefix|unknown)",
       NO_STR
       DEBUG_STR
Ospf6_lsa.c (ospf6d):918
       "no debug ospf6 lsa (router|network|inter-prefix|inter-router|as-ext|grp-mbr|type7|link|intra-prefix) (originate|examine|flooding)",
       NO_STR
       DEBUG_STR
Ospf6_lsa.h (ospf6d):161
/* addr is (struct prefix *) */
#define CONTINUE_IF_ADDRESS_LINKLOCAL(debug,addr)      \
  if (IN6_IS_ADDR_LINKLOCAL (&(addr)->u.prefix6))      \
Ospf6_lsdb.c (ospf6d):27
#include "prefix.h"
#include "table.h"
#include "vty.h"
Ospf6_lsdb.c (ospf6d):70
  memcpy ((caddr_t) &key->prefix + key->prefixlen / 8,
          (caddr_t) value, len);
  key->family = AF_INET6;
Ospf6_lsdb.c (ospf6d):117
  current = route_node_get (lsdb->table, (struct prefix *) &key);
  old = current->info;
  current->info = lsa;
Ospf6_lsdb.c (ospf6d):181
  node = route_node_lookup (lsdb->table, (struct prefix *) &key);
  assert (node && node->info == lsa);

Ospf6_lsdb.c (ospf6d):212
  node = route_node_lookup (lsdb->table, (struct prefix *) &key);
  if (node == NULL || node->info == NULL)
    return NULL;
Ospf6_lsdb.c (ospf6d):227
  struct prefix *p;

  if (lsdb == NULL)
Ospf6_lsdb.c (ospf6d):236
  p = (struct prefix *) &key;

  {
Ospf6_lsdb.c (ospf6d):250
      node = node->link[prefix_bit(&p->u.prefix, node->p.prefixlen)];
    }

Ospf6_lsdb.c (ospf6d):337
	 prefix_match (&node->p, (struct prefix *) &key))
    node = node->link[prefix6_bit(&key.prefix, node->p.prefixlen)];

  if (node)
Ospf6_lsdb.c (ospf6d):348
  if (! prefix_match ((struct prefix *) &key, &node->p))
    return NULL;

Ospf6_lsdb.c (ospf6d):390
	 prefix_match (&node->p, (struct prefix *) &key))
    node = node->link[prefix6_bit(&key.prefix, node->p.prefixlen)];

  if (node)
Ospf6_lsdb.c (ospf6d):401
  if (! prefix_match ((struct prefix *) &key, &node->p))
    return NULL;

Ospf6_lsdb.h (ospf6d):25
#include "prefix.h"
#include "table.h"

Ospf6_main.c (ospf6d):33
#include "prefix.h"
#include "plist.h"
#include "privs.h"
Ospf6_message.c (ospf6d):906
        zlog_debug ("%s: undersized IPv6 prefix header", __func__);
      return MSG_NG;
    }
Ospf6_message.c (ospf6d):921
        zlog_debug ("%s: undersized IPv6 prefix", __func__);
      return MSG_NG;
    }
    /* next prefix */
    length -= requested_pfx_bytes;
    current = (struct ospf6_prefix *) ((caddr_t) current + requested_pfx_bytes);
Ospf6_message.c (ospf6d):932
      zlog_debug ("%s: IPv6 prefix number mismatch (%u required, %u real)",
                  __func__, req_num_pfxs, real_num_pfxs);
    return MSG_NG;
Ospf6_message.c (ospf6d):993
       followed by 3-4 fields of a single IPv6 prefix. */
    if (headeronly)
      break;
Ospf6_message.c (ospf6d):1014
       followed by 3-4 fields of IPv6 prefix and 3 conditional LSA fields:
       16 bytes of forwarding address, 4 bytes of external route tag,
       4 bytes of referenced link state ID. */
Ospf6_message.c (ospf6d):1023
       prefix before ospf6_prefix_examin() confirms its sizing. */
    if (exp_length + OSPF6_PREFIX_MIN_SIZE > lsalen)
    {
Ospf6_message.c (ospf6d):1037
    if (as_external_lsa->prefix.u._prefix_referenced_lstype)
      exp_length += 4;
    /* All the fixed-size fields (mandatory and optional) must fit. I.e.,
       this check does not include any IPv6 prefix fields. */
    if (exp_length > lsalen)
    {
Ospf6_message.c (ospf6d):1047
    /* The last call completely covers the remainder (IPv6 prefix). */
    return ospf6_prefixes_examin
    (
Ospf6_message.c (ospf6d):1056
       by N>=0 IPv6 prefix blocks (with N declared beforehand). */
    if (headeronly)
      break;
Ospf6_proto.c (ospf6d):46
   * prefix bits it must be there for us to write */
  if (mask)
    pnt[index++] &= mask;
Ospf6_route.c (ospf6d):26
#include "prefix.h"
#include "table.h"
#include "vty.h"
Ospf6_route.c (ospf6d):88
                          "area %s summary prefix table", oa->name);
                break;
              case OSPF6_TABLE_TYPE_SUMMARY_ROUTERS:
Ospf6_route.c (ospf6d):138
                        struct prefix *prefix)
{
  memset (prefix, 0, sizeof (struct prefix));
  prefix->family = AF_INET6;
  prefix->prefixlen = 64;
  memcpy (&prefix->u.prefix6.s6_addr[0], &adv_router, 4);
  memcpy (&prefix->u.prefix6.s6_addr[4], &id, 4);
}

Ospf6_route.c (ospf6d):148
ospf6_linkstate_prefix2str (struct prefix *prefix, char *buf, int size)
{
  u_int32_t adv_router, id;
Ospf6_route.c (ospf6d):152
  memcpy (&adv_router, &prefix->u.prefix6.s6_addr[0], 4);
  memcpy (&id, &prefix->u.prefix6.s6_addr[4], 4);
  inet_ntop (AF_INET, &adv_router, adv_router_str, sizeof (adv_router_str));
  inet_ntop (AF_INET, &id, id_str, sizeof (id_str));
Ospf6_route.c (ospf6d):262
ospf6_route_lookup (struct prefix *prefix,
                    struct ospf6_route_table *table)
{
Ospf6_route.c (ospf6d):268
  node = route_node_lookup (table->table, prefix);
  if (node == NULL)
    return NULL;
Ospf6_route.c (ospf6d):282
  for (target = ospf6_route_lookup (&route->prefix, table);
       target; target = target->next)
    {
Ospf6_route.c (ospf6d):292
ospf6_route_lookup_bestmatch (struct prefix *prefix,
                              struct ospf6_route_table *table)
{
Ospf6_route.c (ospf6d):298
  node = route_node_match (table->table, prefix);
  if (node == NULL)
    return NULL;
Ospf6_route.c (ospf6d):343
      prefix2str (&r->prefix, buf, sizeof (buf));
      zlog_info ("%p<-[%p]->%p : %s", r->prev, r, r->next, buf);
    }
Ospf6_route.c (ospf6d):371
    ospf6_linkstate_prefix2str (&route->prefix, buf, sizeof (buf));
  else
    prefix2str (&route->prefix, buf, sizeof (buf));

  if (IS_OSPF6_DEBUG_ROUTE (MEMORY))
Ospf6_route.c (ospf6d):383
  node = route_node_get (table->table, &route->prefix);
  route->rnode = node;

Ospf6_route.c (ospf6d):514
  /* Else, this is the brand new route regarding to the prefix */
  if (IS_OSPF6_DEBUG_ROUTE (MEMORY))
    zlog_debug ("%s %p: route add %p: brand new route",
Ospf6_route.c (ospf6d):590
    ospf6_linkstate_prefix2str (&route->prefix, buf, sizeof (buf));
  else
    prefix2str (&route->prefix, buf, sizeof (buf));

  if (IS_OSPF6_DEBUG_ROUTE (MEMORY))
Ospf6_route.c (ospf6d):601
  node = route_node_lookup (table->table, &route->prefix);
  assert (node);

Ospf6_route.c (ospf6d):716
ospf6_route_match_head (struct prefix *prefix,
                        struct ospf6_route_table *table)
{
Ospf6_route.c (ospf6d):724
  while (node && node->p.prefixlen < prefix->prefixlen &&
	 prefix_match (&node->p, prefix))
    node = node->link[prefix_bit(&prefix->u.prefix, node->p.prefixlen)];

  if (node)
Ospf6_route.c (ospf6d):736
  if (! prefix_match (prefix, &node->p))
    return NULL;

Ospf6_route.c (ospf6d):745
ospf6_route_match_next (struct prefix *prefix,
                        struct ospf6_route *route)
{
Ospf6_route.c (ospf6d):751
  if (next && ! prefix_match (prefix, &next->prefix))
    {
      ospf6_route_unlock (next);
Ospf6_route.c (ospf6d):805
    ospf6_linkstate_prefix2str (&route->prefix, destination,
                                sizeof (destination));
  else if (route->type == OSPF6_DEST_TYPE_ROUTER)
    inet_ntop (route->prefix.family, &route->prefix.u.prefix,
               destination, sizeof (destination));
  else
    prefix2str (&route->prefix, destination, sizeof (destination));

  /* nexthop */
Ospf6_route.c (ospf6d):851
    ospf6_linkstate_prefix2str (&route->prefix, destination,
                                sizeof (destination));
  else if (route->type == OSPF6_DEST_TYPE_ROUTER)
    inet_ntop (route->prefix.family, &route->prefix.u.prefix,
               destination, sizeof (destination));
  else
    prefix2str (&route->prefix, destination, sizeof (destination));
  vty_out (vty, "Destination: %s%s", destination, VNL);

Ospf6_route.c (ospf6d):978
                               struct prefix *prefix,
                               struct ospf6_route_table *table)
{
Ospf6_route.c (ospf6d):983
  route = ospf6_route_lookup (prefix, table);
  if (route == NULL)
    return;
Ospf6_route.c (ospf6d):988
  while (route && ospf6_route_is_prefix (prefix, route))
    {
      /* Specifying a prefix will always display details */
      ospf6_route_show_detail (vty, route);
      route = ospf6_route_next (route);
Ospf6_route.c (ospf6d):1000
                                struct prefix *prefix,
                                struct ospf6_route_table *table)
{
Ospf6_route.c (ospf6d):1005
  route = ospf6_route_lookup_bestmatch (prefix, table);
  if (route == NULL)
    return;
Ospf6_route.c (ospf6d):1009
  prefix = &route->prefix;
  ospf6_route_lock (route);
  while (route && ospf6_route_is_prefix (prefix, route))
    {
      /* Specifying a prefix will always display details */
      ospf6_route_show_detail (vty, route);
      route = ospf6_route_next (route);
Ospf6_route.c (ospf6d):1023
                              struct prefix *prefix,
                              struct ospf6_route_table *table)
{
Ospf6_route.c (ospf6d):1027
  assert (prefix->family);

  route = ospf6_route_match_head (prefix, table);
  while (route)
    {
Ospf6_route.c (ospf6d):1036
      route = ospf6_route_match_next (prefix, route);
    }
}
Ospf6_route.c (ospf6d):1087
  struct prefix prefix;
  u_char type = 0;

  memset (&prefix, 0, sizeof (struct prefix));

  for (i = 0; i < argc; i++)
Ospf6_route.c (ospf6d):1136
      ret = str2prefix (argv[i], &prefix);
      if (ret == 1 && prefix.family == AF_INET6)
        {
          isprefix++;
Ospf6_route.c (ospf6d):1156
  /* Give exact prefix-match route */
  if (isprefix && ! match)
    {
Ospf6_route.c (ospf6d):1161
        ospf6_route_show_table_address (vty, &prefix, table);
      else
        ospf6_route_show_table_prefix (vty, &prefix, table);

      return CMD_SUCCESS;
Ospf6_route.c (ospf6d):1169
    ospf6_route_show_table_match (vty, detail, &prefix, table);
  else if (type)
    ospf6_route_show_table_type (vty, detail, type, table);
Ospf6_route.c (ospf6d):1191
  router = ospf6_linkstate_prefix_adv_router (&route->prefix);
  inet_ntop (AF_INET, &router, routername, sizeof (routername));
  id = ospf6_linkstate_prefix_id (&route->prefix);
  inet_ntop (AF_INET, &id, idname, sizeof (idname));

Ospf6_route.c (ospf6d):1212
                                  struct prefix *prefix,
                                  struct ospf6_route_table *table)
{
Ospf6_route.c (ospf6d):1217
  route = ospf6_route_lookup (prefix, table);
  if (route == NULL)
    return;
Ospf6_route.c (ospf6d):1222
  while (route && ospf6_route_is_prefix (prefix, route))
    {
      /* Specifying a prefix will always display details */
      ospf6_route_show_detail (vty, route);
      route = ospf6_route_next (route);
Ospf6_route.c (ospf6d):1260
  struct prefix router, id, prefix;

  memset (&router, 0, sizeof (struct prefix));
  memset (&id, 0, sizeof (struct prefix));
  memset (&prefix, 0, sizeof (struct prefix));

  for (i = 0; i < argc; i++)
Ospf6_route.c (ospf6d):1304
                            id.u.prefix4.s_addr, &prefix);

  if (prefix.family)
    ospf6_linkstate_show_table_exact (vty, &prefix, table);
  else
    ospf6_linkstate_show_table (vty, detail, table);
Ospf6_route.c (ospf6d):1328
  adv_router = ospf6_linkstate_prefix_adv_router (&route->prefix);
  inet_ntop (AF_INET, &adv_router, adv, sizeof (adv));
  ospf6_capability_printbuf (route->path.router_bits, rbits, sizeof (rbits));
Ospf6_route.h (ospf6d):111
#include "prefix.h"
#include "table.h"

Ospf6_route.h (ospf6d):127
   * for the advertising router-ID and prefix IDs, instead of stuffing them
   * into one. See also XXX below.
   */
Ospf6_route.h (ospf6d):131
  struct prefix prefix;

  /* Time */
Ospf6_route.h (ospf6d):225
#define OSPF6_ROUTE_MATCH_STR   "Display the route matches the prefix\n"

#define ospf6_route_is_prefix(p, r) \
  (memcmp (p, &(r)->prefix, sizeof (struct prefix)) == 0)
#define ospf6_route_is_same(ra, rb) \
  (prefix_same (&(ra)->prefix, &(rb)->prefix))
#define ospf6_route_is_same_origin(ra, rb) \
  ((ra)->path.area_id == (rb)->path.area_id && \
Ospf6_route.h (ospf6d):237
   memcmp (&(ra)->prefix, &(rb)->prefix, sizeof (struct prefix)) == 0 && \
   memcmp (&(ra)->path, &(rb)->path, sizeof (struct ospf6_path)) == 0 && \
   memcmp (&(ra)->nexthop, &(rb)->nexthop,                               \
Ospf6_route.h (ospf6d):255
                                    struct prefix *prefix);
extern void ospf6_linkstate_prefix2str (struct prefix *prefix, char *buf,
                                        int size);

Ospf6_route.h (ospf6d):266
extern struct ospf6_route *ospf6_route_lookup (struct prefix *prefix,
                                               struct ospf6_route_table *table);
extern struct ospf6_route *ospf6_route_lookup_identical (struct ospf6_route *route,
Ospf6_route.h (ospf6d):270
extern struct ospf6_route *ospf6_route_lookup_bestmatch (struct prefix *prefix,
                                              struct ospf6_route_table *table);

Ospf6_route.h (ospf6d):282
extern struct ospf6_route *ospf6_route_match_head (struct prefix *prefix,
                                            struct ospf6_route_table *table);
extern struct ospf6_route *ospf6_route_match_next (struct prefix *prefix,
                                            struct ospf6_route *route);

Ospf6_spf.c (ospf6d):30
#include "prefix.h"
#include "pqueue.h"
#include "linklist.h"
Ospf6_spf.c (ospf6d):345
  memcpy (&route->prefix, &v->vertex_id, sizeof (struct prefix));
  route->type = OSPF6_DEST_TYPE_LINKSTATE;
  route->path.type = OSPF6_PATH_TYPE_INTRA;
Ospf6_spf.c (ospf6d):694
ospf6_spf_display_subtree (struct vty *vty, const char *prefix, int rest,
                           struct ospf6_vertex *v)
{
Ospf6_spf.c (ospf6d):703
  /* "prefix" is the space prefix of the display line */
  vty_out (vty, "%s+-%s [%d]%s", prefix, v->name, v->cost, VNL);

  len = strlen (prefix) + 4;
  next_prefix = (char *) malloc (len);
  if (next_prefix == NULL)
Ospf6_spf.c (ospf6d):713
  snprintf (next_prefix, len, "%s%s", prefix, (rest ? "|  " : "   "));

  restnum = listcount (v->child_list);
Ospf6_spf.h (ospf6d):46
  struct prefix vertex_id;

  /* Identifier String */
Ospf6_spf.h (ospf6d):154
extern void ospf6_spf_display_subtree (struct vty *vty, const char *prefix,
                                       int rest, struct ospf6_vertex *v);

Ospf6_top.c (ospf6d):28
#include "prefix.h"
#include "table.h"
#include "thread.h"
Ospf6_top.c (ospf6d):102
  ospf6_abr_examin_brouter (ADV_ROUTER_IN_PREFIX (&route->prefix));
  ospf6_asbr_lsentry_add (route);
  ospf6_abr_originate_summary (route);
Ospf6_top.c (ospf6d):110
  ospf6_abr_examin_brouter (ADV_ROUTER_IN_PREFIX (&route->prefix));
  ospf6_asbr_lsentry_remove (route);
  ospf6_abr_originate_summary (route);
Ospf6_top.c (ospf6d):774
       "IP source prefix\n")
{
  struct ospf6 *o;
Ospf6_top.c (ospf6d):791
       "IP source prefix\n")
{
  struct ospf6 *o;
Ospf6_top.c (ospf6d):808
       "IP source prefix\n"
       "Access list name\n")
{
Ospf6_top.c (ospf6d):826
       "IP source prefix\n"
       "Access list name\n")
{
Ospf6_top.c (ospf6d):1172
       "Specify IPv6 prefix\n"
       "Detailed information\n"
       "Summary of route table\n"
Ospf6_top.c (ospf6d):1184
       "Specify IPv6 prefix\n"
       "Display routes which match the specified route\n"
       )
Ospf6_top.c (ospf6d):1211
       "Specify IPv6 prefix\n"
       "Display routes which match the specified route\n"
       "Detailed information\n"
Ospf6_top.c (ospf6d):1240
       "Specify IPv6 prefix\n"
       "Display routes longer than the specified route\n"
       )
Ospf6_top.c (ospf6d):1251
       "Specify IPv6 prefix\n"
       "Display routes longer than the specified route\n"
       "Detailed information\n"
Ospf6_zebra.c (ospf6d):27
#include "prefix.h"
#include "stream.h"
#include "zclient.h"
Ospf6_zebra.c (ospf6d):54
  struct prefix router_id;
  struct ospf6 *o = ospf6;

Ospf6_zebra.c (ospf6d):162
		inet_ntop (c->address->family, &c->address->u.prefix,
			   buf, sizeof (buf)), c->address->prefixlen);

Ospf6_zebra.c (ospf6d):188
		inet_ntop (c->address->family, &c->address->u.prefix,
			   buf, sizeof (buf)), c->address->prefixlen);

Ospf6_zebra.c (ospf6d):221
  /* IPv6 prefix. */
  memset (&p, 0, sizeof (struct prefix_ipv6));
  p.family = AF_INET6;
Ospf6_zebra.c (ospf6d):226
  stream_get (&p.prefix, s, PSIZE (p.prefixlen));

  /* Nexthop, ifindex, distance, metric. */
Ospf6_zebra.c (ospf6d):258
      prefix2str ((struct prefix *)&p, prefixstr, sizeof (prefixstr));
      if (nexthop)
        inet_ntop (AF_INET6, nexthop, nexthopstr, sizeof (nexthopstr));
Ospf6_zebra.c (ospf6d):270
    ospf6_asbr_redistribute_add (api.type, ifindex, (struct prefix *) &p,
                                 api.nexthop_num, nexthop, api.tag);
  else
    ospf6_asbr_redistribute_remove (api.type, ifindex, (struct prefix *) &p);

  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))
Ospf6_zebra.c (ospf6d):377
      prefix2str (&request->prefix, buf, sizeof (buf));
      zlog_debug ("Send %s route: %s",
		  (type == REM ? "remove" : "add"), buf);
Ospf6_zebra.c (ospf6d):484
  dest = (struct prefix_ipv6 *) &request->prefix;
  if (type == REM)
    ret = zapi_ipv6_route (ZEBRA_IPV6_ROUTE_DELETE, zclient, dest, &api);
Ospf6_zebra.c (ospf6d):612
      vty_out (vty, "Malformed prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Ospf6_zebra.c (ospf6d):619
  rn = route_node_get (o->distance_table, (struct prefix *) &p);
  if (rn->info)
    {
Ospf6_zebra.c (ospf6d):659
      vty_out (vty, "Malformed prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Ospf6_zebra.c (ospf6d):663
  rn = route_node_lookup (o->distance_table, (struct prefix *) &p);
  if (!rn)
    {
      vty_out (vty, "Cant't find specified prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Ospf6_zebra.h (ospf6d):42
  /* Distance value for the IP source prefix */
  u_char distance;

Ospfclient.c (ospfclient):31
#include "prefix.h" /* needed by ospf_asbr.h */
#include "privs.h"
#include "log.h"
Ospfd.c (ospfd):27
#include "prefix.h"
#include "table.h"
#include "if.h"
Ospfd.c (ospfd):71
static void ospf_network_run (struct prefix *, struct ospf_area *);
static void ospf_network_run_interface (struct ospf *, struct interface *, 
                                        struct prefix *, struct ospf_area *);
static void ospf_network_run_subnet (struct ospf *, struct connected *, 
                                     struct prefix *, struct ospf_area *);
static int ospf_network_match_iface (const struct connected *,
				     const struct prefix *);
static void ospf_finish_final (struct ospf *);

Ospfd.c (ospfd):826
  rn = route_node_get (ospf->networks, (struct prefix *)p);
  if (rn->info)
    {
Ospfd.c (ospfd):838
  ospf_network_run ((struct prefix *)p, area);

  /* Update connected redistribute. */
Ospfd.c (ospfd):857
  rn = route_node_lookup (ospf->networks, (struct prefix *)p);
  if (rn == NULL)
    return 0;
Ospfd.c (ospfd):937
ospf_network_match_iface(const struct connected *co, const struct prefix *net)
{
  /* new approach: more elegant and conceptually clean */
Ospfd.c (ospfd):964
 * - If no specific network prefix/area is supplied, whether there's
 *   a matching network configured.
 */
Ospfd.c (ospfd):969
                         struct prefix *p, struct ospf_area *given_area)
{
  struct ospf_interface *oi;
Ospfd.c (ospfd):1037
                            struct prefix *p,
                            struct ospf_area *given_area)
{
Ospfd.c (ospfd):1046
  /* Network prefix without area is nonsensical */
  if (p)
    assert (given_area != NULL);
Ospfd.c (ospfd):1050
  /* if interface prefix is match specified prefix,
     then create socket and join multicast group. */
  for (ALL_LIST_ELEMENTS_RO (ifp->connected, cnode, co))
Ospfd.c (ospfd):1057
ospf_network_run (struct prefix *p, struct ospf_area *area)
{
  struct interface *ifp;
Ospfd.c (ospfd):1516
  p.prefix = nbr_nbma->addr;
  p.prefixlen = IPV4_MAX_BITLEN;

  rn = route_node_lookup (ospf->nbr_nbma, (struct prefix *)&p);
  if (rn)
    {
Ospfd.c (ospfd):1550
  struct prefix p;

  if (oi->type != OSPF_IFTYPE_NBMA)
Ospfd.c (ospfd):1569
  rn = route_node_get (oi->nbrs, (struct prefix *)&p);
  if (rn->info)
    {
Ospfd.c (ospfd):1608
	  p.prefix = nbr_nbma->addr;
	  p.prefixlen = IPV4_MAX_BITLEN;

	  if (prefix_match (oi->address, (struct prefix *)&p))
	    ospf_nbr_nbma_add (nbr_nbma, oi);
	}
Ospfd.c (ospfd):1623
  p.prefix = nbr_addr;
  p.prefixlen = IPV4_MAX_BITLEN;

  rn = route_node_lookup (ospf->nbr_nbma, (struct prefix *)&p);
  if (rn)
    {
Ospfd.c (ospfd):1681
  p.prefix = nbr_addr;
  p.prefixlen = IPV4_MAX_BITLEN;

  rn = route_node_get (ospf->nbr_nbma, (struct prefix *)&p);
  if (rn->info)
    route_unlock_node (rn);
Ospfd.c (ospfd):1692
	if (prefix_match (oi->address, (struct prefix *)&p))
	  {
	    ospf_nbr_nbma_add (nbr_nbma, oi);
Ospfd.h (ospfd):193
					   prefix is LSA's adv. network*/

  /* Time stamps */
Ospfd.h (ospfd):365
  /* Type 3 LSA Area prefix-list. */
  struct 
  {
Ospf_abr.c (ospfd):29
#include "prefix.h"
#include "if.h"
#include "table.h"
Ospf_abr.c (ospfd):60
  range->addr = p->prefix;
  range->masklen = p->prefixlen;
  range->cost_config = OSPF_AREA_RANGE_COST_UNSPEC;
Ospf_abr.c (ospfd):81
  p.prefix = range->addr;

  rn = route_node_get (area->ranges, (struct prefix *)&p);
  if (rn->info)
    route_unlock_node (rn);
Ospf_abr.c (ospfd):110
  rn = route_node_lookup (area->ranges, (struct prefix *)p);
  if (rn)
    {
Ospf_abr.c (ospfd):130
  p.prefix = *range_net;

  if (first)
Ospf_abr.c (ospfd):136
      rn = route_node_get (area->ranges, (struct prefix *) &p);
      rn = route_next (rn);
    }
Ospf_abr.c (ospfd):159
  node = route_node_match (area->ranges, (struct prefix *) p);
  if (node)
    {
Ospf_abr.c (ospfd):267
  rn = route_node_lookup (area->ranges, (struct prefix*)p);
  if (rn == NULL)
    return 0;
Ospf_abr.c (ospfd):305
  range->subst_addr = s->prefix;
  range->subst_masklen = s->prefixlen;

Ospf_abr.c (ospfd):658
  p.prefix = lsa->data->id;
  p.prefixlen = ip_masklen (ext7->mask);
  
Ospf_abr.c (ospfd):670
  /* try find existing AS-External LSA for this prefix */

  old = ospf_external_info_find_lsa (area->ospf, &p);
Ospf_abr.c (ospfd):718
  /* The Type-7 is created from the aggregated prefix and forwarded
     for lsa installation and flooding... to be added... */
}
Ospf_abr.c (ospfd):775
	      prefix2str ((struct prefix *) p, buf, sizeof(buf));
	      zlog_warn ("%s: Could not refresh %s to %s",
	                 __func__,
Ospf_abr.c (ospfd):799
      	  prefix2str ((struct prefix *)p, buf, sizeof(buf));
	  zlog_warn ("%s: Could not originate %s to %s",
	             __func__,
Ospf_abr.c (ospfd):911
		       "prefix %s/%d was denied by import-list",
		       inet_ntoa (p->prefix), p->prefixlen);
	  continue; 
	}
Ospf_abr.c (ospfd):920
		       "prefix %s/%d was denied by prefix-list",
		       inet_ntoa (p->prefix), p->prefixlen);
	  continue; 
	}
Ospf_abr.c (ospfd):939
		       inet_ntoa (p->prefix), p->prefixlen);

          if (!OSPF_IS_AREA_BACKBONE (area))
Ospf_abr.c (ospfd):950
                       inet_ntoa (p->prefix), p->prefixlen);
          if ((range = ospf_area_range_match (or_area, p)) 
               && !ospf_area_is_transit (area))
Ospf_abr.c (ospfd):1084
	    zlog_debug("ospf_abr_process_network_rt(): denied by prefix-list");
	  continue;
	}
Ospf_abr.c (ospfd):1166
          prefix2str ((struct prefix *)p, buf, sizeof(buf));
          zlog_warn ("%s: Could not refresh/originate %s to %s",
                     __func__,
Ospf_abr.c (ospfd):1226
		       "this is inter-area route to %s", inet_ntoa (p->prefix));
          if (!OSPF_IS_AREA_BACKBONE (area))
	    ospf_abr_announce_rtr_to_area (p, or->cost, area);
Ospf_abr.c (ospfd):1235
		       "this is intra-area route to %s", inet_ntoa (p->prefix));
          ospf_abr_announce_rtr_to_area (p, or->cost, area);
	}
Ospf_abr.c (ospfd):1443
  struct prefix p;
  struct listnode *node, *n;

Ospf_abr.c (ospfd):1555
          p.prefix = range->addr;
          p.prefixlen = range->masklen;

Ospf_abr.c (ospfd):1561
		       inet_ntoa (p.prefix), p.prefixlen);

          if (CHECK_FLAG (range->flags, OSPF_AREA_RANGE_SUBSTITUTE))
Ospf_abr.c (ospfd):1566
	      p.prefix = range->subst_addr;
	      p.prefixlen = range->subst_masklen;
	    }
Ospf_abr.c (ospfd):1575
              /* Fetch LSA-Type-7 from aggregate prefix, and then
               *  translate, Install (as Type-5), Approve, and Flood
               */
Ospf_abr.c (ospfd):1601
  p.prefix.s_addr = OSPF_DEFAULT_DESTINATION;
  p.prefixlen = 0;

Ospf_api.c (ospfd):28
#include "prefix.h"
#include "if.h"
#include "table.h"
Ospf_apiclient.c (ospfclient):28
#include "prefix.h"
#include "linklist.h"
#include "if.h"
Ospf_apiserver.c (ospfd):28
#include "prefix.h"
#include "if.h"
#include "table.h"
Ospf_asbr.c (ospfd):28
#include "prefix.h"
#include "if.h"
#include "table.h"
Ospf_asbr.c (ospfd):55
  rn = route_node_lookup (ospf->old_external_route, (struct prefix *) p);
  if (rn)
    if ((or = rn->info))
Ospf_asbr.c (ospfd):60
		   inet_ntoa (p->prefix), p->prefixlen);

	/* Remove route from zebra. */
Ospf_asbr.c (ospfd):75
	     inet_ntoa (p->prefix), p->prefixlen);
}

Ospf_asbr.c (ospfd):85
  rn = route_node_lookup (ospf->old_external_route, (struct prefix *) p);
  if (rn)
    {
Ospf_asbr.c (ospfd):93
  zlog_warn ("Route[%s/%d]: lookup, no such prefix",
	     inet_ntoa (p->prefix), p->prefixlen);

  return NULL;
Ospf_asbr.c (ospfd):148
  rn = route_node_get (EXTERNAL_INFO (type), (struct prefix *) &p);
  /* If old info exists, -- discard new one or overwrite with new one? */
  if (rn)
Ospf_asbr.c (ospfd):156
		   inet_ntoa (p.prefix), p.prefixlen);
	/* XFREE (MTYPE_OSPF_TMP, rn->info); */
	return rn->info;
Ospf_asbr.c (ospfd):174
	       inet_ntoa (p.prefix), p.prefixlen);
  return new;
}
Ospf_asbr.c (ospfd):183
  rn = route_node_lookup (EXTERNAL_INFO (type), (struct prefix *) &p);
  if (rn)
    {
Ospf_asbr.c (ospfd):197
  rn = route_node_lookup (EXTERNAL_INFO (type), (struct prefix *) p);
  if (rn)
    {
Ospf_asbr.c (ospfd):217
				p->prefix, ospf->router_id);

  if (!lsa)
Ospf_asbr.c (ospfd):228
      id.s_addr = p->prefix.s_addr | (~mask.s_addr);
      lsa = ospf_lsdb_lookup_by_id (ospf->lsdb, OSPF_AS_EXTERNAL_LSA,
				   id, ospf->router_id);
Ospf_ase.c (ospfd):29
#include "prefix.h"
#include "if.h"
#include "table.h"
Ospf_ase.c (ospfd):62
  rn = route_node_lookup (rtrs, (struct prefix *) asbr);
  if (! rn)
    return NULL;
Ospf_ase.c (ospfd):116
  rn = route_node_lookup (rtrs, (struct prefix *) asbr);
 
  if (rn)
Ospf_ase.c (ospfd):173
  asbr.prefix = al->header.adv_router;
  asbr.prefixlen = IPV4_MAX_BITLEN;
  apply_mask_ipv4 (&asbr);
Ospf_ase.c (ospfd):183
		    inet_ntoa (asbr.prefix));
      return NULL;
    }
Ospf_ase.c (ospfd):214
      asbr.prefix = al->e[0].fwd_addr;
      asbr.prefixlen = IPV4_MAX_BITLEN;

      rn = route_node_match (rt_network, (struct prefix *) &asbr);
   
      if (rn == NULL)
Ospf_ase.c (ospfd):349
  asbr.prefix = al->header.adv_router;
  asbr.prefixlen = IPV4_MAX_BITLEN;
  apply_mask_ipv4 (&asbr);
Ospf_ase.c (ospfd):404
      asbr.prefix = al->e[0].fwd_addr;
      asbr.prefixlen = IPV4_MAX_BITLEN;

      rn = route_node_match (ospf->new_table, (struct prefix *) &asbr);
      
      if (rn == NULL || (asbr_route = rn->info) == NULL)
Ospf_ase.c (ospfd):446
  /* Set prefix. */
  p.family = AF_INET;
  p.prefix = al->header.id;
  p.prefixlen = ip_masklen (al->mask);

Ospf_ase.c (ospfd):454
			      (struct prefix *) &p)))
    {
      route_unlock_node(rn);
Ospf_ase.c (ospfd):466
			       (struct prefix *) &p)))
      route_unlock_node(rn);

Ospf_ase.c (ospfd):473
		    inet_ntoa (p.prefix), p.prefixlen);

      ospf_route_add (ospf->new_external_route, &p, new, asbr_route);
Ospf_ase.c (ospfd):547
ospf_ase_route_match_same (struct route_table *rt, struct prefix *prefix,
			   struct ospf_route *newor)
{
Ospf_ase.c (ospfd):557
  if (! rt || ! prefix)
    return 0;

   rn = route_node_lookup (rt, prefix);
   if (! rn)
     return 0;
Ospf_ase.c (ospfd):723
  p.prefix = lsa->data->id;
  p.prefixlen = ip_masklen (al->mask);
  apply_mask_ipv4 (&p);
Ospf_ase.c (ospfd):727
  rn = route_node_get (top->external_lsas, (struct prefix *) &p);
  if ((lst = rn->info) == NULL)
    rn->info = lst = list_new();
Ospf_ase.c (ospfd):748
  p.prefix = lsa->data->id;
  p.prefixlen = ip_masklen (al->mask);
  apply_mask_ipv4 (&p);
Ospf_ase.c (ospfd):752
  rn = route_node_lookup (top->external_lsas, (struct prefix *) &p);

  if (rn) {
Ospf_ase.c (ospfd):793
  p.prefix = lsa->data->id;
  p.prefixlen = ip_masklen (al->mask);
  apply_mask_ipv4 (&p);
Ospf_ase.c (ospfd):806
  rn = route_node_lookup (ospf->new_table, (struct prefix *) &p);
  if (rn)
    {
Ospf_ase.c (ospfd):814
  rn = route_node_lookup (ospf->external_lsas, (struct prefix *) &p);
  assert (rn); 
  assert (rn->info);
Ospf_ase.c (ospfd):825
  rn = route_node_lookup (ospf->old_external_route, (struct prefix *) &p);
  if (rn && rn->info)
    {
      rn2 = route_node_get (tmp_old, (struct prefix *) &p);
      rn2->info = rn->info;
      route_unlock_node (rn);
Ospf_ase.c (ospfd):840
  rn2 = route_node_lookup (ospf->new_external_route, (struct prefix *) &p);
  /* if new route exists, install it to ospf->old_external_route */
  if (rn2 && rn2->info)
Ospf_ase.c (ospfd):845
	rn = route_node_get (ospf->old_external_route, (struct prefix *) &p);
      rn->info = rn2->info;
    }
Ospf_dump.c (ospfd):27
#include "prefix.h"
#include "command.h"
#include "stream.h"
Ospf_flood.c (ospfd):26
#include "prefix.h"
#include "if.h"
#include "command.h"
Ospf_flood.c (ospfd):90
  p.prefix = lsa->data->id;
  p.prefixlen = ip_masklen (al->mask);

Ospf_flood.c (ospfd):100
				    (struct prefix *) &p);
	    if (rn)
	      {
Ospf_ia.c (ospfd):30
#include "prefix.h"
#include "table.h"
#include "log.h"
Ospf_ia.c (ospfd):58
  if ((rn = route_node_lookup (rtrs, (struct prefix *) abr)) == NULL)
    return NULL;

Ospf_ia.c (ospfd):81
	       inet_ntoa (p->prefix), p->prefixlen);

  /* Find a route to the same dest */
  if ((rn1 = route_node_lookup (rt, (struct prefix *) p)))
    {
      int res;
Ospf_ia.c (ospfd):123
		   inet_ntoa (p->prefix), p->prefixlen);
      ospf_route_add (rt, p, new_or, abr_or);
    }
Ospf_ia.c (ospfd):139
	       inet_ntoa (p->prefix), p->prefixlen);
  /* Find a route to the same dest */
  rn = route_node_get (rtrs, (struct prefix *) p);
   
  if (rn->info == NULL)
Ospf_ia.c (ospfd):228
  p.prefix = sl->header.id;
   
  if (sl->header.type == OSPF_SUMMARY_LSA)
Ospf_ia.c (ospfd):249
      p.prefix.s_addr == OSPF_DEFAULT_DESTINATION &&
      p.prefixlen == 0)
    return 0; /* Ignore summary default from a stub area */
Ospf_ia.c (ospfd):254
  abr.prefix = sl->header.adv_router;
  abr.prefixlen = IPV4_MAX_BITLEN;
  apply_mask_ipv4 (&abr);
Ospf_ia.c (ospfd):320
  abr.prefix =lsa->header.adv_router;
  abr.prefixlen = IPV4_MAX_BITLEN;
  apply_mask_ipv4 (&abr);
Ospf_ia.c (ospfd):335
  rn = route_node_lookup (rt, (struct prefix *) p);

  if (! rn)
Ospf_ia.c (ospfd):447
  abr.prefix = lsa->header.adv_router;
  abr.prefixlen = IPV4_MAX_BITLEN;
  apply_mask_ipv4 (&abr);
Ospf_ia.c (ospfd):573
  p.prefix = sl->header.id;
   
  if (sl->header.type == OSPF_SUMMARY_LSA)
Ospf_interface.c (ospfd):27
#include "prefix.h"
#include "if.h"
#include "table.h"
Ospf_interface.c (ospfd):170
/* lookup oi for specified prefix/ifp */
struct ospf_interface *
ospf_if_table_lookup (struct interface *ifp, struct prefix *prefix)
{
  struct prefix p;
  struct route_node *rn;
  struct ospf_interface *rninfo = NULL;
Ospf_interface.c (ospfd):178
  p = *prefix;
  p.prefixlen = IPV4_MAX_PREFIXLEN;
  
Ospf_interface.c (ospfd):195
  struct prefix p;

  p = *oi->address;
Ospf_interface.c (ospfd):212
  struct prefix p;

  p = *oi->address;
Ospf_interface.c (ospfd):226
ospf_if_new (struct ospf *ospf, struct interface *ifp, struct prefix *p)
{
  struct ospf_interface *oi;
Ospf_interface.c (ospfd):367
  addr.prefix = *address;
  addr.prefixlen = IPV4_MAX_PREFIXLEN;

Ospf_interface.c (ospfd):377
			     (struct prefix *)&addr))
	      return oi;
	  }
Ospf_interface.c (ospfd):458
	  struct prefix ptmp;

	  prefix_copy (&ptmp, CONNECTED_PREFIX(oi->connected));
Ospf_interface.c (ospfd):462
	  if (prefix_same (&ptmp, (struct prefix *) p))
	    return oi;
	}
Ospf_interface.c (ospfd):479
  addr.prefix = src;
  addr.prefixlen = IPV4_MAX_BITLEN;

Ospf_interface.c (ospfd):498
      			(struct prefix *) &addr))
	{
	  if ( (match == NULL) || 
Ospf_interface.c (ospfd):585
  p.prefix = addr;
  rn = route_node_lookup (IF_OIFS_PARAMS (ifp), (struct prefix*)&p);
  if (!rn || !rn->info)
    return;
Ospf_interface.c (ospfd):621
  p.prefix = addr;

  rn = route_node_lookup (IF_OIFS_PARAMS (ifp), (struct prefix*)&p);
  
  if (rn)
Ospf_interface.c (ospfd):642
  p.prefix = addr;

  rn = route_node_get (IF_OIFS_PARAMS (ifp), (struct prefix*)&p);
  
  if (rn->info == NULL)
Ospf_interface.c (ospfd):901
  p->prefix.s_addr = 0;
  p->prefixlen = 0;
 
  co->address = (struct prefix *)p;
  
  voi = ospf_if_new (ospf, vi, co->address);
Ospf_interface.h (ospfd):174
  struct prefix *address;		/* Interface prefix */
  struct connected *connected;          /* Pointer to connected */ 

Ospf_interface.h (ospfd):241
					   struct prefix *);
extern void ospf_if_cleanup (struct ospf_interface *);
extern void ospf_if_free (struct ospf_interface *);
Ospf_interface.h (ospfd):258
						    struct prefix *);
extern struct ospf_interface *ospf_if_addr_local (struct in_addr);
extern struct ospf_interface *ospf_if_lookup_recv_if (struct ospf *,
Ospf_ism.c (ospfd):28
#include "prefix.h"
#include "if.h"
#include "table.h"
Ospf_lsa.c (ospfd):26
#include "prefix.h"
#include "if.h"
#include "table.h"
Ospf_lsa.c (ospfd):1215
ospf_summary_lsa_body_set (struct stream *s, struct prefix *p,
			   u_int32_t metric)
{
Ospf_lsa.c (ospfd):1233
ospf_summary_lsa_new (struct ospf_area *area, struct prefix *p,
		      u_int32_t metric, struct in_addr id)
{
Ospf_lsa.c (ospfd):1300
  if ( !(new = ospf_summary_lsa_new (area, (struct prefix *) p, metric, id)))
    return NULL;

Ospf_lsa.c (ospfd):1327
  struct prefix p;
  
  /* Sanity check. */
Ospf_lsa.c (ospfd):1361
ospf_summary_asbr_lsa_body_set (struct stream *s, struct prefix *p,
				u_int32_t metric)
{
Ospf_lsa.c (ospfd):1375
ospf_summary_asbr_lsa_new (struct ospf_area *area, struct prefix *p,
			   u_int32_t metric, struct in_addr id)
{
Ospf_lsa.c (ospfd):1442
  new = ospf_summary_asbr_lsa_new (area, (struct prefix *) p, metric, id);
  if (!new)
    return NULL;
Ospf_lsa.c (ospfd):1470
  struct prefix p;

  /* Sanity check. */
Ospf_lsa.c (ospfd):1507
  struct prefix nh;
  struct listnode *node;
  struct ospf_interface *oi;
Ospf_lsa.c (ospfd):1632
  /* If prefix is default, specify DEFAULT_ROUTE. */
  type = is_prefix_default (&ei->p) ? DEFAULT_ROUTE : ei->type;
  
Ospf_lsa.c (ospfd):1821
  ei.p.prefix = type7->data->id;
  ei.p.prefixlen = ip_masklen (ext->mask);
  ei.type = ZEBRA_ROUTE_OSPF;
Ospf_lsa.c (ospfd):1834
                 inet_ntoa (ei.p.prefix));
    return NULL;
  }
Ospf_lsa.c (ospfd):1923
          .prefix = type7->data->id,
          .prefixlen = ip_masklen (ext->mask),
          .family = AF_INET,
Ospf_lsa.c (ospfd):2011
  q.prefix.s_addr = 0;
  q.prefixlen = 0;

  return prefix_same ((struct prefix *) p, (struct prefix *) &q);
}

Ospf_lsa.c (ospfd):2067
		   inet_ntoa (ei->p.prefix));
      return NULL;
    }
Ospf_lsa.c (ospfd):2128
  p.prefix.s_addr = 0;
  p.prefixlen = 0;

Ospf_lsa.c (ospfd):2135
	rn = route_node_lookup (EXTERNAL_INFO (type), (struct prefix *) &p);
	if (rn != NULL)
	  {
Ospf_lsa.c (ospfd):2159
  p.prefix.s_addr = 0;
  p.prefixlen = 0;

Ospf_lsa.c (ospfd):2176
/* Flush any NSSA LSAs for given prefix */
void
ospf_nssa_lsa_flush (struct ospf *ospf, struct prefix_ipv4 *p)
Ospf_lsa.c (ospfd):2188
      if (!(lsa = ospf_lsa_lookup (area, OSPF_AS_NSSA_LSA, p->prefix,
                                ospf->router_id))) 
      {
Ospf_lsa.c (ospfd):2193
                    inet_ntoa (p->prefix), p->prefixlen);
        continue;
      }
Ospf_lsa.c (ospfd):2216
	       inet_ntoa (p->prefix), p->prefixlen);

  /* First lookup LSA from LSDB. */
Ospf_lsa.c (ospfd):2223
		   inet_ntoa (p->prefix), p->prefixlen);
      return;
    }
Ospf_lsa.c (ospfd):2265
  p.prefix.s_addr = 0;

  ei = ospf_default_external_info (ospf);
Ospf_lsa.c (ospfd):2921
  lsa_prefix.prefixlen = sizeof(lsa_prefix.prefix) * CHAR_BIT;
  lsa_prefix.prefix = (uintptr_t) lsa;

  if ((rn = route_node_lookup(ospf->maxage_lsa,
			      (struct prefix *)&lsa_prefix)))
    {
      if (rn->info == lsa)
Ospf_lsa.c (ospfd):2960
  lsa_prefix.prefixlen = sizeof(lsa_prefix.prefix) * CHAR_BIT;
  lsa_prefix.prefix = (uintptr_t) lsa;

  if ((rn = route_node_get (ospf->maxage_lsa,
			    (struct prefix *)&lsa_prefix)) != NULL)
    {
      if (rn->info != NULL)
Ospf_lsa.c (ospfd):3096
  lsa = ospf_lsdb_lookup_by_id (lsdb, type, p->prefix, router_id);
  if (lsa == NULL)
    return NULL;
Ospf_lsa.c (ospfd):3106
      id.s_addr = p->prefix.s_addr | (~mask.s_addr);
      lsa = ospf_lsdb_lookup_by_id (lsdb, type, id, router_id);
      if (!lsa)
Ospf_lsa.c (ospfd):3485
  id = p->prefix;

  /* Check existence of LSA instance. */
Ospf_lsa.c (ospfd):3497
		       inet_ntoa (p->prefix), p->prefixlen);
	  /*	  id.s_addr = 0; */
	  id.s_addr = 0xffffffff;
Ospf_lsa.c (ospfd):3507
	  id.s_addr = p->prefix.s_addr | (~mask.s_addr);
	  lsa = ospf_lsdb_lookup_by_id (ospf->lsdb, type,
				       id, ospf->router_id);
Ospf_lsa.c (ospfd):3515
			   inet_ntoa (p->prefix), p->prefixlen);
	      /* 	      id.s_addr = 0; */
	      id.s_addr = 0xffffffff;
Ospf_lsdb.c (ospfd):25
#include "prefix.h"
#include "table.h"
#include "memory.h"
Ospf_lsdb.c (ospfd):122
  rn = route_node_get (table, (struct prefix *)&lp);
  
  /* nothing to do? */
Ospf_lsdb.c (ospfd):174
  if ((rn = route_node_lookup (table, (struct prefix *) &lp)))
    {
      if (rn->info == lsa)
Ospf_lsdb.c (ospfd):225
  rn = route_node_lookup (table, (struct prefix *) &lp);
  if (rn)
    {
Ospf_lsdb.c (ospfd):252
  rn = route_node_lookup (table, (struct prefix *) &lp);
  if (rn)
    {
Ospf_lsdb.c (ospfd):284
      if ((rn = route_node_lookup (table, (struct prefix *) &lp)) == NULL)
        return NULL;
      rn = route_next (rn);
Ospf_main.c (ospfd):28
#include "prefix.h"
#include "linklist.h"
#include "if.h"
Ospf_neighbor.c (ospfd):26
#include "prefix.h"
#include "memory.h"
#include "command.h"
Ospf_neighbor.c (ospfd):53
              struct prefix *key)
{
  key->family = AF_INET;
Ospf_neighbor.c (ospfd):154
  struct prefix p;

  oi = nbr->oi;
Ospf_neighbor.c (ospfd):158
  /* get appropriate prefix 'key' */
  ospf_nbr_key (oi, nbr, &p);

Ospf_neighbor.c (ospfd):250
  struct prefix p;
  struct route_node *rn;

Ospf_neighbor.c (ospfd):331
  struct prefix p;
  struct route_node *rn;
  struct ospf_neighbor *nbr;
Ospf_neighbor.c (ospfd):426
              struct prefix *p)
{
  struct ospf_neighbor *nbr;
Ospf_neighbor.c (ospfd):433
  memcpy (&nbr->address, p, sizeof (struct prefix));

  nbr->nbr_nbma = NULL;
Ospf_neighbor.c (ospfd):469
              struct ip *iph, struct prefix *p)
{
  struct route_node *rn;
  struct prefix key;
  struct ospf_neighbor *nbr;
  
Ospf_neighbor.c (ospfd):493
          memcpy (&nbr->address, p, sizeof (struct prefix));
        }
    }
Ospf_neighbor.h (ospfd):40
  struct prefix address;		/* Neighbor Interface Address. */

  struct in_addr src;			/* Src address. */
Ospf_neighbor.h (ospfd):108
					   struct ip *, struct prefix *);
extern struct ospf_neighbor *ospf_nbr_lookup (struct ospf_interface *,
					      struct ip *,
Ospf_network.c (ospfd):27
#include "prefix.h"
#include "if.h"
#include "sockunion.h"
Ospf_network.c (ospfd):50
ospf_if_add_allspfrouters (struct ospf *top, struct prefix *p,
			   ifindex_t ifindex)
{
Ospf_network.c (ospfd):71
ospf_if_drop_allspfrouters (struct ospf *top, struct prefix *p,
			    ifindex_t ifindex)
{
Ospf_network.c (ospfd):92
ospf_if_add_alldrouters (struct ospf *top, struct prefix *p, ifindex_t ifindex)
{
  int ret;
Ospf_network.c (ospfd):112
ospf_if_drop_alldrouters (struct ospf *top, struct prefix *p, ifindex_t ifindex)
{
  int ret;
Ospf_network.c (ospfd):131
ospf_if_ipmulticast (struct ospf *top, struct prefix *p, ifindex_t ifindex)
{
  u_char val;
Ospf_network.h (ospfd):27
extern int ospf_if_add_allspfrouters (struct ospf *, struct prefix *,
				      ifindex_t);
extern int ospf_if_drop_allspfrouters (struct ospf *, struct prefix *,
				       ifindex_t);
extern int ospf_if_add_alldrouters (struct ospf *, struct prefix *,
				    ifindex_t);
extern int ospf_if_drop_alldrouters (struct ospf *, struct prefix *,
				     ifindex_t);
extern int ospf_if_ipmulticast (struct ospf *, struct prefix *, ifindex_t);
extern int ospf_sock_init (void);
extern void ospf_adjust_sndbuflen (struct ospf *, unsigned int);
Ospf_nsm.c (ospfd):30
#include "prefix.h"
#include "if.h"
#include "table.h"
Ospf_opaque.c (ospfd):32
#include "prefix.h"
#include "if.h"
#include "table.h"
Ospf_packet.c (ospfd):28
#include "prefix.h"
#include "if.h"
#include "table.h"
Ospf_packet.c (ospfd):817
  struct prefix p;

  /* increment statistics. */
Ospf_packet.c (ospfd):837
  /* get neighbor prefix. */
  p.family = AF_INET;
  p.prefixlen = ip_masklen (hello->network_mask);
Ospf_packet.c (ospfd):848
	zlog_warn ("Packet %s [Hello:RECV]: NetworkMask mismatch on %s (configured prefix length is %d, but hello packet indicates %d).",
		   inet_ntoa(ospfh->router_id), IF_NAME(oi),
		   (int)oi->address->prefixlen, (int)p.prefixlen);
Ospf_packet.c (ospfd):3778
    p.prefix = oi->vl_data->peer_addr;
  else if (oi->type == OSPF_IFTYPE_POINTOPOINT) 
     p.prefix.s_addr = htonl (OSPF_ALLSPFROUTERS);
  else if (flag == OSPF_SEND_PACKET_DIRECT)
     p.prefix = nbr->address.u.prefix4;
  else if (oi->state == ISM_DR || oi->state == ISM_Backup)
     p.prefix.s_addr = htonl (OSPF_ALLSPFROUTERS);
  else if (oi->type == OSPF_IFTYPE_POINTOMULTIPOINT)
     p.prefix.s_addr = htonl (OSPF_ALLSPFROUTERS);
  else
     p.prefix.s_addr = htonl (OSPF_ALLDROUTERS);

  if (oi->type == OSPF_IFTYPE_NBMA)
Ospf_packet.c (ospfd):3794
      if (IPV4_ADDR_SAME(&oi->address->u.prefix4, &p.prefix.s_addr))
	zlog_warn ("* LS-Update is sent to myself.");
    }
Ospf_packet.c (ospfd):3798
  rn = route_node_get (oi->ls_upd_queue, (struct prefix *) &p);

  if (rn->info == NULL)
Ospf_ri.c (ospfd):32
#include "prefix.h"
#include "if.h"
#include "table.h"
Ospf_route.c (ospfd):25
#include "prefix.h"
#include "table.h"
#include "memory.h"
Ospf_route.c (ospfd):129
/* If a prefix exists in the new routing table, then return 1,
   otherwise return 0. Since the ZEBRA-RIB does an implicit
   withdraw, it is not necessary to send a delete, an add later
Ospf_route.c (ospfd):134
ospf_route_exist_new_table (struct route_table *rt, struct prefix_ipv4 *prefix)
{
  struct route_node *rn;
Ospf_route.c (ospfd):139
  assert (prefix);

  rn = route_node_lookup (rt, (struct prefix *) prefix);
  if (!rn) {
    return 0;
Ospf_route.c (ospfd):154
/* If a prefix and a nexthop match any route in the routing table,
   then return 1, otherwise return 0. */
int
ospf_route_match_same (struct route_table *rt, struct prefix_ipv4 *prefix,
		       struct ospf_route *newor)
{
Ospf_route.c (ospfd):167
  if (! rt || ! prefix)
    return 0;

   rn = route_node_lookup (rt, (struct prefix *) prefix);
   if (! rn || ! rn->info)
     return 0;
Ospf_route.c (ospfd):198
       else if (prefix_same (&rn->p, (struct prefix *) prefix))
	 return 1;
     }
Ospf_route.c (ospfd):223
          if ( (ext_rn = route_node_lookup (external_routes, (struct prefix *)p)) )
            {
              if (ext_rn->info)
Ospf_route.c (ospfd):369
  p.prefix = v->id;
  p.prefixlen = IPV4_MAX_BITLEN;

Ospf_route.c (ospfd):374
	       inet_ntoa (p.prefix), p.prefixlen);

  rn = route_node_get (rt, (struct prefix *) &p);

  /* Note that we keep all routes to ABRs and ASBRs, not only the best */
Ospf_route.c (ospfd):410
  p.prefix = v->id;
  p.prefixlen = ip_masklen (lsa->mask);
  apply_mask_ipv4 (&p);
Ospf_route.c (ospfd):414
  rn = route_node_get (rt, (struct prefix *) &p);

  /* If the routing table entry already exists (i.e., there is already
Ospf_route.c (ospfd):473
  p.prefix = link->link_id;
  p.prefixlen = ip_masklen (link->link_data);
  apply_mask_ipv4 (&p);
Ospf_route.c (ospfd):479
	       inet_ntoa (p.prefix), p.prefixlen);

  /* (1) Calculate the distance D of stub network from the root.  D is
Ospf_route.c (ospfd):504
  rn = route_node_get (rt, (struct prefix *) &p);

  /* Lookup current routing table. */
Ospf_route.c (ospfd):517
		   "another route to the same prefix found with cost %u",
		   cur_or->cost);

Ospf_route.c (ospfd):851
  rn = route_node_get (rt, (struct prefix *) p);

  ospf_route_copy_nexthops (new_or, over->paths);
Ospf_route.c (ospfd):948
  rn = route_node_get (rt, (struct prefix *) p);

  if (rn == NULL)
Ospf_route.c (ospfd):984
		"adding %s/%d", inet_ntoa (p->prefix), p->prefixlen);

  new_or = ospf_route_new ();
Ospf_route.c (ospfd):1008
		"deleting %s/%d", inet_ntoa (p->prefix), p->prefixlen);

  rn = route_node_lookup (rt, (struct prefix*)p);

  if (rn == NULL)
Ospf_routemap.c (ospfd):28
#include "prefix.h"
#include "table.h"
#include "routemap.h"
Ospf_routemap.c (ospfd):195
route_match_ip_nexthop (void *rule, struct prefix *prefix,
			route_map_object_t type, void *object)
{
Ospf_routemap.c (ospfd):205
      p.prefix = ei->nexthop;
      p.prefixlen = IPV4_MAX_BITLEN;

Ospf_routemap.c (ospfd):242
/* `match ip next-hop prefix-list PREFIX_LIST' */

static route_map_result_t
route_match_ip_next_hop_prefix_list (void *rule, struct prefix *prefix,
                                    route_map_object_t type, void *object)
{
Ospf_routemap.c (ospfd):255
      p.prefix = ei->nexthop;
      p.prefixlen = IPV4_MAX_BITLEN;

Ospf_routemap.c (ospfd):282
  "ip next-hop prefix-list",
  route_match_ip_next_hop_prefix_list,
  route_match_ip_next_hop_prefix_list_compile,
Ospf_routemap.c (ospfd):292
route_match_ip_address (void *rule, struct prefix *prefix,
                        route_map_object_t type, void *object)
{
Ospf_routemap.c (ospfd):304
      return (access_list_apply (alist, prefix) == FILTER_DENY ?
              RMAP_NOMATCH : RMAP_MATCH);
    }
Ospf_routemap.c (ospfd):334
/* `match ip address prefix-list PREFIX_LIST' */
static route_map_result_t
route_match_ip_address_prefix_list (void *rule, struct prefix *prefix,
                                    route_map_object_t type, void *object)
{
Ospf_routemap.c (ospfd):347
      return (prefix_list_apply (plist, prefix) == PREFIX_DENY ?
              RMAP_NOMATCH : RMAP_MATCH);
    }
Ospf_routemap.c (ospfd):367
  "ip address prefix-list",
  route_match_ip_address_prefix_list,
  route_match_ip_address_prefix_list_compile,
Ospf_routemap.c (ospfd):377
route_match_interface (void *rule, struct prefix *prefix,
		       route_map_object_t type, void *object)
{
Ospf_routemap.c (ospfd):422
route_match_tag (void *rule, struct prefix *prefix,
                 route_map_object_t type, void *object)
{
Ospf_routemap.c (ospfd):452
route_set_metric (void *rule, struct prefix *prefix,
                  route_map_object_t type, void *object)
{
Ospf_routemap.c (ospfd):524
route_set_metric_type (void *rule, struct prefix *prefix,
		       route_map_object_t type, void *object)
{
Ospf_routemap.c (ospfd):579
route_set_tag (void *rule, struct prefix *prefix,
               route_map_object_t type, void *object)
{
Ospf_routemap.c (ospfd):646
       "match ip next-hop prefix-list WORD",
       MATCH_STR
       IP_STR
Ospf_routemap.c (ospfd):650
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")
{
  return ospf_route_match_add (vty, vty->index, "ip next-hop prefix-list",
			       argv[0]);
}
Ospf_routemap.c (ospfd):659
       "no match ip next-hop prefix-list",
       NO_STR
       MATCH_STR
Ospf_routemap.c (ospfd):664
       "Match entries of prefix-lists\n")
{
  if (argc == 0)
    return ospf_route_match_delete (vty, vty->index, "ip next-hop prefix-list",
				    NULL);
  return ospf_route_match_delete (vty, vty->index, "ip next-hop prefix-list",
				  argv[0]);
}
Ospf_routemap.c (ospfd):675
       "no match ip next-hop prefix-list WORD",
       NO_STR
       MATCH_STR
Ospf_routemap.c (ospfd):680
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")

DEFUN (match_ip_address,
Ospf_routemap.c (ospfd):723
       "match ip address prefix-list WORD",
       MATCH_STR
       IP_STR
Ospf_routemap.c (ospfd):727
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")
{
  return ospf_route_match_add (vty, vty->index, "ip address prefix-list",
			       argv[0]);
}
Ospf_routemap.c (ospfd):736
       "no match ip address prefix-list",
       NO_STR
       MATCH_STR
Ospf_routemap.c (ospfd):741
       "Match entries of prefix-lists\n")
{
  if (argc == 0)
    return ospf_route_match_delete (vty, vty->index, "ip address prefix-list",
				    NULL);
  return ospf_route_match_delete (vty, vty->index, "ip address prefix-list",
				  argv[0]);
}
Ospf_routemap.c (ospfd):752
       "no match ip address prefix-list WORD",
       NO_STR
       MATCH_STR
Ospf_routemap.c (ospfd):757
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")

DEFUN (match_interface,
Ospf_snmp.c (ospfd):33
#include "prefix.h"
#include "table.h"
#include "command.h"
Ospf_snmp.c (ospfd):1185
      p.prefix = *range_net;

      return ospf_area_range_lookup (area, &p);
Ospf_snmp.c (ospfd):1455
  struct prefix *p;
  struct ospf_snmp_if *osif;
  struct in_addr *addr;
Ospf_snmp.c (ospfd):1929
  rn = route_node_get (ospf_snmp_vl_table, (struct prefix *) &lp);
  if (rn->info)
    route_unlock_node (rn);
Ospf_snmp.c (ospfd):1948
  rn = route_node_lookup (ospf_snmp_vl_table, (struct prefix *) &lp);
  if (! rn)
    return;
Ospf_snmp.c (ospfd):1969
  rn = route_node_lookup (ospf_snmp_vl_table, (struct prefix *) &lp);
  if (rn)
    {
Ospf_snmp.c (ospfd):1997
      rn = route_node_get (ospf_snmp_vl_table, (struct prefix *) &lp);
      rn = route_next (rn);
    }
Ospf_spf.c (ospfd):27
#include "prefix.h"
#include "if.h"
#include "table.h"
Ospf_spf.c (ospfd):642
		      la.prefix = l2->link_data;

		      if (prefix_cmp ((struct prefix *) &la,
				      oi->address) != 0)
			continue;
Ospf_te.c (ospfd):34
#include "prefix.h"
#include "if.h"
#include "table.h"
Ospf_te.c (ospfd):856
      struct prefix *pref = CONNECTED_PREFIX(oi->connected);
      if (pref != NULL)
        set_linkparams_rmtif_ipaddr(lp, pref->u.prefix4);
Ospf_te.c (ospfd):1078
          struct prefix *pref = CONNECTED_PREFIX(oi->connected);
          if (pref != NULL)
            set_linkparams_rmtif_ipaddr(lp, pref->u.prefix4);
Ospf_vty.c (ospfd):27
#include "prefix.h"
#include "table.h"
#include "vty.h"
Ospf_vty.c (ospfd):486
       "OSPF network prefix\n"
       "Set the OSPF area ID\n"
       "OSPF area ID in IP address format\n"
Ospf_vty.c (ospfd):496
  /* Get network prefix and Area ID. */
  VTY_GET_IPV4_PREFIX ("network prefix", p, argv[0]);
  VTY_GET_OSPF_AREA_ID (area_id, format, argv[1]);

Ospf_vty.c (ospfd):515
       "OSPF network prefix\n"
       "Set the OSPF area ID\n"
       "OSPF area ID in IP address format\n"
Ospf_vty.c (ospfd):525
  /* Get network prefix and Area ID. */
  VTY_GET_IPV4_PREFIX ("network prefix", p, argv[0]);
  VTY_GET_OSPF_AREA_ID (area_id, format, argv[1]);

Ospf_vty.c (ospfd):548
       "Area range prefix\n")
{
  struct ospf *ospf = vty->index;
Ospf_vty.c (ospfd):576
       "Area range prefix\n"
       "Advertise this range (default)\n")

Ospf_vty.c (ospfd):586
       "Area range prefix\n"
       "User specified metric for this range\n"
       "Advertised metric for this range\n")
Ospf_vty.c (ospfd):597
       "Area range prefix\n"
       "Advertise this range (default)\n"
       "User specified metric for this range\n"
Ospf_vty.c (ospfd):609
       "Area range prefix\n"
       "DoNotAdvertise this range\n")
{
Ospf_vty.c (ospfd):633
       "Area range prefix\n")
{
  struct ospf *ospf = vty->index;
Ospf_vty.c (ospfd):656
       "Area range prefix\n"
       "Advertise this range (default)\n"
       "DoNotAdvertise this range\n")
Ospf_vty.c (ospfd):668
       "Area range prefix\n"
       "User specified metric for this range\n"
       "Advertised metric for this range\n")
Ospf_vty.c (ospfd):680
       "Area range prefix\n"
       "Advertise this range (default)\n"
       "User specified metric for this range\n"
Ospf_vty.c (ospfd):692
       "Area range prefix\n"
       "Announce area range as another prefix\n"
       "Network prefix to be announced instead of range\n")
{
  struct ospf *ospf = vty->index;
Ospf_vty.c (ospfd):703
  VTY_GET_IPV4_PREFIX ("substituted network prefix", s, argv[2]);

  ospf_area_range_substitute_set (ospf, area_id, &p, &s);
Ospf_vty.c (ospfd):718
       "Area range prefix\n"
       "Announce area range as another prefix\n"
       "Network prefix to be announced instead of range\n")
{
  struct ospf *ospf = vty->index;
Ospf_vty.c (ospfd):729
  VTY_GET_IPV4_PREFIX ("substituted network prefix", s, argv[2]);

  ospf_area_range_substitute_unset (ospf, area_id, &p);
Ospf_vty.c (ospfd):1768
  p.prefix.s_addr = OSPF_DEFAULT_DESTINATION;
  p.prefixlen = 0;
  if (IS_DEBUG_OSPF_EVENT)
Ospf_vty.c (ospfd):1811
  p.prefix.s_addr = OSPF_DEFAULT_DESTINATION;
  p.prefixlen = 0;
  if (IS_DEBUG_OSPF_EVENT)
Ospf_vty.c (ospfd):1924
       "area (A.B.C.D|<0-4294967295>) filter-list prefix WORD (in|out)",
       "OSPF area parameters\n"
       "OSPF area ID in IP address format\n"
Ospf_vty.c (ospfd):1930
       "Name of an IP prefix-list\n"
       "Filter networks sent to this area\n"
       "Filter networks sent from this area\n")
Ospf_vty.c (ospfd):1968
       "no area (A.B.C.D|<0-4294967295>) filter-list prefix WORD (in|out)",
       NO_STR
       "OSPF area parameters\n"
Ospf_vty.c (ospfd):1975
       "Name of an IP prefix-list\n"
       "Filter networks sent to this area\n"
       "Filter networks sent from this area\n")
Ospf_vty.c (ospfd):3581
	    p.prefix = sl->header.id;
	    p.prefixlen = ip_masklen (sl->mask);
	    apply_mask_ipv4 (&p);
Ospf_vty.c (ospfd):3585
	    vty_out (vty, " %s/%d", inet_ntoa (p.prefix), p.prefixlen);
	    break;
	  case OSPF_AS_EXTERNAL_LSA:
Ospf_vty.c (ospfd):3592
	    p.prefix = asel->header.id;
	    p.prefixlen = ip_masklen (asel->mask);
	    apply_mask_ipv4 (&p);
Ospf_vty.c (ospfd):3598
		     inet_ntoa (p.prefix), p.prefixlen,
		     (u_long)ntohl (asel->e[0].route_tag));
	    break;
Ospf_vty.c (ospfd):3975
  start = route_node_get (rt, (struct prefix *) &lp);
  if (start)
    {
Ospf_vty.c (ospfd):6097
  p.prefix.s_addr = 0;
  p.prefixlen = 0;

Ospf_vty.c (ospfd):6254
       "IP source prefix\n")
{
  struct ospf *ospf = vty->index;
Ospf_vty.c (ospfd):6269
       "IP source prefix\n")
{
  struct ospf *ospf = vty->index;
Ospf_vty.c (ospfd):6283
       "IP source prefix\n"
       "Access list name\n")
{
Ospf_vty.c (ospfd):6299
       "IP source prefix\n"
       "Access list name\n")
{
Ospf_vty.c (ospfd):7167
	vty_out (vty, " area %s filter-list prefix %s in%s", buf,
		 PREFIX_NAME_IN (area), VTY_NEWLINE);

Ospf_vty.c (ospfd):7171
	vty_out (vty, " area %s filter-list prefix %s out%s", buf,
		 PREFIX_NAME_OUT (area), VTY_NEWLINE);
    }
Ospf_zebra.c (ospfd):28
#include "prefix.h"
#include "routemap.h"
#include "table.h"
Ospf_zebra.c (ospfd):66
  struct prefix router_id;
  zebra_router_id_update_read(zclient->ibuf,&router_id);

Ospf_zebra.c (ospfd):289
  struct prefix p;

  c = zebra_interface_address_read (command, zclient->ibuf, vrf_id);
Ospf_zebra.c (ospfd):390
      /* Put prefix information. */
      psize = PSIZE (p->prefixlen);
      stream_putc (s, p->prefixlen);
      stream_write (s, (u_char *) & p->prefix, psize);

      /* Nexthop count. */
Ospf_zebra.c (ospfd):426
			 inet_ntop(AF_INET, &p->prefix,
				   buf[0], sizeof(buf[0])),
			 p->prefixlen,
Ospf_zebra.c (ospfd):483
      /* Put prefix information. */
      psize = PSIZE (p->prefixlen);
      stream_putc (s, p->prefixlen);
      stream_write (s, (u_char *) & p->prefix, psize);

      /* Nexthop count. */
Ospf_zebra.c (ospfd):516
			 inet_ntop(AF_INET, &p->prefix,
				   buf[0], sizeof(buf[0])),
			 p->prefixlen,
Ospf_zebra.c (ospfd):563
                   inet_ntoa (p->prefix), p->prefixlen);
    }
}
Ospf_zebra.c (ospfd):588
                   inet_ntoa (p->prefix), p->prefixlen);

    }
Ospf_zebra.c (ospfd):736
  /* If prefix is multicast, then do not originate LSA. */
  if (IN_MULTICAST (htonl (ei->p.prefix.s_addr)))
    {
      zlog_info ("LSA[Type5:%s]: Not originate AS-external-LSA, "
                 "Prefix belongs multicast", inet_ntoa (ei->p.prefix));
      return 0;
    }
Ospf_zebra.c (ospfd):756
/* If connected prefix is OSPF enable interface, then do not announce. */
int
ospf_distribute_check_connected (struct ospf *ospf, struct external_info *ei)
Ospf_zebra.c (ospfd):765
      if (prefix_match (oi->address, (struct prefix *) &ei->p))
          return 0;
  return 1;
Ospf_zebra.c (ospfd):798
                       inet_ntoa (p->prefix), p->prefixlen);
          return 0;
        }
Ospf_zebra.c (ospfd):810
      ret = route_map_apply (ROUTEMAP (ospf, type), (struct prefix *) p,
                             RMAP_OSPF, ei);

Ospf_zebra.c (ospfd):819
                       inet_ntoa (p->prefix), p->prefixlen);
          return 0;
        }
Ospf_zebra.c (ospfd):876
  /* IPv4 prefix. */
  memset (&p, 0, sizeof (struct prefix_ipv4));
  p.family = AF_INET;
Ospf_zebra.c (ospfd):881
  stream_get (&p.prefix, s, PSIZE (p.prefixlen));

  if (IPV4_NET127(ntohl(p.prefix.s_addr)))
    return 0;

Ospf_zebra.c (ospfd):952
                               inet_ntoa (p.prefix));
                }
            }
Ospf_zebra.c (ospfd):1141
/* If prefix-list is updated, do some updates. */
void
ospf_prefix_list_update (struct prefix_list *plist)
Ospf_zebra.c (ospfd):1157
   * They might use prefix-list.
   */
  for (type = 0; type <= ZEBRA_ROUTE_MAX; type++)
Ospf_zebra.c (ospfd):1163
          /* If route-map is not NULL it may be using this prefix list */
          ospf_distribute_list_update (ospf, type);
          continue;
Ospf_zebra.c (ospfd):1223
      vty_out (vty, "Malformed prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Ospf_zebra.c (ospfd):1230
  rn = route_node_get (ospf->distance_table, (struct prefix *) &p);
  if (rn->info)
    {
Ospf_zebra.c (ospfd):1271
      vty_out (vty, "Malformed prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Ospf_zebra.c (ospfd):1275
  rn = route_node_lookup (ospf->distance_table, (struct prefix *) &p);
  if (!rn)
    {
      vty_out (vty, "Can't find specified prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Ospf_zebra.h (ospfd):37
  /* Distance value for the IP source prefix. */
  u_char distance;

Pim_assert.c (pimd):26
#include "prefix.h"

#include "pimd.h"
Pim_assert.c (pimd):245
  struct prefix            msg_group_addr;
  struct prefix            msg_source_addr;
  struct pim_assert_metric msg_metric;
  int offset;
Pim_cmd.c (pimd):29
#include "prefix.h"
#include "zclient.h"

Pim_cmd.c (pimd):536
      struct prefix *p = ifc->address;

      if (p->family != AF_INET)
Pim_cmd.c (pimd):946
      struct prefix *p;

      if (!neigh->prefix_list)
Pim_iface.c (pimd):28
#include "prefix.h"

#include "pimd.h"
Pim_iface.c (pimd):501
    struct prefix *p = ifc->address;
    
    if (p->family != AF_INET)
Pim_iface.c (pimd):521
    struct prefix *p = ifc->address;
    
    if (p->family != AF_INET)
Pim_iface.c (pimd):541
    struct prefix *p = ifc->address;
    
    if (p->family != AF_INET)
Pim_iface.c (pimd):561
    struct prefix *p = ifc->address;
    
    if (p->family != AF_INET)
Pim_iface.c (pimd):577
    struct prefix *p = ifc->address;
    
    if (p->family != AF_INET)
Pim_join.c (pimd):26
#include "prefix.h"

#include "pimd.h"
Pim_join.c (pimd):112
  struct prefix   msg_upstream_addr;
  uint8_t         msg_num_groups;
  uint16_t        msg_holdtime;
Pim_join.c (pimd):192
    struct prefix msg_group_addr;
    struct prefix msg_source_addr;
    uint8_t       msg_source_flags;
    uint16_t      msg_num_joined_sources;
Pim_main.c (pimd):39
#include "prefix.h"
#include "plist.h"

Pim_neighbor.c (pimd):26
#include "prefix.h"
#include "memory.h"

Pim_neighbor.c (pimd):359
    struct prefix *p;
    char addr_str[10];
    int list_size = neigh->prefix_list ? (int) listcount(neigh->prefix_list) : -1;
Pim_neighbor.c (pimd):365
      zlog_debug("%s: DUMP_PREFIX_LIST neigh=%x prefix_list=%x prefix=%x addr=%s [%d/%d]",
		 __PRETTY_FUNCTION__,
		 (unsigned) neigh, (unsigned) neigh->prefix_list, (unsigned) p,
Pim_neighbor.c (pimd):587
struct prefix *pim_neighbor_find_secondary(struct pim_neighbor *neigh,
					   struct in_addr addr)
{
Pim_neighbor.c (pimd):591
  struct prefix   *p;

  if (!neigh->prefix_list)
Pim_neighbor.c (pimd):623
  struct prefix        *addr;
  struct pim_interface *pim_ifp;

Pim_neighbor.c (pimd):648
	struct prefix *p = pim_neighbor_find_secondary(neigh, addr->u.prefix4);
	if (p) {
	  char addr_str[100];
Pim_neighbor.c (pimd):699
      zlog_err("%s: internal error: trying to replace same prefix list=%p",
	       __PRETTY_FUNCTION__, (void *) addr_list);
    }
Pim_neighbor.h (pimd):42
  struct list       *prefix_list; /* list of struct prefix */
  struct thread     *t_expire_timer;
  struct interface  *interface;
Pim_neighbor.h (pimd):70
struct prefix *pim_neighbor_find_secondary(struct pim_neighbor *neigh,
					   struct in_addr addr);
int pim_if_dr_election(struct interface *ifp);
Pim_rpf.c (pimd):26
#include "prefix.h"
#include "memory.h"

Pim_tlv.c (pimd):26
#include "prefix.h"

#include "pimd.h"
Pim_tlv.c (pimd):122
    struct prefix *p = ifc->address;
    
    if (p->family != AF_INET)
Pim_tlv.c (pimd):343
			 struct prefix *p,
			 const uint8_t *buf,
			 int buf_size)
Pim_tlv.c (pimd):411
			 struct prefix *p,
			 const uint8_t *buf,
			 int buf_size)
Pim_tlv.c (pimd):485
			  struct prefix *p,
			  uint8_t *flags,
			  const uint8_t *buf,
Pim_tlv.c (pimd):602
    struct prefix tmp;
    int addr_offset;

Pim_tlv.c (pimd):684
      struct prefix *p;
      p = prefix_new();
      if (!p) {
Pim_tlv.h (pimd):119
			 struct prefix *p,
			 const uint8_t *buf,
			 int buf_size);
Pim_tlv.h (pimd):123
			 struct prefix *p,
			 const uint8_t *buf,
			 int buf_size);
Pim_tlv.h (pimd):128
			  struct prefix *p,
			  uint8_t *flags,
			  const uint8_t *buf,
Pim_zebra.c (pimd):29
#include "prefix.h"
#include "zclient.h"
#include "stream.h"
Pim_zebra.c (pimd):58
  struct prefix router_id;

  zebra_router_id_update_read(zclient->ibuf, &router_id);
Pim_zebra.c (pimd):203
    struct prefix *p = ifc->address;
    
    if (p->family != AF_INET)
Pim_zebra.c (pimd):222
  struct prefix *p;

  /*
Pim_zebra.c (pimd):284
  struct prefix *p;

  /*
Pim_zebra.c (pimd):531
  /* IPv4 prefix length. */
  memset(&p, 0, sizeof(struct prefix_ipv4));
  p.family = AF_INET;
Pim_zebra.c (pimd):564
  /* IPv4 prefix. */
  stream_get(&p.prefix, s, PSIZE(p.prefixlen));

  /* Nexthop, ifindex, distance, metric. */
Pim_zebra.c (pimd):598
		 inet_ntop(AF_INET, &p.prefix, buf[0], sizeof(buf[0])),
		 p.prefixlen,
		 inet_ntop(AF_INET, &nexthop, buf[1], sizeof(buf[1])),
Pim_zebra.c (pimd):615
		 inet_ntop(AF_INET, &p.prefix, buf[0], sizeof(buf[0])),
		 p.prefixlen,
		 inet_ntop(AF_INET, &nexthop, buf[1], sizeof(buf[1])),
Pim_zlookup.c (pimd):27
#include "prefix.h"
#include "zclient.h"
#include "stream.h"
Plist.c (lib):24
#include "prefix.h"
#include "command.h"
#include "memory.h"
Plist.c (lib):75
/* Static structure of IPv6 prefix-list's master. */
static struct prefix_master prefix_master_ipv6 = 
{ 
Plist.c (lib):188
/* Insert new prefix list to list of prefix_list.  Each prefix_list
   is sorted by the name. */
static struct prefix_list *
Plist.c (lib):292
/* Delete prefix-list from prefix_list_master and free it. */
static void
prefix_list_delete (struct prefix_list *plist)
Plist.c (lib):301
  /* If prefix-list contain prefix_list_entry free all of it. */
  for (pentry = plist->head; pentry; pentry = next)
    {
Plist.c (lib):329
  /* Make sure master's recent changed prefix-list information is
     cleared. */
  master->recent = NULL;
Plist.c (lib):343
prefix_list_entry_make (struct prefix *prefix, enum prefix_list_type type,
			int seq, int le, int ge, int any)
{
Plist.c (lib):353
  prefix_copy (&pentry->prefix, prefix);
  pentry->type = type;
  pentry->seq = seq;
Plist.c (lib):403
/* Return prefix list entry which has same seq number. */
static struct prefix_list_entry *
prefix_seq_check (struct prefix_list *plist, int seq)
Plist.c (lib):416
prefix_list_entry_lookup (struct prefix_list *plist, struct prefix *prefix,
			  enum prefix_list_type type, int seq, int le, int ge)
{
Plist.c (lib):422
    if (prefix_same (&pentry->prefix, prefix) && pentry->type == type)
      {
	if (seq >= 0 && pentry->seq != seq)
Plist.c (lib):481
  /* Is there any same seq prefix list entry? */
  replace = prefix_seq_check (plist, pentry->seq);
  if (replace)
Plist.c (lib):541
prefix_list_entry_match (struct prefix_list_entry *pentry, struct prefix *p)
{
  int ret;
Plist.c (lib):545
  ret = prefix_match (&pentry->prefix, p);
  if (! ret)
    return 0;
Plist.c (lib):552
      if (pentry->prefix.prefixlen != p->prefixlen)
	return 0;
    }
Plist.c (lib):572
  struct prefix *p;

  p = (struct prefix *) object;

  if (plist == NULL)
Plist.c (lib):603
  printf ("ip prefix-list %s: %d entries\n", plist->name, plist->count);

  for (pentry = plist->head; pentry; pentry = pentry->next)
Plist.c (lib):611
	  struct prefix *p;
	  char buf[BUFSIZ];
	  
	  p = &pentry->prefix;
	  
	  printf ("  seq %d %s %s/%d", 
Plist.c (lib):619
		  inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
		  p->prefixlen);
	  if (pentry->ge)
Plist.c (lib):645
      if (prefix_same (&pentry->prefix, &new->prefix)
	  && pentry->type == new->type
	  && pentry->le == new->le
Plist.c (lib):656
vty_invalid_prefix_range (struct vty *vty, const char *prefix)
{
  vty_out (vty, "%% Invalid prefix range for %s, make sure: len < ge-value <= le-value%s",
           prefix, VTY_NEWLINE);
  return CMD_WARNING;
}
Plist.c (lib):666
			 const char *prefix, const char *ge, const char *le)
{
  int ret;
Plist.c (lib):673
  struct prefix p;
  int any = 0;
  int seqnum = -1;
Plist.c (lib):684
      vty_out (vty, "%% prefix must be IPv4 or IPv6!%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Plist.c (lib):705
      vty_out (vty, "%% prefix type must be permit or deny%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Plist.c (lib):713
      if (strncmp ("any", prefix, strlen (prefix)) == 0)
	{
	  ret = str2prefix_ipv4 ("0.0.0.0/0", (struct prefix_ipv4 *) &p);
Plist.c (lib):721
	ret = str2prefix_ipv4 (prefix, (struct prefix_ipv4 *) &p);

      if (ret <= 0)
Plist.c (lib):725
	  vty_out (vty, "%% Malformed IPv4 prefix%s", VTY_NEWLINE);
	  return CMD_WARNING;
	}
Plist.c (lib):730
      if (strncmp ("any", prefix, strlen (prefix)) == 0)
	{
	  ret = str2prefix_ipv6 ("::/0", (struct prefix_ipv6 *) &p);
Plist.c (lib):738
	ret = str2prefix_ipv6 (prefix, (struct prefix_ipv6 *) &p);

      if (ret <= 0)
Plist.c (lib):742
	  vty_out (vty, "%% Malformed IPv6 prefix%s", VTY_NEWLINE);
	  return CMD_WARNING;
	}
Plist.c (lib):755
    return vty_invalid_prefix_range (vty, prefix);

  if (lenum && (lenum <= p.prefixlen))
    return vty_invalid_prefix_range (vty, prefix);

  if (lenum && (genum > lenum))
    return vty_invalid_prefix_range (vty, prefix);

  if (genum && (lenum == (afi == AFI_IP ? 32 : 128)))
Plist.c (lib):769
  /* Make prefix entry. */
  pentry = prefix_list_entry_make (&p, type, seqnum, lenum, genum, any);
    
Plist.c (lib):778
      vty_out (vty, "%% Insertion failed - prefix-list entry exists:%s",
	       VTY_NEWLINE);
      vty_out (vty, "   seq %d %s %s", dup->seq, typestr, prefix);
      if (! any && genum)
	vty_out (vty, " ge %d", genum);
Plist.c (lib):798
			   const char *prefix, const char *ge, const char *le)
{
  int ret;
Plist.c (lib):804
  struct prefix p;
  int seqnum = -1;
  int lenum = 0;
Plist.c (lib):809
  /* Check prefix list name. */
  plist = prefix_list_lookup (afi, name);
  if (! plist)
Plist.c (lib):813
      vty_out (vty, "%% Can't find specified prefix-list%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Plist.c (lib):817
  /* Only prefix-list name specified, delete the entire prefix-list. */
  if (seq == NULL && typestr == NULL && prefix == NULL && 
      ge == NULL && le == NULL)
    {
Plist.c (lib):825
  /* We must have, at a minimum, both the type and prefix here */
  if ((typestr == NULL) || (prefix == NULL))
    {
      vty_out (vty, "%% Both prefix and type required%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Plist.c (lib):849
      vty_out (vty, "%% prefix type must be permit or deny%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Plist.c (lib):856
      if (strncmp ("any", prefix, strlen (prefix)) == 0)
	{
	  ret = str2prefix_ipv4 ("0.0.0.0/0", (struct prefix_ipv4 *) &p);
Plist.c (lib):863
	ret = str2prefix_ipv4 (prefix, (struct prefix_ipv4 *) &p);

      if (ret <= 0)
Plist.c (lib):867
	  vty_out (vty, "%% Malformed IPv4 prefix%s", VTY_NEWLINE);
	  return CMD_WARNING;
	}
Plist.c (lib):874
      if (strncmp ("any", prefix, strlen (prefix)) == 0)
	{
	  ret = str2prefix_ipv6 ("::/0", (struct prefix_ipv6 *) &p);
Plist.c (lib):881
	ret = str2prefix_ipv6 (prefix, (struct prefix_ipv6 *) &p);

      if (ret <= 0)
Plist.c (lib):885
	  vty_out (vty, "%% Malformed IPv6 prefix%s", VTY_NEWLINE);
	  return CMD_WARNING;
	}
Plist.c (lib):891
  /* Lookup prefix entry. */
  pentry = prefix_list_entry_lookup(plist, &p, type, seqnum, lenum, genum);

Plist.c (lib):896
      vty_out (vty, "%% Can't find specified prefix-list%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Plist.c (lib):914
      vty_out (vty, "%% Can't find specified prefix-list%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Plist.c (lib):953
      vty_out (vty, "ip%s prefix-list %s: %d entries%s",
	       afi == AFI_IP ? "" : "v6",
	       plist->name, plist->count, VTY_NEWLINE);
Plist.c (lib):961
      vty_out (vty, "ip%s prefix-list %s:%s",
	       afi == AFI_IP ? "" : "v6", plist->name, VTY_NEWLINE);

Plist.c (lib):992
	      struct prefix *p = &pentry->prefix;
	      char buf[BUFSIZ];

Plist.c (lib):996
		       inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
		       p->prefixlen);

Plist.c (lib):1034
	  vty_out (vty, "%% Can't find specified prefix-list%s", VTY_NEWLINE);
	  return CMD_WARNING;
	}
Plist.c (lib):1060
			     const char *prefix, enum display_type type)
{
  struct prefix_list *plist;
Plist.c (lib):1064
  struct prefix p;
  int ret;
  int match;
Plist.c (lib):1071
      vty_out (vty, "%% Can't find specified prefix-list%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Plist.c (lib):1075
  ret = str2prefix (prefix, &p);
  if (ret <= 0)
    {
      vty_out (vty, "%% prefix is malformed%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Plist.c (lib):1087
	if (prefix_same (&p, &pentry->prefix))
	  match = 1;

Plist.c (lib):1091
	if (prefix_match (&p, &pentry->prefix))
	  match = 1;

Plist.c (lib):1104
	      struct prefix *p = &pentry->prefix;
	      char buf[BUFSIZ];
	      
Plist.c (lib):1108
		       inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
		       p->prefixlen);

Plist.c (lib):1132
                       const char *prefix)
{
  struct prefix_master *master;
Plist.c (lib):1138
  struct prefix p;

  master = prefix_master_get (afi, 0);
Plist.c (lib):1144
  if (name == NULL && prefix == NULL)
    {
      for (plist = master->num.head; plist; plist = plist->next)
Plist.c (lib):1159
	  vty_out (vty, "%% Can't find specified prefix-list%s", VTY_NEWLINE);
	  return CMD_WARNING;
	}
Plist.c (lib):1163
      if (prefix)
	{
	  ret = str2prefix (prefix, &p);
	  if (ret <= 0)
	    {
	      vty_out (vty, "%% prefix is malformed%s", VTY_NEWLINE);
	      return CMD_WARNING;
	    }
Plist.c (lib):1175
	  if (prefix)
	    {
	      if (prefix_match (&pentry->prefix, &p))
		pentry->hitcnt = 0;
	    }
Plist.c (lib):1189
       "ip prefix-list WORD (deny|permit) (A.B.C.D/M|any)",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Any prefix match. Same as \"0.0.0.0/0 le 32\"\n")
{
  return vty_prefix_list_install (vty, AFI_IP, argv[0], NULL, 
Plist.c (lib):1204
       "ip prefix-list WORD (deny|permit) A.B.C.D/M ge <0-32>",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
  return vty_prefix_list_install (vty, AFI_IP, argv[0], NULL, argv[1], 
Plist.c (lib):1220
       "ip prefix-list WORD (deny|permit) A.B.C.D/M ge <0-32> le <0-32>",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
  return vty_prefix_list_install (vty, AFI_IP, argv[0], NULL, argv[1], 
Plist.c (lib):1238
       "ip prefix-list WORD (deny|permit) A.B.C.D/M le <0-32>",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
  return vty_prefix_list_install (vty, AFI_IP, argv[0], NULL, argv[1],
Plist.c (lib):1254
       "ip prefix-list WORD (deny|permit) A.B.C.D/M le <0-32> ge <0-32>",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
  return vty_prefix_list_install (vty, AFI_IP, argv[0], NULL, argv[1],
Plist.c (lib):1272
       "ip prefix-list WORD seq <1-4294967295> (deny|permit) (A.B.C.D/M|any)",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):1280
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Any prefix match. Same as \"0.0.0.0/0 le 32\"\n")
{
  return vty_prefix_list_install (vty, AFI_IP, argv[0], argv[1], argv[2],
Plist.c (lib):1289
       "ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M ge <0-32>",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):1297
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
  return vty_prefix_list_install (vty, AFI_IP, argv[0], argv[1], argv[2],
Plist.c (lib):1307
       "ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M ge <0-32> le <0-32>",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):1315
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
  return vty_prefix_list_install (vty, AFI_IP, argv[0], argv[1], argv[2],
Plist.c (lib):1327
       "ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M le <0-32>",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):1335
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
  return vty_prefix_list_install (vty, AFI_IP, argv[0], argv[1], argv[2],
Plist.c (lib):1345
       "ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M le <0-32> ge <0-32>",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):1353
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
  return vty_prefix_list_install (vty, AFI_IP, argv[0], argv[1], argv[2],
Plist.c (lib):1365
       "no ip prefix-list WORD",
       NO_STR
       IP_STR
Plist.c (lib):1369
       "Name of a prefix list\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], NULL, NULL,
Plist.c (lib):1377
       "no ip prefix-list WORD (deny|permit) (A.B.C.D/M|any)",
       NO_STR
       IP_STR
Plist.c (lib):1381
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Any prefix match.  Same as \"0.0.0.0/0 le 32\"\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], NULL, argv[1],
Plist.c (lib):1393
       "no ip prefix-list WORD (deny|permit) A.B.C.D/M ge <0-32>",
       NO_STR
       IP_STR
Plist.c (lib):1397
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], NULL, argv[1],
Plist.c (lib):1410
       "no ip prefix-list WORD (deny|permit) A.B.C.D/M ge <0-32> le <0-32>",
       NO_STR
       IP_STR
Plist.c (lib):1414
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], NULL, argv[1],
Plist.c (lib):1429
       "no ip prefix-list WORD (deny|permit) A.B.C.D/M le <0-32>",
       NO_STR
       IP_STR
Plist.c (lib):1433
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], NULL, argv[1],
Plist.c (lib):1446
       "no ip prefix-list WORD (deny|permit) A.B.C.D/M le <0-32> ge <0-32>",
       NO_STR
       IP_STR
Plist.c (lib):1450
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], NULL, argv[1],
Plist.c (lib):1465
       "no ip prefix-list WORD seq <1-4294967295> (deny|permit) (A.B.C.D/M|any)",
       NO_STR
       IP_STR
Plist.c (lib):1469
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):1474
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Any prefix match.  Same as \"0.0.0.0/0 le 32\"\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], argv[1], argv[2],
Plist.c (lib):1483
       "no ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M ge <0-32>",
       NO_STR
       IP_STR
Plist.c (lib):1487
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):1492
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], argv[1], argv[2],
Plist.c (lib):1502
       "no ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M ge <0-32> le <0-32>",
       NO_STR
       IP_STR
Plist.c (lib):1506
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):1511
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], argv[1], argv[2],
Plist.c (lib):1523
       "no ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M le <0-32>",
       NO_STR
       IP_STR
Plist.c (lib):1527
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):1532
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], argv[1], argv[2],
Plist.c (lib):1542
       "no ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M le <0-32> ge <0-32>",
       NO_STR
       IP_STR
Plist.c (lib):1546
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):1551
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], argv[1], argv[2],
Plist.c (lib):1563
       "ip prefix-list sequence-number",
       IP_STR
       PREFIX_LIST_STR
Plist.c (lib):1574
       "no ip prefix-list sequence-number",
       NO_STR
       IP_STR
Plist.c (lib):1586
       "ip prefix-list WORD description .LINE",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Prefix-list specific description\n"
       "Up to 80 characters describing this prefix-list\n")
{
  struct prefix_list *plist;
Plist.c (lib):1609
       "no ip prefix-list WORD description",
       NO_STR
       IP_STR
Plist.c (lib):1613
       "Name of a prefix list\n"
       "Prefix-list specific description\n")
{
Plist.c (lib):1621
       "no ip prefix-list WORD description .LINE",
       NO_STR
       IP_STR
Plist.c (lib):1625
       "Name of a prefix list\n"
       "Prefix-list specific description\n"
       "Up to 80 characters describing this prefix-list\n")

DEFUN (show_ip_prefix_list,
Plist.c (lib):1631
       "show ip prefix-list",
       SHOW_STR
       IP_STR
Plist.c (lib):1641
       "show ip prefix-list WORD",
       SHOW_STR
       IP_STR
Plist.c (lib):1645
       "Name of a prefix list\n")
{
  return vty_show_prefix_list (vty, AFI_IP, argv[0], NULL, normal_display);
Plist.c (lib):1652
       "show ip prefix-list WORD seq <1-4294967295>",
       SHOW_STR
       IP_STR
Plist.c (lib):1656
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n")
Plist.c (lib):1665
       "show ip prefix-list WORD A.B.C.D/M",
       SHOW_STR
       IP_STR
Plist.c (lib):1669
       "Name of a prefix list\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  return vty_show_prefix_list_prefix (vty, AFI_IP, argv[0], argv[1], normal_display);
Plist.c (lib):1677
       "show ip prefix-list WORD A.B.C.D/M longer",
       SHOW_STR
       IP_STR
Plist.c (lib):1681
       "Name of a prefix list\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Lookup longer prefix\n")
{
  return vty_show_prefix_list_prefix (vty, AFI_IP, argv[0], argv[1], longer_display);
Plist.c (lib):1690
       "show ip prefix-list WORD A.B.C.D/M first-match",
       SHOW_STR
       IP_STR
Plist.c (lib):1694
       "Name of a prefix list\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "First matched prefix\n")
{
  return vty_show_prefix_list_prefix (vty, AFI_IP, argv[0], argv[1], first_match_display);
Plist.c (lib):1703
       "show ip prefix-list summary",
       SHOW_STR
       IP_STR
Plist.c (lib):1707
       "Summary of prefix lists\n")
{
  return vty_show_prefix_list (vty, AFI_IP, NULL, NULL, summary_display);
Plist.c (lib):1714
       "show ip prefix-list summary WORD",
       SHOW_STR
       IP_STR
Plist.c (lib):1718
       "Summary of prefix lists\n"
       "Name of a prefix list\n")
{
  return vty_show_prefix_list (vty, AFI_IP, argv[0], NULL, summary_display);
Plist.c (lib):1727
       "show ip prefix-list detail",
       SHOW_STR
       IP_STR
Plist.c (lib):1731
       "Detail of prefix lists\n")
{
  return vty_show_prefix_list (vty, AFI_IP, NULL, NULL, detail_display);
Plist.c (lib):1738
       "show ip prefix-list detail WORD",
       SHOW_STR
       IP_STR
Plist.c (lib):1742
       "Detail of prefix lists\n"
       "Name of a prefix list\n")
{
  return vty_show_prefix_list (vty, AFI_IP, argv[0], NULL, detail_display);
Plist.c (lib):1750
       "clear ip prefix-list",
       CLEAR_STR
       IP_STR
Plist.c (lib):1760
       "clear ip prefix-list WORD",
       CLEAR_STR
       IP_STR
Plist.c (lib):1764
       "Name of a prefix list\n")
{
  return vty_clear_prefix_list (vty, AFI_IP, argv[0], NULL);
Plist.c (lib):1771
       "clear ip prefix-list WORD A.B.C.D/M",
       CLEAR_STR
       IP_STR
Plist.c (lib):1775
       "Name of a prefix list\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  return vty_clear_prefix_list (vty, AFI_IP, argv[0], argv[1]);
Plist.c (lib):1784
       "ipv6 prefix-list WORD (deny|permit) (X:X::X:X/M|any)",
       IPV6_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Any prefix match.  Same as \"::0/0 le 128\"\n")
{
  return vty_prefix_list_install (vty, AFI_IP6, argv[0], NULL, 
Plist.c (lib):1799
       "ipv6 prefix-list WORD (deny|permit) X:X::X:X/M ge <0-128>",
       IPV6_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
  return vty_prefix_list_install (vty, AFI_IP6, argv[0], NULL, argv[1], 
Plist.c (lib):1815
       "ipv6 prefix-list WORD (deny|permit) X:X::X:X/M ge <0-128> le <0-128>",
       IPV6_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")

{
Plist.c (lib):1834
       "ipv6 prefix-list WORD (deny|permit) X:X::X:X/M le <0-128>",
       IPV6_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
  return vty_prefix_list_install (vty, AFI_IP6, argv[0], NULL, argv[1],
Plist.c (lib):1850
       "ipv6 prefix-list WORD (deny|permit) X:X::X:X/M le <0-128> ge <0-128>",
       IPV6_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
  return vty_prefix_list_install (vty, AFI_IP6, argv[0], NULL, argv[1],
Plist.c (lib):1868
       "ipv6 prefix-list WORD seq <1-4294967295> (deny|permit) (X:X::X:X/M|any)",
       IPV6_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):1876
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Any prefix match.  Same as \"::0/0 le 128\"\n")
{
  return vty_prefix_list_install (vty, AFI_IP6, argv[0], argv[1], argv[2],
Plist.c (lib):1885
       "ipv6 prefix-list WORD seq <1-4294967295> (deny|permit) X:X::X:X/M ge <0-128>",
       IPV6_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):1893
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
  return vty_prefix_list_install (vty, AFI_IP6, argv[0], argv[1], argv[2],
Plist.c (lib):1903
       "ipv6 prefix-list WORD seq <1-4294967295> (deny|permit) X:X::X:X/M ge <0-128> le <0-128>",
       IPV6_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):1911
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
  return vty_prefix_list_install (vty, AFI_IP6, argv[0], argv[1], argv[2],
Plist.c (lib):1923
       "ipv6 prefix-list WORD seq <1-4294967295> (deny|permit) X:X::X:X/M le <0-128>",
       IPV6_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):1931
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
  return vty_prefix_list_install (vty, AFI_IP6, argv[0], argv[1], argv[2],
Plist.c (lib):1941
       "ipv6 prefix-list WORD seq <1-4294967295> (deny|permit) X:X::X:X/M le <0-128> ge <0-128>",
       IPV6_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):1949
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
  return vty_prefix_list_install (vty, AFI_IP6, argv[0], argv[1], argv[2],
Plist.c (lib):1961
       "no ipv6 prefix-list WORD",
       NO_STR
       IPV6_STR
Plist.c (lib):1965
       "Name of a prefix list\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP6, argv[0], NULL, NULL,
Plist.c (lib):1973
       "no ipv6 prefix-list WORD (deny|permit) (X:X::X:X/M|any)",
       NO_STR
       IPV6_STR
Plist.c (lib):1977
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Any prefix match.  Same as \"::0/0 le 128\"\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP6, argv[0], NULL, argv[1],
Plist.c (lib):1989
       "no ipv6 prefix-list WORD (deny|permit) X:X::X:X/M ge <0-128>",
       NO_STR
       IPV6_STR
Plist.c (lib):1993
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP6, argv[0], NULL, argv[1],
Plist.c (lib):2006
       "no ipv6 prefix-list WORD (deny|permit) X:X::X:X/M ge <0-128> le <0-128>",
       NO_STR
       IPV6_STR
Plist.c (lib):2010
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP6, argv[0], NULL, argv[1],
Plist.c (lib):2025
       "no ipv6 prefix-list WORD (deny|permit) X:X::X:X/M le <0-128>",
       NO_STR
       IPV6_STR
Plist.c (lib):2029
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP6, argv[0], NULL, argv[1],
Plist.c (lib):2042
       "no ipv6 prefix-list WORD (deny|permit) X:X::X:X/M le <0-128> ge <0-128>",
       NO_STR
       IPV6_STR
Plist.c (lib):2046
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP6, argv[0], NULL, argv[1],
Plist.c (lib):2061
       "no ipv6 prefix-list WORD seq <1-4294967295> (deny|permit) (X:X::X:X/M|any)",
       NO_STR
       IPV6_STR
Plist.c (lib):2065
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):2070
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Any prefix match.  Same as \"::0/0 le 128\"\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP6, argv[0], argv[1], argv[2],
Plist.c (lib):2079
       "no ipv6 prefix-list WORD seq <1-4294967295> (deny|permit) X:X::X:X/M ge <0-128>",
       NO_STR
       IPV6_STR
Plist.c (lib):2083
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):2088
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP6, argv[0], argv[1], argv[2],
Plist.c (lib):2098
       "no ipv6 prefix-list WORD seq <1-4294967295> (deny|permit) X:X::X:X/M ge <0-128> le <0-128>",
       NO_STR
       IPV6_STR
Plist.c (lib):2102
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):2107
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP6, argv[0], argv[1], argv[2],
Plist.c (lib):2119
       "no ipv6 prefix-list WORD seq <1-4294967295> (deny|permit) X:X::X:X/M le <0-128>",
       NO_STR
       IPV6_STR
Plist.c (lib):2123
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):2128
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP6, argv[0], argv[1], argv[2],
Plist.c (lib):2138
       "no ipv6 prefix-list WORD seq <1-4294967295> (deny|permit) X:X::X:X/M le <0-128> ge <0-128>",
       NO_STR
       IPV6_STR
Plist.c (lib):2142
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
Plist.c (lib):2147
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
  return vty_prefix_list_uninstall (vty, AFI_IP6, argv[0], argv[1], argv[2],
Plist.c (lib):2159
       "ipv6 prefix-list sequence-number",
       IPV6_STR
       PREFIX_LIST_STR
Plist.c (lib):2170
       "no ipv6 prefix-list sequence-number",
       NO_STR
       IPV6_STR
Plist.c (lib):2182
       "ipv6 prefix-list WORD description .LINE",
       IPV6_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Prefix-list specific description\n"
       "Up to 80 characters describing this prefix-list\n")
{
  struct prefix_list *plist;
Plist.c (lib):2205
       "no ipv6 prefix-list WORD description",
       NO_STR
       IPV6_STR
Plist.c (lib):2209
       "Name of a prefix list\n"
       "Prefix-list specific description\n")
{
Plist.c (lib):2217
       "no ipv6 prefix-list WORD description .LINE",
       NO_STR
       IPV6_STR
Plist.c (lib):2221
       "Name of a prefix list\n"
       "Prefix-list specific description\n"
       "Up to 80 characters describing this prefix-list\n")

DEFUN (show_ipv6_prefix_list,
Plist.c (lib):2227
       "show ipv6 prefix-list",
       SHOW_STR
       IPV6_STR
Plist.c (lib):2237
       "show ipv6 prefix-list WORD",
       SHOW_STR
       IPV6_STR
Plist.c (lib):2241
       "Name of a prefix list\n")
{
  return vty_show_prefix_list (vty, AFI_IP6, argv[0], NULL, normal_display);
Plist.c (lib):2248
       "show ipv6 prefix-list WORD seq <1-4294967295>",
       SHOW_STR
       IPV6_STR
Plist.c (lib):2252
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n")
Plist.c (lib):2261
       "show ipv6 prefix-list WORD X:X::X:X/M",
       SHOW_STR
       IPV6_STR
Plist.c (lib):2265
       "Name of a prefix list\n"
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n")
{
  return vty_show_prefix_list_prefix (vty, AFI_IP6, argv[0], argv[1], normal_display);
Plist.c (lib):2273
       "show ipv6 prefix-list WORD X:X::X:X/M longer",
       SHOW_STR
       IPV6_STR
Plist.c (lib):2277
       "Name of a prefix list\n"
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "Lookup longer prefix\n")
{
  return vty_show_prefix_list_prefix (vty, AFI_IP6, argv[0], argv[1], longer_display);
Plist.c (lib):2286
       "show ipv6 prefix-list WORD X:X::X:X/M first-match",
       SHOW_STR
       IPV6_STR
Plist.c (lib):2290
       "Name of a prefix list\n"
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n"
       "First matched prefix\n")
{
  return vty_show_prefix_list_prefix (vty, AFI_IP6, argv[0], argv[1], first_match_display);
Plist.c (lib):2299
       "show ipv6 prefix-list summary",
       SHOW_STR
       IPV6_STR
Plist.c (lib):2303
       "Summary of prefix lists\n")
{
  return vty_show_prefix_list (vty, AFI_IP6, NULL, NULL, summary_display);
Plist.c (lib):2310
       "show ipv6 prefix-list summary WORD",
       SHOW_STR
       IPV6_STR
Plist.c (lib):2314
       "Summary of prefix lists\n"
       "Name of a prefix list\n")
{
  return vty_show_prefix_list (vty, AFI_IP6, argv[0], NULL, summary_display);
Plist.c (lib):2322
       "show ipv6 prefix-list detail",
       SHOW_STR
       IPV6_STR
Plist.c (lib):2326
       "Detail of prefix lists\n")
{
  return vty_show_prefix_list (vty, AFI_IP6, NULL, NULL, detail_display);
Plist.c (lib):2333
       "show ipv6 prefix-list detail WORD",
       SHOW_STR
       IPV6_STR
Plist.c (lib):2337
       "Detail of prefix lists\n"
       "Name of a prefix list\n")
{
  return vty_show_prefix_list (vty, AFI_IP6, argv[0], NULL, detail_display);
Plist.c (lib):2345
       "clear ipv6 prefix-list",
       CLEAR_STR
       IPV6_STR
Plist.c (lib):2355
       "clear ipv6 prefix-list WORD",
       CLEAR_STR
       IPV6_STR
Plist.c (lib):2359
       "Name of a prefix list\n")
{
  return vty_clear_prefix_list (vty, AFI_IP6, argv[0], NULL);
Plist.c (lib):2366
       "clear ipv6 prefix-list WORD X:X::X:X/M",
       CLEAR_STR
       IPV6_STR
Plist.c (lib):2370
       "Name of a prefix list\n"
       "IPv6 prefix <network>/<length>, e.g., 3ffe::/16\n")
{
  return vty_clear_prefix_list (vty, AFI_IP6, argv[0], argv[1]);
Plist.c (lib):2392
      vty_out (vty, "no ip%s prefix-list sequence-number%s", 
	       afi == AFI_IP ? "" : "v6", VTY_NEWLINE);
      vty_out (vty, "!%s", VTY_NEWLINE);
Plist.c (lib):2401
	  vty_out (vty, "ip%s prefix-list %s description %s%s",
		   afi == AFI_IP ? "" : "v6",
		   plist->name, plist->desc, VTY_NEWLINE);
Plist.c (lib):2409
	  vty_out (vty, "ip%s prefix-list %s ",
		   afi == AFI_IP ? "" : "v6",
		   plist->name);
Plist.c (lib):2422
	      struct prefix *p = &pentry->prefix;
	      char buf[BUFSIZ];

Plist.c (lib):2426
		       inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
		       p->prefixlen);

Plist.c (lib):2444
	  vty_out (vty, "ip%s prefix-list %s description %s%s",
		   afi == AFI_IP ? "" : "v6",
		   plist->name, plist->desc, VTY_NEWLINE);
Plist.c (lib):2452
	  vty_out (vty, "ip%s prefix-list %s ",
		   afi == AFI_IP ? "" : "v6",
		   plist->name);
Plist.c (lib):2465
	      struct prefix *p = &pentry->prefix;
	      char buf[BUFSIZ];

Plist.c (lib):2469
		       inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
		       p->prefixlen);

Plist.c (lib):2497
      struct prefix *p = &pentry->prefix;

      flag |= (pentry->type == PREFIX_PERMIT ?
Plist.c (lib):2572
/* return prefix count */
int
prefix_bgp_show_prefix_list (struct vty *vty, afi_t afi, char *name)
Plist.c (lib):2586
  vty_out (vty, "ip%s prefix-list %s: %d entries%s",
	   afi == AFI_IP ? "" : "v6",
	   plist->name, plist->count, VTY_NEWLINE);
Plist.c (lib):2592
      struct prefix *p = &pentry->prefix;
      char buf[BUFSIZ];

Plist.c (lib):2597
	       inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
	       p->prefixlen);

Plist.h (lib):39
  struct prefix p;
};

Plist_int.h (lib):51
/* Each prefix-list's entry. */
struct prefix_list_entry
{
Plist_int.h (lib):62
  struct prefix prefix;

  unsigned long refcnt;
Prefix.c (lib):25
#include "prefix.h"
#include "vty.h"
#include "sockunion.h"
Prefix.c (lib):168
/* Number of bits in prefix type. */
#ifndef PNBBY
#define PNBBY 8
Prefix.c (lib):176
prefix_bit (const u_char *prefix, const u_char prefixlen)
{
  unsigned int offset = prefixlen / 8;
Prefix.c (lib):181
  return (prefix[offset] >> shift) & 1;
}

Prefix.c (lib):185
prefix6_bit (const struct in6_addr *prefix, const u_char prefixlen)
{
  return prefix_bit((const u_char *) &prefix->s6_addr, prefixlen);
}

Prefix.c (lib):261
/* If n includes p prefix then return 1 else return 0. */
int
prefix_match (const struct prefix *n, const struct prefix *p)
{
  int offset;
Prefix.c (lib):269
  /* If n's prefix is longer than p's one return 0. */
  if (n->prefixlen > p->prefixlen)
    return 0;
Prefix.c (lib):273
  /* Set both prefix's head pointer. */
  np = (const u_char *)&n->u.prefix;
  pp = (const u_char *)&p->u.prefix;
  
  offset = n->prefixlen / PNBBY;
Prefix.c (lib):290
/* Copy prefix from src to dest. */
void
prefix_copy (struct prefix *dest, const struct prefix *src)
{
  dest->family = src->family;
Prefix.c (lib):321
 * Return 1 if the address/netmask contained in the prefix structure
 * is the same, and else return 0.  For this routine, 'same' requires
 * that not only the prefix length and the network part be the same,
 * but also the host part.  Thus, 10.0.0.1/8 and 10.0.0.2/8 are not
 * the same.  Note that this routine has the same return value sense
Prefix.c (lib):329
prefix_same (const struct prefix *p1, const struct prefix *p2)
{
  if (p1->family == p2->family && p1->prefixlen == p2->prefixlen)
Prefix.c (lib):350
 * Return 0 if the network prefixes represented by the struct prefix
 * arguments are the same prefix, and 1 otherwise.  Network prefixes
 * are considered the same if the prefix lengths are equal and the
 * network parts are the same.  Host bits (which are considered masked
 * by the prefix length) are not significant.  Thus, 10.0.0.1/8 and
 * 10.0.0.2/8 are considered equivalent by this routine.  Note that
 * this routine has the same return sense as strcmp (which is different
Prefix.c (lib):360
prefix_cmp (const struct prefix *p1, const struct prefix *p2)
{
  int offset;
Prefix.c (lib):365
  /* Set both prefix's head pointer. */
  const u_char *pp1 = (const u_char *)&p1->u.prefix;
  const u_char *pp2 = (const u_char *)&p2->u.prefix;

  if (p1->family != p2->family || p1->prefixlen != p2->prefixlen)
Prefix.c (lib):387
 * Count the number of common bits in 2 prefixes. The prefix length is
 * ignored for this function; the whole prefix is compared. If the prefix
 * address families don't match, return -1; otherwise the return value is
 * in range 0 ... maximum prefix length for the address family.
 */
int
prefix_common_bits (const struct prefix *p1, const struct prefix *p2)
{
  int pos, bit;
Prefix.c (lib):399
  /* Set both prefix's head pointer. */
  const u_char *pp1 = (const u_char *)&p1->u.prefix;
  const u_char *pp2 = (const u_char *)&p2->u.prefix;

  if (p1->family == AF_INET)
Prefix.c (lib):426
/* Return prefix family type string. */
const char *
prefix_family_str (const struct prefix *p)
{
  if (p->family == AF_INET)
Prefix.c (lib):447
  /* Call prefix_new to allocate a full-size struct prefix to avoid problems
     where the struct prefix_ipv4 is cast to struct prefix and unallocated
     bytes were being referenced (e.g. in structure assignments). */
  p = (struct prefix_ipv4 *)prefix_new();
Prefix.c (lib):459
  prefix_free((struct prefix *)p);
}

Prefix.c (lib):477
      /* Convert string to prefix. */
      ret = inet_aton (str, &p->prefix);
      if (ret == 0)
	return 0;
Prefix.c (lib):493
      ret = inet_aton (cp, &p->prefix);
      XFREE (MTYPE_TMP, cp);

      /* Get prefix length. */
      plen = (u_char) atoi (++pnt);
      if (plen > IPV4_MAX_PREFIXLEN)
Prefix.c (lib):525
      /* Get prefix length. */
      plen = (u_char) atoi (++pnt);
      if (plen > 48)
Prefix.c (lib):540
  /* Convert string to prefix. */
  if (sscanf(str_addr, "%2x:%2x:%2x:%2x:%2x:%2x",
    a+0, a+1, a+2, a+3, a+4, a+5) != 6)
Prefix.c (lib):592
/* Apply mask to IPv4 prefix (network byte order). */
void
apply_mask_ipv4 (struct prefix_ipv4 *p)
Prefix.c (lib):598
  p->prefix.s_addr &= mask.s_addr;
}

/* If prefix is 0.0.0.0/0 then return 1 else return 0. */
int
prefix_ipv4_any (const struct prefix_ipv4 *p)
Prefix.c (lib):605
  return (p->prefix.s_addr == 0 && p->prefixlen == 0);
}

Prefix.c (lib):616
  /* Allocate a full-size struct prefix to avoid problems with structure
     size mismatches. */
  p = (struct prefix_ipv6 *)prefix_new();
Prefix.c (lib):623
/* Free prefix for IPv6. */
void
prefix_ipv6_free (struct prefix_ipv6 *p)
Prefix.c (lib):627
  prefix_free((struct prefix *)p);
}

Prefix.c (lib):643
      ret = inet_pton (AF_INET6, str, &p->prefix);
      if (ret == 0)
	return 0;
Prefix.c (lib):655
      ret = inet_pton (AF_INET6, cp, &p->prefix);
      free (cp);
      if (ret == 0)
Prefix.c (lib):716
      pnt = (u_char *) &p->prefix;
      offset = p->prefixlen % 8;

Prefix.c (lib):743
apply_mask (struct prefix *p)
{
  switch (p->family)
Prefix.c (lib):761
/* Utility function of convert between struct prefix <=> union sockunion.
 * FIXME This function isn't used anywhere. */
struct prefix *
sockunion2prefix (const union sockunion *dest,
		  const union sockunion *mask)
Prefix.c (lib):773
      p->prefix = dest->sin.sin_addr;
      p->prefixlen = ip_masklen (mask->sin.sin_addr);
      return (struct prefix *) p;
    }
#ifdef HAVE_IPV6
Prefix.c (lib):785
      memcpy (&p->prefix, &dest->sin6.sin6_addr, sizeof (struct in6_addr));
      return (struct prefix *) p;
    }
#endif /* HAVE_IPV6 */
Prefix.c (lib):792
/* Utility function of convert between struct prefix <=> union sockunion. */
struct prefix *
sockunion2hostprefix (const union sockunion *su, struct prefix *prefix)
{
  if (su->sa.sa_family == AF_INET)
Prefix.c (lib):800
      p = prefix ? (struct prefix_ipv4 *) prefix : prefix_ipv4_new ();
      p->family = AF_INET;
      p->prefix = su->sin.sin_addr;
      p->prefixlen = IPV4_MAX_BITLEN;
      return (struct prefix *) p;
    }
#ifdef HAVE_IPV6
Prefix.c (lib):811
      p = prefix ? (struct prefix_ipv6 *) prefix : prefix_ipv6_new ();
      p->family = AF_INET6;
      p->prefixlen = IPV6_MAX_BITLEN;
      memcpy (&p->prefix, &su->sin6.sin6_addr, sizeof (struct in6_addr));
      return (struct prefix *) p;
    }
#endif /* HAVE_IPV6 */
Prefix.c (lib):822
prefix2sockunion (const struct prefix *p, union sockunion *su)
{
  memset (su, 0, sizeof (*su));
Prefix.c (lib):836
prefix_blen (const struct prefix *p)
{
  switch (p->family) 
Prefix.c (lib):854
/* Generic function for conversion string to struct prefix. */
int
str2prefix (const char *str, struct prefix *p)
{
  int ret;
Prefix.c (lib):883
  const struct prefix *p = pu.p;
  char buf[BUFSIZ];

Prefix.c (lib):904
  inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ);
  snprintf (str, size, "%s/%d", buf, p->prefixlen);
  return str;
Prefix.c (lib):909
struct prefix *
prefix_new ()
{
  struct prefix *p;

  p = XCALLOC (MTYPE_PREFIX, sizeof *p);
Prefix.c (lib):918
/* Free prefix structure. */
void
prefix_free (struct prefix *p)
{
  XFREE (MTYPE_PREFIX, p);
Prefix.c (lib):943
  destination = ntohl (p->prefix.s_addr);
  
  if (p->prefixlen == IPV4_MAX_PREFIXLEN);
Prefix.h (lib):51
 * A struct prefix contains an address family, a prefix length, and an
 * address.  This can represent either a 'network prefix' as defined
 * by CIDR, where the 'host bits' of the prefix are 0
 * (e.g. AF_INET:10.0.0.0/8), or an address and netmask
 * (e.g. AF_INET:10.0.0.9/8), such as might be configured on an
Prefix.h (lib):68
/* IPv4 and IPv6 unified prefix structure. */
struct prefix
{
  u_char family;
Prefix.h (lib):75
    u_char prefix;
    struct in_addr prefix4;
#ifdef HAVE_IPV6
Prefix.h (lib):91
/* IPv4 prefix structure. */
struct prefix_ipv4
{
Prefix.h (lib):96
  struct in_addr prefix __attribute__ ((aligned (8)));
};

/* IPv6 prefix structure. */
#ifdef HAVE_IPV6
struct prefix_ipv6
Prefix.h (lib):105
  struct in6_addr prefix __attribute__ ((aligned (8)));
};
#endif /* HAVE_IPV6 */
Prefix.h (lib):138
  uintptr_t prefix __attribute__ ((aligned (8)));
};

Prefix.h (lib):142
 * (w/o this, functions accepting all prefix types need casts on the caller
 * side, which strips type safety since the cast will accept any pointer
 * type.)
Prefix.h (lib):148
  struct prefix *p;
  struct prefix_ipv4 *p4;
  struct prefix_ipv6 *p6;
Prefix.h (lib):155
  const struct prefix *p;
  const struct prefix_ipv4 *p4;
  const struct prefix_ipv6 *p6;
Prefix.h (lib):172
/* Maximum prefix string length (IPv6) */
#define PREFIX_STRLEN 51

Prefix.h (lib):196
/* Count prefix size from mask length */
#define PSIZE(a) (((a) + 7) / (8))

Prefix.h (lib):219
/* Check bit of the prefix. */
extern unsigned int prefix_bit (const u_char *prefix, const u_char prefixlen);
extern unsigned int prefix6_bit (const struct in6_addr *prefix, const u_char prefixlen);

extern struct prefix *prefix_new (void);
extern void prefix_free (struct prefix *);
extern const char *prefix_family_str (const struct prefix *);
extern int prefix_blen (const struct prefix *);
extern int str2prefix (const char *, struct prefix *);
extern const char *prefix2str (union prefix46constptr, char *, int);
extern int prefix_match (const struct prefix *, const struct prefix *);
extern int prefix_same (const struct prefix *, const struct prefix *);
extern int prefix_cmp (const struct prefix *, const struct prefix *);
extern int prefix_common_bits (const struct prefix *, const struct prefix *);
extern void prefix_copy (struct prefix *dest, const struct prefix *src);
extern void apply_mask (struct prefix *);

extern struct prefix *sockunion2prefix (const union sockunion *dest,
                                        const union sockunion *mask);
extern struct prefix *sockunion2hostprefix (const union sockunion *, struct prefix *p);
extern void prefix2sockunion (const struct prefix *, union sockunion *);

extern int str2prefix_eth (const char *, struct prefix_eth *);
Qpb.h (qpb):33
#include "prefix.h"

#include "qpb/qpb.pb-c.h"
Qpb.h (qpb):91
qpb__l3_prefix__create (qpb_allocator_t *allocator, struct prefix *p)
{
  Qpb__L3Prefix *prefix;

  prefix = QPB_ALLOC(allocator, typeof(*prefix));
  if (!prefix) {
    return NULL;
  }
  qpb__l3_prefix__init(prefix);
  prefix->length = p->prefixlen;
  prefix->bytes.len = (p->prefixlen + 7)/8;
  prefix->bytes.data = qpb_alloc(allocator, prefix->bytes.len);
  if (!prefix->bytes.data) {
    return NULL;
  }
Qpb.h (qpb):107
  memcpy(prefix->bytes.data, &p->u.prefix, prefix->bytes.len);

  return prefix;
}

Qpb.h (qpb):118
		     struct prefix *prefix)
{

Qpb.h (qpb):125
      memset(prefix, 0, sizeof(struct prefix_ipv4));
      break;

Qpb.h (qpb):129
      memset(prefix, 0, sizeof(struct prefix_ipv6));
      break;

Qpb.h (qpb):133
      memset(prefix, 0, sizeof(*prefix));
    }

  prefix->prefixlen = pb_prefix->length;
  prefix->family = family;
  memcpy(&prefix->u.prefix, pb_prefix->bytes.data, pb_prefix->bytes.len);
  return 1;
}
README.txt (solaris):27
	./configure --prefix=/usr/local/quagga \
		--localstatedir=/var/run/quagga
		--enable-gcc-rdynamic --enable-opaque-lsa --enable-ospf-te \
Redistribute.c (zebra):27
#include "prefix.h"
#include "table.h"
#include "stream.h"
Redistribute.c (zebra):45
zebra_check_addr (struct prefix *p)
{
  if (p->family == AF_INET)
Redistribute.c (zebra):72
is_default (struct prefix *p)
{
  if (p->family == AF_INET)
Redistribute.c (zebra):108
      rn = route_node_lookup (table, (struct prefix *)&p);
      if (rn)
	{
Redistribute.c (zebra):128
      rn = route_node_lookup (table, (struct prefix *)&p6);
      if (rn)
	{
Redistribute.c (zebra):185
redistribute_add (struct prefix *p, struct rib *rib)
{
  struct listnode *node, *nnode;
Redistribute.c (zebra):211
redistribute_delete (struct prefix *p, struct rib *rib)
{
  struct listnode *node, *nnode;
Redistribute.c (zebra):360
  struct prefix *p;

  if (IS_ZEBRA_DEBUG_EVENT)
Redistribute.c (zebra):392
  struct prefix *p;

  if (IS_ZEBRA_DEBUG_EVENT)
Redistribute.h (zebra):37
extern void redistribute_add (struct prefix *, struct rib *);
extern void redistribute_delete (struct prefix *, struct rib *);

extern void zebra_interface_up_update (struct interface *);
Redistribute.h (zebra):53
extern int zebra_check_addr (struct prefix *);

extern int is_default (struct prefix *);

#endif /* _ZEBRA_REDISTRIBUTE_H */
Redistribute_null.c (zebra):47
void redistribute_add (struct prefix *a, struct rib *b)
{ return; }
#ifdef HAVE_SYS_WEAK_ALIAS_PRAGMA
Redistribute_null.c (zebra):52
void redistribute_delete (struct prefix *a, struct rib *b)
{ return; }
#endif
Rib.h (zebra):28
#include "prefix.h"
#include "table.h"
#include "queue.h"
Rib.h (zebra):105
 * Structure that represents a single destination (prefix).
 */
typedef struct rib_dest_t_
Rib.h (zebra):112
   * us get to the prefix that this structure is for.
   */
  struct route_node *rnode;
Rib.h (zebra):117
   * Doubly-linked list of routes for this prefix.
   */
  struct rib *routes;
Rib.h (zebra):141
 * This flag indicates that a given prefix has been 'advertised' to
 * the FPM to be installed in the forwarding plane.
 */
Rib.h (zebra):153
 * Macro to iterate over each route for a destination (prefix).
 */
#define RIB_DEST_FOREACH_ROUTE(dest, rib)				\
Rib.h (zebra):323
  struct prefix rid_user_assigned;

#if defined (HAVE_RTADV)
Rib.h (zebra):378
  MCAST_MIX_PFXLEN,	/* MRIB & URIB, longer prefix wins */
			/* on equal value, MRIB wins for last 2 */
};
Rib.h (zebra):400
#define rib_dump(prefix ,rib) _rib_dump(__func__, prefix, rib)
extern void _rib_dump (const char *,
		       union prefix46constptr, const struct rib *);
Rib.h (zebra):422
 * All rib_add_ipv[46]* functions will not just add prefix into RIB, but
 * also implicitly withdraw equal prefix of same type. */
extern int rib_add_ipv4 (int type, int flags, struct prefix_ipv4 *p, 
			 struct in_addr *gate, struct in_addr *src,
Rib.h (zebra):453
static_add_ipv4_safi (safi_t safi, struct prefix *p, struct in_addr *gate,
		      const char *ifname, u_char flags, route_tag_t, 
		      u_char distance, vrf_id_t vrf_id);
Rib.h (zebra):457
static_delete_ipv4_safi (safi_t safi, struct prefix *p, struct in_addr *gate,
			 const char *ifname, route_tag_t tag, u_char distance,
			 vrf_id_t vrf_id);
Rib.h (zebra):478
static_add_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
		 const char *ifname, u_char flags, route_tag_t, 
		 u_char distance, vrf_id_t vrf_id);
Rib.h (zebra):486
static_delete_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
		    const char *ifname, route_tag_t, u_char distance, 
		    vrf_id_t vrf_id);
Rib.h (zebra):536
static inline struct prefix *
rib_dest_prefix (rib_dest_t *dest)
{
Ripd.c (ripd):27
#include "prefix.h"
#include "table.h"
#include "thread.h"
Ripd.c (ripd):331
			     (struct prefix *) p) == FILTER_DENY)
	{
	  if (IS_RIP_DEBUG_PACKET)
Ripd.c (ripd):335
                        inet_ntoa (p->prefix), p->prefixlen, inout);
	  return -1;
	}
Ripd.c (ripd):339
  if (ri->prefix[rip_distribute])
    {
      if (prefix_list_apply (ri->prefix[rip_distribute],
			     (struct prefix *) p) == PREFIX_DENY)
	{
	  if (IS_RIP_DEBUG_PACKET)
	    zlog_debug ("%s/%d filtered by prefix-list %s",
                        inet_ntoa (p->prefix), p->prefixlen, inout);
	  return -1;
	}
Ripd.c (ripd):361
	      if (access_list_apply (alist, (struct prefix *) p) == FILTER_DENY)
		{
		  if (IS_RIP_DEBUG_PACKET)
Ripd.c (ripd):365
                                inet_ntoa (p->prefix), p->prefixlen, inout);
		  return -1;
		}
Ripd.c (ripd):370
      if (dist->prefix[distribute])
	{
	  plist = prefix_list_lookup (AFI_IP, dist->prefix[distribute]);

	  if (plist)
Ripd.c (ripd):377
				     (struct prefix *) p) == PREFIX_DENY)
		{
		  if (IS_RIP_DEBUG_PACKET)
		    zlog_debug ("%s/%d filtered by prefix-list %s",
                                inet_ntoa (p->prefix), p->prefixlen, inout);
		  return -1;
		}
Ripd.c (ripd):398
  struct prefix *p;

  /* If nexthop address matches local configured address then it is
Ripd.c (ripd):432
  /* Make prefix structure. */
  memset (&p, 0, sizeof (struct prefix_ipv4));
  p.family = AF_INET;
  p.prefix = rte->prefix;
  p.prefixlen = ip_masklen (rte->mask);

Ripd.c (ripd):465
                             (struct prefix *) &p, RMAP_RIP, &newinfo);

      if (ret == RMAP_DENYMATCH)
Ripd.c (ripd):471
                       inet_ntoa (p.prefix), p.prefixlen);
          return;
        }
Ripd.c (ripd):510
  /* Get index for the prefix. */
  rp = route_node_get (rip->table, (struct prefix *) &p);

  newinfo.rp = rp;
Ripd.c (ripd):607
         for the destination prefix.  If there is no such route, add
         this route to the routing table, unless the metric is
         infinity (there is no point in adding a route which
Ripd.c (ripd):722
		  p = (u_char *)&rte->prefix;

		  zlog_debug ("  family 0x%X type %d auth string: %s",
Ripd.c (ripd):744
		  p = (u_char *)&rte->prefix;

		  zlog_debug ("  family 0x%X type %d (MD5 data)",
Ripd.c (ripd):762
                       inet_ntop (AF_INET, &rte->prefix, pbuf, BUFSIZ),
                       netmask, inet_ntop (AF_INET, &rte->nexthop, nbuf,
                                           BUFSIZ), ntohs (rte->family),
Ripd.c (ripd):770
		     inet_ntop (AF_INET, &rte->prefix, pbuf, BUFSIZ),
		     ntohs (rte->family), ntohs (rte->tag),
		     (u_long)ntohl (rte->metric));
Ripd.c (ripd):827
      auth_str = (char *) &rte->prefix;
	  
      if (strncmp (auth_str, ri->auth_str, 16) == 0)
Ripd.c (ripd):841
      key = key_match_for_accept (keychain, (char *) &rte->prefix);
      if (key)
	return 1;
Ripd.c (ripd):1163
      if (! rip_destination_check (rte->prefix))
        {
	  zlog_info ("Network is net 0 or net 127 or it is not unicast network");
Ripd.c (ripd):1254
      if ((packet->version == RIPv1 && rte->prefix.s_addr != 0) 
	  || (packet->version == RIPv2 
	      && (rte->prefix.s_addr != 0 && rte->mask.s_addr == 0)))
	{
	  u_int32_t destination;
Ripd.c (ripd):1270
	  destination = ntohl (rte->prefix.s_addr);

	  if (IN_CLASSA (destination))
Ripd.c (ripd):1282
	  if ((subnetted == 1) && ((rte->prefix.s_addr & destination) ==
	      ifaddrclass.prefix.s_addr))
	    {
	      masklen2ip (ifaddr.prefixlen, &rte->mask);
	      if ((rte->prefix.s_addr & rte->mask.s_addr) != rte->prefix.s_addr)
		masklen2ip (32, &rte->mask);
	      if (IS_RIP_DEBUG_EVENT)
		zlog_debug ("Subnetted route %s", inet_ntoa (rte->prefix));
	    }
	  else
Ripd.c (ripd):1293
	      if ((rte->prefix.s_addr & rte->mask.s_addr) != rte->prefix.s_addr)
		continue;
	    }
Ripd.c (ripd):1299
	      zlog_debug ("Resultant route %s", inet_ntoa (rte->prefix));
	      zlog_debug ("Resultant mask %s", inet_ntoa (rte->mask));
	    }
Ripd.c (ripd):1304
      /* In case of RIPv2, if prefix in RTE is not netmask applied one
         ignore the entry.  */
      if ((packet->version == RIPv2) 
Ripd.c (ripd):1308
	  && ((rte->prefix.s_addr & rte->mask.s_addr) != rte->prefix.s_addr))
	{
	  zlog_warn ("RIPv2 address %s is not mask /%d applied one",
		     inet_ntoa (rte->prefix), ip_masklen (rte->mask));
	  rip_peer_bad_route (from);
	  continue;
Ripd.c (ripd):1319
          && (rte->prefix.s_addr != 0))
        {
          if (IS_RIP_DEBUG_EVENT)
Ripd.c (ripd):1524
  ret = rip_destination_check (p->prefix);
  if (! ret)
    return;
Ripd.c (ripd):1528
  rp = route_node_get (rip->table, (struct prefix *) p);

  memset (&newinfo, 0, sizeof (struct rip_info));
Ripd.c (ripd):1576
      zlog_debug ("Redistribute new prefix %s/%d on the interface %s",
                 inet_ntoa(p->prefix), p->prefixlen,
                 ifindex2ifname(ifindex));
    else
      zlog_debug ("Redistribute new prefix %s/%d with nexthop %s on the interface %s",
                 inet_ntoa(p->prefix), p->prefixlen, inet_ntoa(rinfo->nexthop),
                 ifindex2ifname(ifindex));
  }
Ripd.c (ripd):1597
  ret = rip_destination_check (p->prefix);
  if (! ret)
    return;
Ripd.c (ripd):1601
  rp = route_node_lookup (rip->table, (struct prefix *) p);
  if (rp)
    {
Ripd.c (ripd):1624
                            inet_ntoa(p->prefix), p->prefixlen,
                            ifindex2ifname(ifindex));

Ripd.c (ripd):1695
	  p.prefix = rte->prefix;
	  p.prefixlen = ip_masklen (rte->mask);
	  apply_mask_ipv4 (&p);
Ripd.c (ripd):1699
	  rp = route_node_lookup (rip->table, (struct prefix *) &p);
	  if (rp)
	    {
Ripd.c (ripd):2096
      stream_put_ipv4 (s, p->prefix.s_addr);
      stream_put_ipv4 (s, 0);
      stream_put_ipv4 (s, 0);
Ripd.c (ripd):2107
      stream_put_ipv4 (s, p->prefix.s_addr);
      stream_put_ipv4 (s, mask.s_addr);
      stream_put_ipv4 (s, rinfo->nexthop_out.s_addr);
Ripd.c (ripd):2212
		prefix_match ((struct prefix *) &ifaddrclass, &rp->p))
	      {
		if ((ifc->address->prefixlen != rp->p.prefixlen) &&
Ripd.c (ripd):2252
             * we suppress the route if the prefix is a subset of the
             * source address that we are going to use for the packet 
             * (in order to handle the case when multiple subnets are
Ripd.c (ripd):2269
                 prefix_match((struct prefix *)p, ifc->address))
	      suppress = 1;

Ripd.c (ripd):2297
				     (struct prefix *) p, RMAP_RIP, 
				     rinfo);

Ripd.c (ripd):2304
			     inet_ntoa (p->prefix), p->prefixlen);
                continue;
	      }
Ripd.c (ripd):2314
				   (struct prefix *)p, RMAP_RIP, rinfo);

	    if (ret == RMAP_DENYMATCH) 
Ripd.c (ripd):2320
			     inet_ntoa (p->prefix), p->prefixlen);
		continue;
	      }
Ripd.c (ripd):2361
             * we suppress the route if the prefix is a subset of the
             * source address that we are going to use for the packet 
             * (in order to handle the case when multiple subnets are
Ripd.c (ripd):2374
                prefix_match((struct prefix *)p, ifc->address))
	        rinfo->metric_out = RIP_METRIC_INFINITY;
            }
Ripd.c (ripd):2538
	ifp = if_lookup_address (p->prefix);
	if (! ifp)
	  {
Ripd.c (ripd):2542
		       inet_ntoa (p->prefix));
	    continue;
	  }
Ripd.c (ripd):2546
        if ( (connected = connected_lookup_address (ifp, p->prefix)) == NULL)
          {
            zlog_warn ("Neighbor %s doesnt have connected network",
                       inet_ntoa (p->prefix));
            continue;
          }
Ripd.c (ripd):2555
	to.sin_addr = p->prefix;
	to.sin_port = htons (RIP_PORT_DEFAULT);

Ripd.c (ripd):2696
                         inet_ntoa(p->prefix), p->prefixlen,
                         ifindex2ifname(rinfo->ifindex));
	    }
Ripd.c (ripd):2921
       "IP prefix <network>/<length>\n")
{
  int ret;
Ripd.c (ripd):2936
  node = route_node_get (rip->route, (struct prefix *) &p);

  if (node->info)
Ripd.c (ripd):2957
       "IP prefix <network>/<length>\n")
{
  int ret;
Ripd.c (ripd):2972
  node = route_node_lookup (rip->route, (struct prefix *) &p);
  if (! node)
    {
Ripd.c (ripd):3123
  /* Distance value for the IP source prefix. */
  u_char distance;

Ripd.c (ripd):3155
      vty_out (vty, "Malformed prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Ripd.c (ripd):3162
  rn = route_node_get (rip_distance_table, (struct prefix *) &p);
  if (rn->info)
    {
Ripd.c (ripd):3201
      vty_out (vty, "Malformed prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Ripd.c (ripd):3205
  rn = route_node_lookup (rip_distance_table, (struct prefix *)&p);
  if (! rn)
    {
      vty_out (vty, "Can't find specified prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Ripd.c (ripd):3256
  p.prefix = rinfo->from;
  p.prefixlen = IPV4_MAX_BITLEN;

Ripd.c (ripd):3260
  rn = route_node_match (rip_distance_table, (struct prefix *) &p);
  if (rn)
    {
Ripd.c (ripd):3341
       "IP source prefix\n")
{
  rip_distance_set (vty, argv[0], argv[1], NULL);
Ripd.c (ripd):3353
       "IP source prefix\n")
{
  rip_distance_unset (vty, argv[0], argv[1], NULL);
Ripd.c (ripd):3364
       "IP source prefix\n"
       "Access list name\n")
{
Ripd.c (ripd):3377
       "IP source prefix\n"
       "Access list name\n")
{
Ripd.c (ripd):3757
      /* RIP source IP prefix distance configuration. */
      for (rn = route_top (rip_distance_table); rn; rn = route_next (rn))
	if ((rdistance = rn->info) != NULL)
Ripd.c (ripd):3829
  if (dist->prefix[DISTRIBUTE_V4_IN])
    {
      plist = prefix_list_lookup (AFI_IP, dist->prefix[DISTRIBUTE_V4_IN]);
      if (plist)
	ri->prefix[RIP_FILTER_IN] = plist;
      else
	ri->prefix[RIP_FILTER_IN] = NULL;
    }
  else
    ri->prefix[RIP_FILTER_IN] = NULL;

  if (dist->prefix[DISTRIBUTE_V4_OUT])
    {
      plist = prefix_list_lookup (AFI_IP, dist->prefix[DISTRIBUTE_V4_OUT]);
      if (plist)
	ri->prefix[RIP_FILTER_OUT] = plist;
      else
	ri->prefix[RIP_FILTER_OUT] = NULL;
    }
  else
    ri->prefix[RIP_FILTER_OUT] = NULL;
}

Ripd.h (ripd):164
  struct in_addr prefix;	/* Prefix of rip route. */
  struct in_addr mask;		/* Netmask of rip route. */
  struct in_addr nexthop;	/* Next hop of rip route. */
Ripd.h (ripd):284
  struct prefix_list *prefix[RIP_FILTER_MAX];

  /* Route-map. */
Ripngd.c (ripngd):24
#include "prefix.h"
#include "filter.h"
#include "log.h"
Ripngd.c (ripngd):342
   The route tag and prefix length in the next hop RTE must be
   set to zero on sending and ignored on receiption.  */
  if (ntohs (rte->tag) != 0)
Ripngd.c (ripngd):352
  /* Specifying a value of 0:0:0:0:0:0:0:0 in the prefix field of a
   next hop RTE indicates that the next hop address should be the
   originator of the RIPng advertisement.  An address specified as a
Ripngd.c (ripngd):393
  struct prefix *p;

  for (ALL_LIST_ELEMENTS_RO (ifp->connected, node, connected))
Ripngd.c (ripngd):625
			     (struct prefix *) p) == FILTER_DENY)
	{
	  if (IS_RIPNG_DEBUG_PACKET)
Ripngd.c (ripngd):629
                        inet6_ntoa (p->prefix), p->prefixlen, inout);
	  return -1;
	}
Ripngd.c (ripngd):633
  if (ri->prefix[ripng_distribute])
    {
      if (prefix_list_apply (ri->prefix[ripng_distribute],
			     (struct prefix *) p) == PREFIX_DENY)
	{
	  if (IS_RIPNG_DEBUG_PACKET)
	    zlog_debug ("%s/%d filtered by prefix-list %s",
                        inet6_ntoa (p->prefix), p->prefixlen, inout);
	  return -1;
	}
Ripngd.c (ripngd):656
				     (struct prefix *) p) == FILTER_DENY)
		{
		  if (IS_RIPNG_DEBUG_PACKET)
Ripngd.c (ripngd):660
                                inet6_ntoa (p->prefix), p->prefixlen, inout);
		  return -1;
		}
Ripngd.c (ripngd):665
      if (dist->prefix[distribute])
	{
	  plist = prefix_list_lookup (AFI_IP6, dist->prefix[distribute]);

	  if (plist)
Ripngd.c (ripngd):672
				     (struct prefix *) p) == PREFIX_DENY)
		{
		  if (IS_RIPNG_DEBUG_PACKET)
		    zlog_debug ("%s/%d filtered by prefix-list %s",
                                inet6_ntoa (p->prefix), p->prefixlen, inout);
		  return -1;
		}
Ripngd.c (ripngd):701
  /* Make prefix structure. */
  memset (&p, 0, sizeof (struct prefix_ipv6));
  p.family = AF_INET6;
  /* p.prefix = rte->addr; */
  IPV6_ADDR_COPY (&p.prefix, &rte->addr);
  p.prefixlen = rte->prefixlen;

Ripngd.c (ripngd):709
  /* XXX We have to check the prefix is valid or not before call
     apply_mask_ipv6. */
  apply_mask_ipv6 (&p);
Ripngd.c (ripngd):739
			     (struct prefix *)&p, RMAP_RIPNG, &newinfo);

      if (ret == RMAP_DENYMATCH)
Ripngd.c (ripngd):745
		       inet6_ntoa (p.prefix), p.prefixlen);
	  return;
	}
Ripngd.c (ripngd):795
  rp = route_node_get (ripng->table, (struct prefix *) &p);

  newinfo.rp = rp;
Ripngd.c (ripngd):859
	 for the destination prefix.  If there is no such route, add
	 this route to the routing table, unless the metric is
	 infinity (there is no point in adding a route which
Ripngd.c (ripngd):916
  if (IN6_IS_ADDR_LINKLOCAL (&p->prefix))
    return;
  if (IN6_IS_ADDR_LOOPBACK (&p->prefix))
    return;

  rp = route_node_get (ripng->table, (struct prefix *) p);

  memset (&newinfo, 0, sizeof (struct ripng_info));
Ripngd.c (ripngd):966
      zlog_debug ("Redistribute new prefix %s/%d on the interface %s",
                 inet6_ntoa(p->prefix), p->prefixlen,
                 ifindex2ifname(ifindex));
    else
      zlog_debug ("Redistribute new prefix %s/%d with nexthop %s on the interface %s",
                 inet6_ntoa(p->prefix), p->prefixlen, inet6_ntoa(*nexthop),
                 ifindex2ifname(ifindex));
  }
Ripngd.c (ripngd):986
  if (IN6_IS_ADDR_LINKLOCAL (&p->prefix))
    return;
  if (IN6_IS_ADDR_LOOPBACK (&p->prefix))
    return;

  rp = route_node_lookup (ripng->table, (struct prefix *) p);

  if (rp)
Ripngd.c (ripngd):1019
                            inet6_ntoa (p->prefix), p->prefixlen,
                            ifindex2ifname (ifindex));

Ripngd.c (ripngd):1062
	                 inet6_ntoa(p->prefix), p->prefixlen,
	                 ifindex2ifname(rinfo->ifindex));
	    }
Ripngd.c (ripngd):1150
      /* - is the destination prefix valid (e.g., not a multicast
         prefix and not a link-local address) A link-local address
         should never be present in an RTE. */
      if (IN6_IS_ADDR_MULTICAST (&rte->addr))
Ripngd.c (ripngd):1155
	  zlog_warn ("Destination prefix is a multicast address %s/%d [%d]",
		     inet6_ntoa (rte->addr), rte->prefixlen, rte->metric);
	  ripng_peer_bad_route (from);
Ripngd.c (ripngd):1162
	  zlog_warn ("Destination prefix is a link-local address %s/%d [%d]",
		     inet6_ntoa (rte->addr), rte->prefixlen, rte->metric);
	  ripng_peer_bad_route (from);
Ripngd.c (ripngd):1169
	  zlog_warn ("Destination prefix is a loopback address %s/%d [%d]",
		     inet6_ntoa (rte->addr), rte->prefixlen, rte->metric);
	  ripng_peer_bad_route (from);
Ripngd.c (ripngd):1175
      /* - is the prefix length valid (i.e., between 0 and 128,
         inclusive) */
      if (rte->prefixlen > 128)
Ripngd.c (ripngd):1179
	  zlog_warn ("Invalid prefix length %s/%d from %s%%%s",
		     inet6_ntoa (rte->addr), rte->prefixlen,
		     inet6_ntoa (from->sin6_addr), ifp->name);
Ripngd.c (ripngd):1241
     request, and it has a destination prefix of zero, a prefix length
     of zero, and a metric of infinity (i.e., 16), then this is a
     request to send the entire routing table.  In that case, a call
Ripngd.c (ripngd):1270
	  p.prefix = rte->addr;
	  p.prefixlen = rte->prefixlen;
	  apply_mask_ipv6 (&p);
Ripngd.c (ripngd):1274
	  rp = route_node_lookup (ripng->table, (struct prefix *) &p);

	  if (rp)
Ripngd.c (ripngd):1550
    stream_write (s, (u_char *) &p->prefix, sizeof (struct in6_addr));
  else
    stream_write (s, (u_char *) nexthop, sizeof (struct in6_addr));
Ripngd.c (ripngd):1654
				     (struct prefix *) p, RMAP_RIPNG, 
				     rinfo);

Ripngd.c (ripngd):1661
			       inet6_ntoa (p->prefix), p->prefixlen);
		  continue;
		}
Ripngd.c (ripngd):1673
				     (struct prefix *) p, RMAP_RIPNG,
				     rinfo);

Ripngd.c (ripngd):1680
			       inet6_ntoa (p->prefix), p->prefixlen);
		  continue;
		}
Ripngd.c (ripngd):1762
				     (struct prefix *) p, RMAP_RIPNG, 
				     &newinfo);

Ripngd.c (ripngd):1769
			       inet6_ntoa (p->prefix), p->prefixlen);
		  continue;
		}
Ripngd.c (ripngd):2012
			 inet6_ntoa (p->prefix), p->prefixlen);
#else
	  len = vty_out (vty, "R(a) %s/%d ", 
			 inet6_ntoa (p->prefix), p->prefixlen);
#endif /* DEBUG */
	  vty_out (vty, "%s", VTY_NEWLINE);
Ripngd.c (ripngd):2036
			 inet6_ntoa (p->prefix), p->prefixlen);
#else
	  len = vty_out (vty, "%c(%s) %s/%d ",
Ripngd.c (ripngd):2041
			 inet6_ntoa (p->prefix), p->prefixlen);
#endif /* DEBUG */
	  vty_out (vty, "%s", VTY_NEWLINE);
Ripngd.c (ripngd):2211
  rp = route_node_get (ripng->route, (struct prefix *) &p);
  if (rp->info)
    {
Ripngd.c (ripngd):2244
  rp = route_node_lookup (ripng->route, (struct prefix *) &p);
  if (! rp)
    {
Ripngd.c (ripngd):2267
  struct prefix p;
  struct route_node *node;

Ripngd.c (ripngd):2300
  struct prefix p;
  struct route_node *rn;

Ripngd.c (ripngd):2785
  if (dist->prefix[DISTRIBUTE_V6_IN])
    {
      plist = prefix_list_lookup (AFI_IP6, dist->prefix[DISTRIBUTE_V6_IN]);
      if (plist)
	ri->prefix[RIPNG_FILTER_IN] = plist;
      else
	ri->prefix[RIPNG_FILTER_IN] = NULL;
    }
  else
    ri->prefix[RIPNG_FILTER_IN] = NULL;

  if (dist->prefix[DISTRIBUTE_V6_OUT])
    {
      plist = prefix_list_lookup (AFI_IP6, dist->prefix[DISTRIBUTE_V6_OUT]);
      if (plist)
	ri->prefix[RIPNG_FILTER_OUT] = plist;
      else
	ri->prefix[RIPNG_FILTER_OUT] = NULL;
    }
  else
    ri->prefix[RIPNG_FILTER_OUT] = NULL;
}

Ripngd.h (ripngd):148
  struct in6_addr addr;	/* RIPng destination prefix */
  u_int16_t tag;		/* RIPng tag */
  u_char prefixlen;	/* Length of the RIPng prefix */
  u_char metric;	/* Metric of the RIPng route */
  			/* The nexthop is stored by the structure
Ripngd.h (ripngd):266
  struct prefix_list *prefix[RIPNG_FILTER_MAX];

  /* Route-map. */
Ripng_interface.c (ripngd):27
#include "prefix.h"
#include "memory.h"
#include "network.h"
Ripng_interface.c (ripngd):150
      struct prefix *p;
      p = connected->address;

Ripng_interface.c (ripngd):349
      ri->prefix[RIPNG_FILTER_IN] = NULL;
      ri->prefix[RIPNG_FILTER_OUT] = NULL;

      if (ri->t_wakeup)
Ripng_interface.c (ripngd):365
  struct prefix *p;

  if (!ripng)
Ripng_interface.c (ripngd):377
  address.prefix = p->u.prefix6;
  address.prefixlen = p->prefixlen;
  apply_mask_ipv6(&address);
Ripng_interface.c (ripngd):382
     or  Check if this address's prefix is RIP enabled */
  if ((ripng_enable_if_lookup(ifc->ifp->name) >= 0) ||
      (ripng_enable_network_lookup2(ifc) >= 0))
Ripng_interface.c (ripngd):395
  struct prefix *p;

  c = zebra_interface_address_read (ZEBRA_INTERFACE_ADDRESS_ADD, 
Ripng_interface.c (ripngd):414
      /* Check is this prefix needs to be redistributed. */
      ripng_apply_address_add(c);

Ripng_interface.c (ripngd):437
  struct prefix *p;

  if (!ripng)
Ripng_interface.c (ripngd):449
  address.prefix = p->u.prefix6;
  address.prefixlen = p->prefixlen;
  apply_mask_ipv6(&address);
Ripng_interface.c (ripngd):462
  struct prefix *p;
  char buf[INET6_ADDRSTRLEN];

Ripng_interface.c (ripngd):480
	  /* Check wether this prefix needs to be removed. */
	  ripng_apply_address_del(ifc);
	}
Ripng_interface.c (ripngd):496
/* Check wether the interface has at least a connected prefix that
 * is within the ripng_enable_network table. */
static int
Ripng_interface.c (ripngd):507
      struct prefix *p; 
      struct route_node *node;

Ripng_interface.c (ripngd):515
          address.prefix = p->u.prefix6;
          address.prefixlen = IPV6_MAX_BITLEN;

Ripng_interface.c (ripngd):519
                                   (struct prefix *)&address);
          if (node)
            {
Ripng_interface.c (ripngd):535
  struct prefix *p;

  p = connected->address;
Ripng_interface.c (ripngd):543
    address.prefix = p->u.prefix6;
    address.prefixlen = IPV6_MAX_BITLEN;

Ripng_interface.c (ripngd):548
                             (struct prefix *)&address);

    if (node) {
Ripng_interface.c (ripngd):561
ripng_enable_network_add (struct prefix *p)
{
  struct route_node *node;
Ripng_interface.c (ripngd):583
ripng_enable_network_delete (struct prefix *p)
{
  struct route_node *node;
Ripng_interface.c (ripngd):691
      struct prefix *p;
      p = connected->address;

Ripng_interface.c (ripngd):698
      address.prefix = p->u.prefix6;
      address.prefixlen = p->prefixlen;
      apply_mask_ipv6 (&address);
Ripng_interface.c (ripngd):703
        /* Check once more wether this prefix is within a "network IF_OR_PREF" one */
        if ((ripng_enable_if_lookup(connected->ifp->name) >= 0) ||
            (ripng_enable_network_lookup2(connected) >= 0))
Ripng_interface.c (ripngd):923
	struct prefix *p = &node->p;
	vty_out (vty, "%s%s/%d%s", 
		 config_mode ? " network " : "    ",
		 inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
		 p->prefixlen,
		 VTY_NEWLINE);
Ripng_interface.c (ripngd):957
  struct prefix p;

  ret = str2prefix (argv[0], &p);
Ripng_interface.c (ripngd):986
  struct prefix p;

  ret = str2prefix (argv[0], &p);
Ripng_main.c (ripngd):33
#include "prefix.h"
#include "if.h"
#include "privs.h"
Ripng_nexthop.c (ripngd):37
#include "prefix.h"

#include "ripngd/ripngd.h"
Ripng_offset.c (ripngd):29
#include "prefix.h"
#include "filter.h"
#include "command.h"
Ripng_offset.c (ripngd):227
	  && access_list_apply (alist, (struct prefix *)p) == FILTER_PERMIT)
	{
	  *metric += OFFSET_LIST_IN_METRIC (offset);
Ripng_offset.c (ripngd):241
	  && access_list_apply (alist, (struct prefix *)p) == FILTER_PERMIT)
	{
	  *metric += OFFSET_LIST_IN_METRIC (offset);
Ripng_offset.c (ripngd):266
	  && access_list_apply (alist, (struct prefix *)p) == FILTER_PERMIT)
	{
	  *metric += OFFSET_LIST_OUT_METRIC (offset);
Ripng_offset.c (ripngd):281
	  && access_list_apply (alist, (struct prefix *)p) == FILTER_PERMIT)
	{
	  *metric += OFFSET_LIST_OUT_METRIC (offset);
Ripng_peer.c (ripngd):29
#include "prefix.h"
#include "command.h"
#include "linklist.h"
Ripng_route.c (ripngd):25
#include "prefix.h"
#include "table.h"
#include "memory.h"
Ripng_route.c (ripngd):98
ripng_aggregate_add (struct prefix *p)
{
  struct route_node *top;
Ripng_route.c (ripngd):140
ripng_aggregate_delete (struct prefix *p)
{
  struct route_node *top;
Ripng_route.h (ripngd):53
extern int ripng_aggregate_add (struct prefix *p);
extern int ripng_aggregate_delete (struct prefix *p);
extern void ripng_aggregate_free (struct ripng_aggregate *aggregate);

Ripng_routemap.c (ripngd):26
#include "prefix.h"
#include "routemap.h"
#include "command.h"
Ripng_routemap.c (ripngd):137
route_match_metric (void *rule, struct prefix *prefix, 
		    route_map_object_t type, void *object)
{
Ripng_routemap.c (ripngd):191
route_match_interface (void *rule, struct prefix *prefix,
		       route_map_object_t type, void *object)
{
Ripng_routemap.c (ripngd):240
route_match_tag (void *rule, struct prefix *prefix, 
		    route_map_object_t type, void *object)
{
Ripng_routemap.c (ripngd):272
route_set_metric (void *rule, struct prefix *prefix, 
		  route_map_object_t type, void *object)
{
Ripng_routemap.c (ripngd):372
route_set_ipv6_nexthop_local (void *rule, struct prefix *prefix, 
		      route_map_object_t type, void *object)
{
Ripng_routemap.c (ripngd):432
route_set_tag (void *rule, struct prefix *prefix, 
		      route_map_object_t type, void *object)
{
Ripng_zebra.c (ripngd):26
#include "prefix.h"
#include "table.h"
#include "stream.h"
Ripng_zebra.c (ripngd):154
  /* IPv6 prefix. */
  memset (&p, 0, sizeof (struct prefix_ipv6));
  p.family = AF_INET6;
Ripng_zebra.c (ripngd):159
  stream_get (&p.prefix, s, PSIZE (p.prefixlen));

  /* Nexthop, ifindex, distance, metric. */
Rip_interface.c (ripd):27
#include "prefix.h"
#include "memory.h"
#include "network.h"
Rip_interface.c (ripd):283
	  if (ipv4_multicast_join (sock, group, p->prefix, ifp->ifindex) < 0)
	    return -1;
	  else
Rip_interface.c (ripd):315
          if (ipv4_multicast_leave (sock, group, p->prefix, ifp->ifindex) == 0)
	    return;
        }
Rip_interface.c (ripd):331
      struct prefix *p;

      p = connected->address;
Rip_interface.c (ripd):366
	  if (IPV4_ADDR_CMP (&p->prefix, &addr) == 0)
	    return 1;
	}
Rip_interface.c (ripd):548
  ri->prefix[RIP_FILTER_IN] = NULL;
  ri->prefix[RIP_FILTER_OUT] = NULL;
  
  ri->recv_badpackets = 0;
Rip_interface.c (ripd):616
  struct prefix *p;

  if (!rip)
Rip_interface.c (ripd):628
  address.prefix = p->u.prefix4;
  address.prefixlen = p->prefixlen;
  apply_mask_ipv4(&address);
Rip_interface.c (ripd):633
     or  Check if this address's prefix is RIP enabled */
  if ((rip_enable_if_lookup(ifc->ifp->name) >= 0) ||
      (rip_enable_network_lookup2(ifc) >= 0))
Rip_interface.c (ripd):646
  struct prefix *p;

  ifc = zebra_interface_address_read (ZEBRA_INTERFACE_ADDRESS_ADD, 
Rip_interface.c (ripd):663
      /* Check if this prefix needs to be redistributed */
      rip_apply_address_add(ifc);

Rip_interface.c (ripd):677
  struct prefix *p;

  if (!rip)
Rip_interface.c (ripd):689
  address.prefix = p->u.prefix4;
  address.prefixlen = p->prefixlen;
  apply_mask_ipv4(&address);
Rip_interface.c (ripd):702
  struct prefix *p;

  ifc = zebra_interface_address_read (ZEBRA_INTERFACE_ADDRESS_DELETE,
Rip_interface.c (ripd):720
	  /* Chech wether this prefix needs to be removed */
          rip_apply_address_del(ifc);

Rip_interface.c (ripd):733
/* Check wether the interface has at least a connected prefix that
 * is within the ripng_enable_network table. */
static int
Rip_interface.c (ripd):744
      struct prefix *p; 
      struct route_node *node;

Rip_interface.c (ripd):752
          address.prefix = p->u.prefix4;
          address.prefixlen = IPV4_MAX_BITLEN;
          
Rip_interface.c (ripd):756
                                   (struct prefix *)&address);
          if (node)
            {
Rip_interface.c (ripd):772
  struct prefix *p;

  p = connected->address;
Rip_interface.c (ripd):780
    address.prefix = p->u.prefix4;
    address.prefixlen = IPV4_MAX_BITLEN;

Rip_interface.c (ripd):785
                             (struct prefix *)&address);

    if (node) {
Rip_interface.c (ripd):797
rip_enable_network_add (struct prefix *p)
{
  struct route_node *node;
Rip_interface.c (ripd):819
rip_enable_network_delete (struct prefix *p)
{
  struct route_node *node;
Rip_interface.c (ripd):931
      struct prefix *p; 
      p = connected->address;

Rip_interface.c (ripd):938
      address.prefix = p->u.prefix4;
      address.prefixlen = p->prefixlen;
      apply_mask_ipv4 (&address);
Rip_interface.c (ripd):943
        /* Check once more wether this prefix is within a "network IF_OR_PREF" one */
        if ((rip_enable_if_lookup(connected->ifp->name) >= 0) ||
            (rip_enable_network_lookup2(connected) >= 0))
Rip_interface.c (ripd):1045
  p.prefix = from->sin_addr;
  p.prefixlen = IPV4_MAX_BITLEN;

  node = route_node_lookup (rip->neighbor, (struct prefix *) &p);
  if (node)
    {
Rip_interface.c (ripd):1063
  node = route_node_get (rip->neighbor, (struct prefix *) p);

  if (node->info)
Rip_interface.c (ripd):1080
  node = route_node_lookup (rip->neighbor, (struct prefix *) p);
  if (! node)
    return -1;
Rip_interface.c (ripd):1212
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Interface name\n")
{
Rip_interface.c (ripd):1221
    ret = rip_enable_network_add ((struct prefix *) &p);
  else
    ret = rip_enable_if_add (argv[0]);
Rip_interface.c (ripd):1241
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Interface name\n")
{
Rip_interface.c (ripd):1250
    ret = rip_enable_network_delete ((struct prefix *) &p);
  else
    ret = rip_enable_if_delete (argv[0]);
Rip_main.c (ripd):29
#include "prefix.h"
#include "filter.h"
#include "keychain.h"
Rip_offset.c (ripd):25
#include "prefix.h"
#include "filter.h"
#include "command.h"
Rip_offset.c (ripd):219
	  && access_list_apply (alist, (struct prefix *)p) == FILTER_PERMIT)
	{
	  *metric += OFFSET_LIST_IN_METRIC (offset);
Rip_offset.c (ripd):233
	  && access_list_apply (alist, (struct prefix *)p) == FILTER_PERMIT)
	{
	  *metric += OFFSET_LIST_IN_METRIC (offset);
Rip_offset.c (ripd):258
	  && access_list_apply (alist, (struct prefix *)p) == FILTER_PERMIT)
	{
	  *metric += OFFSET_LIST_OUT_METRIC (offset);
Rip_offset.c (ripd):273
	  && access_list_apply (alist, (struct prefix *)p) == FILTER_PERMIT)
	{
	  *metric += OFFSET_LIST_OUT_METRIC (offset);
Rip_peer.c (ripd):25
#include "prefix.h"
#include "command.h"
#include "linklist.h"
Rip_routemap.c (ripd):26
#include "prefix.h"
#include "routemap.h"
#include "command.h"
Rip_routemap.c (ripd):167
route_match_metric (void *rule, struct prefix *prefix, 
		    route_map_object_t type, void *object)
{
Rip_routemap.c (ripd):226
route_match_interface (void *rule, struct prefix *prefix,
		       route_map_object_t type, void *object)
{
Rip_routemap.c (ripd):279
route_match_ip_next_hop (void *rule, struct prefix *prefix,
			route_map_object_t type, void *object)
{
Rip_routemap.c (ripd):290
      p.prefix = (rinfo->nexthop.s_addr) ? rinfo->nexthop : rinfo->from;
      p.prefixlen = IPV4_MAX_BITLEN;

Rip_routemap.c (ripd):327
/* `match ip next-hop prefix-list PREFIX_LIST' */

static route_map_result_t
route_match_ip_next_hop_prefix_list (void *rule, struct prefix *prefix,
                                    route_map_object_t type, void *object)
{
Rip_routemap.c (ripd):341
      p.prefix = (rinfo->nexthop.s_addr) ? rinfo->nexthop : rinfo->from;
      p.prefixlen = IPV4_MAX_BITLEN;

Rip_routemap.c (ripd):368
  "ip next-hop prefix-list",
  route_match_ip_next_hop_prefix_list,
  route_match_ip_next_hop_prefix_list_compile,
Rip_routemap.c (ripd):379
route_match_ip_address (void *rule, struct prefix *prefix, 
			route_map_object_t type, void *object)
{
Rip_routemap.c (ripd):390
      return (access_list_apply (alist, prefix) == FILTER_DENY ?
	      RMAP_NOMATCH : RMAP_MATCH);
    }
Rip_routemap.c (ripd):420
/* `match ip address prefix-list PREFIX_LIST' */

static route_map_result_t
route_match_ip_address_prefix_list (void *rule, struct prefix *prefix, 
				    route_map_object_t type, void *object)
{
Rip_routemap.c (ripd):434
      return (prefix_list_apply (plist, prefix) == PREFIX_DENY ?
	      RMAP_NOMATCH : RMAP_MATCH);
    }
Rip_routemap.c (ripd):454
  "ip address prefix-list",
  route_match_ip_address_prefix_list,
  route_match_ip_address_prefix_list_compile,
Rip_routemap.c (ripd):463
route_match_tag (void *rule, struct prefix *prefix, 
		    route_map_object_t type, void *object)
{
Rip_routemap.c (ripd):496
route_set_metric (void *rule, struct prefix *prefix, 
		  route_map_object_t type, void *object)
{
Rip_routemap.c (ripd):595
route_set_ip_nexthop (void *rule, struct prefix *prefix, 
		      route_map_object_t type, void *object)
{
Rip_routemap.c (ripd):655
route_set_tag (void *rule, struct prefix *prefix, 
		      route_map_object_t type, void *object)
{
Rip_routemap.c (ripd):788
       "match ip next-hop prefix-list WORD",
       MATCH_STR
       IP_STR
Rip_routemap.c (ripd):792
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")
{
  return rip_route_match_add (vty, vty->index, "ip next-hop prefix-list", argv[0]);
}

Rip_routemap.c (ripd):800
       "no match ip next-hop prefix-list",
       NO_STR
       MATCH_STR
Rip_routemap.c (ripd):805
       "Match entries of prefix-lists\n")
{
  if (argc == 0)
    return rip_route_match_delete (vty, vty->index, "ip next-hop prefix-list", NULL);

  return rip_route_match_delete (vty, vty->index, "ip next-hop prefix-list", argv[0]);
}

Rip_routemap.c (ripd):815
       "no match ip next-hop prefix-list WORD",
       NO_STR
       MATCH_STR
Rip_routemap.c (ripd):820
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")

DEFUN (match_ip_address,
Rip_routemap.c (ripd):864
       "match ip address prefix-list WORD",
       MATCH_STR
       IP_STR
Rip_routemap.c (ripd):868
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")
{
  return rip_route_match_add (vty, vty->index, "ip address prefix-list", argv[0]);
}

Rip_routemap.c (ripd):876
       "no match ip address prefix-list",
       NO_STR
       MATCH_STR
Rip_routemap.c (ripd):881
       "Match entries of prefix-lists\n")
{
  if (argc == 0)
    return rip_route_match_delete (vty, vty->index, "ip address prefix-list", NULL);

  return rip_route_match_delete (vty, vty->index, "ip address prefix-list", argv[0]);
}

Rip_routemap.c (ripd):891
       "no match ip address prefix-list WORD",
       NO_STR
       MATCH_STR
Rip_routemap.c (ripd):896
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")

DEFUN (match_tag, 
Rip_snmp.c (ripd):30
#include "prefix.h"
#include "command.h"
#include "table.h"
Rip_snmp.c (ripd):180
  struct prefix *p;
  struct route_node *rn;

Rip_snmp.c (ripd):195
  struct prefix *p;
  struct route_node *rn;
  struct interface *i;
Rip_snmp.c (ripd):225
  p.prefix = *addr;

  rn = route_node_get (rip_ifaddr_table, (struct prefix *) &p);

  for (rn = route_next (rn); rn; rn = route_next (rn))
Rip_zebra.c (ripd):25
#include "prefix.h"
#include "table.h"
#include "stream.h"
Rip_zebra.c (ripd):155
  /* IPv4 prefix. */
  memset (&p, 0, sizeof (struct prefix_ipv4));
  p.family = AF_INET;
Rip_zebra.c (ripd):160
  stream_get (&p.prefix, s, PSIZE (p.prefixlen));

  /* Nexthop, ifindex, distance, metric. */
Routemap.c (lib):26
#include "prefix.h"
#include "routemap.h"
#include "command.h"
Routemap.c (lib):744
                       struct prefix *prefix, route_map_object_t type,
                       void *object)
{
Routemap.c (lib):763
          ret = (*match->cmd->func_apply) (match->value, prefix,
                                           type, object);
          if (ret != RMAP_MATCH)
Routemap.c (lib):774
route_map_apply (struct route_map *map, struct prefix *prefix,
                 route_map_object_t type, void *object)
{
Routemap.c (lib):797
      ret = route_map_apply_match (&index->match_list, prefix, type, object);

      /* Now we apply the matrix from above */
Routemap.c (lib):810
                ret = (*set->cmd->func_apply) (set->value, prefix,
                                               type, object);

Routemap.c (lib):822
                      ret = route_map_apply (nextrm, prefix, type, object);
                      recursion--;
                    }
Routemap.h (lib):25
#include "prefix.h"

/* Route map's type. */
Routemap.h (lib):85
  route_map_result_t (*func_apply)(void *, struct prefix *, 
				   route_map_object_t, void *);

Routemap.h (lib):193
                                           struct prefix *,
                                           route_map_object_t object_type,
                                           void *object);
Router-id.c (zebra):29
#include "prefix.h"
#include "stream.h"
#include "command.h"
Router-id.c (zebra):75
router_id_get (struct prefix *p, vrf_id_t vrf_id)
{
  struct listnode *node;
Router-id.c (zebra):102
router_id_set (struct prefix *p, vrf_id_t vrf_id)
{
  struct prefix p2;
  struct listnode *node;
  struct zserv *client;
Router-id.c (zebra):131
  struct prefix before;
  struct prefix after;
  struct zserv *client;
  struct zebra_vrf *zvrf = vrf_info_get (ifc->ifp->vrf_id);
Router-id.c (zebra):164
  struct prefix after;
  struct prefix before;
  struct listnode *node;
  struct zserv *client;
Router-id.c (zebra):221
  struct prefix rid;
  vrf_id_t vrf_id = VRF_DEFAULT;

Router-id.c (zebra):252
  struct prefix rid;
  vrf_id_t vrf_id = VRF_DEFAULT;

Router-id.h (zebra):30
#include "prefix.h"
#include "zclient.h"
#include "if.h"
Router-id.h (zebra):39
extern void router_id_get(struct prefix *, vrf_id_t);

#endif
Rt.h (zebra):26
#include "prefix.h"
#include "if.h"
#include "zebra/rib.h"
Rt.h (zebra):30
extern int kernel_route_rib (struct prefix *, struct rib *, struct rib *);
extern int kernel_add_route (struct prefix_ipv4 *, struct in_addr *, int, int);
extern int kernel_address_add_ipv4 (struct interface *, struct connected *);
Rtadv.c (zebra):30
#include "prefix.h"
#include "linklist.h"
#include "command.h"
Rtadv.c (zebra):258
  /* Fill in prefix. */
  for (ALL_LIST_ELEMENTS_RO (zif->rtadv.AdvPrefixList, node, rprefix))
    {
Rtadv.c (zebra):267
      pinfo->nd_opt_pi_prefix_len = rprefix->prefix.prefixlen;

      pinfo->nd_opt_pi_flags_reserved = 0;
Rtadv.c (zebra):281
      IPV6_ADDR_COPY (&pinfo->nd_opt_pi_prefix, &rprefix->prefix.prefix);

#ifdef DEBUG
Rtadv.c (zebra):588
    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))
      return rprefix;
  return NULL;
Rtadv.c (zebra):603
  memcpy (&rprefix->prefix, p, sizeof (struct prefix_ipv6));
  listnode_add (rplist, rprefix);

Rtadv.c (zebra):614
  rprefix = rtadv_prefix_get (zif->rtadv.AdvPrefixList, &rp->prefix);

  /* Set parameters. */
Rtadv.c (zebra):629
  rprefix = rtadv_prefix_lookup (zif->rtadv.AdvPrefixList, &rp->prefix);
  if (rprefix != NULL)
    {
Rtadv.c (zebra):1158
       "ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) "
       "(<0-4294967295>|infinite) (off-link|) (no-autoconfig|) (router-address|)",
       "Interface IPv6 config commands\n"
Rtadv.c (zebra):1163
       "IPv6 prefix\n"
       "Valid lifetime in seconds\n"
       "Infinite valid lifetime\n"
Rtadv.c (zebra):1168
       "Do not use prefix for onlink determination\n"
       "Do not use prefix for autoconfiguration\n"
       "Set Router Address flag\n")
{
Rtadv.c (zebra):1182
  ret = str2prefix_ipv6 (argv[0], &rp.prefix);
  if (!ret)
    {
      vty_out (vty, "Malformed IPv6 prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
  apply_mask_ipv6 (&rp.prefix); /* RFC4861 4.6.2 */
  rp.AdvOnLinkFlag = 1;
  rp.AdvAutonomousFlag = 1;
Rtadv.c (zebra):1240
       "ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) "
       "(<0-4294967295>|infinite) (off-link|) (no-autoconfig|)",
       "Interface IPv6 config commands\n"
Rtadv.c (zebra):1245
       "IPv6 prefix\n"
       "Valid lifetime in seconds\n"
       "Infinite valid lifetime\n"
Rtadv.c (zebra):1250
       "Do not use prefix for onlink determination\n"
       "Do not use prefix for autoconfiguration\n")

ALIAS (ipv6_nd_prefix,
Rtadv.c (zebra):1255
       "ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) "
       "(<0-4294967295>|infinite) (no-autoconfig|) (off-link|)",
       "Interface IPv6 config commands\n"
Rtadv.c (zebra):1260
       "IPv6 prefix\n"
       "Valid lifetime in seconds\n"
       "Infinite valid lifetime\n"
Rtadv.c (zebra):1265
       "Do not use prefix for autoconfiguration\n"
       "Do not use prefix for onlink determination\n")

ALIAS (ipv6_nd_prefix,
Rtadv.c (zebra):1270
       "ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) "
       "(<0-4294967295>|infinite) (no-autoconfig|) (off-link|) (router-address|)",
       "Interface IPv6 config commands\n"
Rtadv.c (zebra):1275
       "IPv6 prefix\n"
       "Valid lifetime in seconds\n"
       "Infinite valid lifetime\n"
Rtadv.c (zebra):1280
       "Do not use prefix for autoconfiguration\n"
       "Do not use prefix for onlink determination\n"
       "Set Router Address flag\n")

Rtadv.c (zebra):1286
       "ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) "
       "(<0-4294967295>|infinite) (no-autoconfig|)",
       "Interface IPv6 config commands\n"
Rtadv.c (zebra):1291
       "IPv6 prefix\n"
       "Valid lifetime in seconds\n"
       "Infinite valid lifetime\n"
Rtadv.c (zebra):1296
       "Do not use prefix for autoconfiguration")

ALIAS (ipv6_nd_prefix,
Rtadv.c (zebra):1300
       "ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) "
       "(<0-4294967295>|infinite) (off-link|)",
       "Interface IPv6 config commands\n"
Rtadv.c (zebra):1305
       "IPv6 prefix\n"
       "Valid lifetime in seconds\n"
       "Infinite valid lifetime\n"
Rtadv.c (zebra):1310
       "Do not use prefix for onlink determination\n")

ALIAS (ipv6_nd_prefix,
Rtadv.c (zebra):1314
       "ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) "
       "(<0-4294967295>|infinite) (router-address|)",
       "Interface IPv6 config commands\n"
Rtadv.c (zebra):1319
       "IPv6 prefix\n"
       "Valid lifetime in seconds\n"
       "Infinite valid lifetime\n"
Rtadv.c (zebra):1328
       "ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) "
       "(<0-4294967295>|infinite)",
       "Interface IPv6 config commands\n"
Rtadv.c (zebra):1333
       "IPv6 prefix\n"
       "Valid lifetime in seconds\n"
       "Infinite valid lifetime\n"
Rtadv.c (zebra):1341
       "ipv6 nd prefix X:X::X:X/M (no-autoconfig|) (off-link|)",
       "Interface IPv6 config commands\n"
       "Neighbor discovery\n"
Rtadv.c (zebra):1345
       "IPv6 prefix\n"
       "Do not use prefix for autoconfiguration\n"
       "Do not use prefix for onlink determination\n")

ALIAS (ipv6_nd_prefix,
Rtadv.c (zebra):1351
       "ipv6 nd prefix X:X::X:X/M (off-link|) (no-autoconfig|)",
       "Interface IPv6 config commands\n"
       "Neighbor discovery\n"
Rtadv.c (zebra):1355
       "IPv6 prefix\n"
       "Do not use prefix for onlink determination\n"
       "Do not use prefix for autoconfiguration\n")

ALIAS (ipv6_nd_prefix,
Rtadv.c (zebra):1361
       "ipv6 nd prefix X:X::X:X/M (no-autoconfig|)",
       "Interface IPv6 config commands\n"
       "Neighbor discovery\n"
Rtadv.c (zebra):1365
       "IPv6 prefix\n"
       "Do not use prefix for autoconfiguration\n")

ALIAS (ipv6_nd_prefix,
Rtadv.c (zebra):1370
       "ipv6 nd prefix X:X::X:X/M (off-link|)",
       "Interface IPv6 config commands\n"
       "Neighbor discovery\n"
Rtadv.c (zebra):1374
       "IPv6 prefix\n"
       "Do not use prefix for onlink determination\n")

ALIAS (ipv6_nd_prefix,
Rtadv.c (zebra):1379
       "ipv6 nd prefix X:X::X:X/M (router-address|)",
       "Interface IPv6 config commands\n"
       "Neighbor discovery\n"
Rtadv.c (zebra):1383
       "IPv6 prefix\n"
       "Set Router Address flag\n")

Rtadv.c (zebra):1388
       "ipv6 nd prefix X:X::X:X/M",
       "Interface IPv6 config commands\n"
       "Neighbor discovery\n"
Rtadv.c (zebra):1392
       "IPv6 prefix\n")

DEFUN (no_ipv6_nd_prefix,
Rtadv.c (zebra):1396
       "no ipv6 nd prefix IPV6PREFIX",
       NO_STR
       "Interface IPv6 config commands\n"
Rtadv.c (zebra):1401
       "IPv6 prefix\n")
{
  int ret;
Rtadv.c (zebra):1411
  ret = str2prefix_ipv6 (argv[0], &rp.prefix);
  if (!ret)
    {
      vty_out (vty, "Malformed IPv6 prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
  apply_mask_ipv6 (&rp.prefix); /* RFC4861 4.6.2 */

  ret = rtadv_prefix_reset (zebra_if, &rp);
Rtadv.c (zebra):1422
      vty_out (vty, "Non-exist IPv6 prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Rtadv.c (zebra):1592
      vty_out (vty, " ipv6 nd prefix %s",
               prefix2str (&rprefix->prefix, buf, sizeof(buf)));
      if ((rprefix->AdvValidLifetime != RTADV_VALID_LIFETIME) || 
	  (rprefix->AdvPreferredLifetime != RTADV_PREFERRED_LIFETIME))
Rtadv.h (zebra):32
/* Router advertisement prefix. */
struct rtadv_prefix
{
Rtadv.h (zebra):36
  struct prefix_ipv6 prefix;
  
  /* The value to be placed in the Valid Lifetime in the Prefix */
Rtread_getmsg.c (zebra):25
#include "prefix.h"
#include "log.h"
#include "if.h"
Rtread_getmsg.c (zebra):74
	struct prefix_ipv4	prefix;
 	struct in_addr		tmpaddr, gateway;
	u_char			zebra_flags = 0;
Rtread_getmsg.c (zebra):84
	prefix.family = AF_INET;

	tmpaddr.s_addr = routeEntry->ipRouteDest;
	prefix.prefix = tmpaddr;

	tmpaddr.s_addr = routeEntry->ipRouteMask;
	prefix.prefixlen = ip_masklen (tmpaddr);

	gateway.s_addr = routeEntry->ipRouteNextHop;
Rtread_getmsg.c (zebra):94
	rib_add_ipv4 (ZEBRA_ROUTE_KERNEL, zebra_flags, &prefix,
		      &gateway, NULL, 0, VRF_DEFAULT, RT_TABLE_MAIN,
		      0, 0, 0, SAFI_UNICAST);
Rt_netlink.c (zebra):33
#include "prefix.h"
#include "connected.h"
#include "table.h"
Rt_netlink.c (zebra):816
      memcpy (&p.prefix, dest, 4);
      p.prefixlen = rtm->rtm_dst_len;

Rt_netlink.c (zebra):884
      memcpy (&p.prefix, dest, 16);
      p.prefixlen = rtm->rtm_dst_len;

Rt_netlink.c (zebra):1023
      memcpy (&p.prefix, dest, 4);
      p.prefixlen = rtm->rtm_dst_len;

Rt_netlink.c (zebra):1107
      memcpy (&p.prefix, dest, 16);
      p.prefixlen = rtm->rtm_dst_len;

Rt_netlink.c (zebra):1655
        struct prefix *p,
        struct nexthop *nexthop,
        const char *routedesc,
Rt_netlink.c (zebra):1675
netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib)
{
  int bytelen;
Rt_netlink.c (zebra):1728
  addattr_l (&req.n, sizeof req, RTA_DST, &p->u.prefix, bytelen);

  /* Metric. */
Rt_netlink.c (zebra):1875
kernel_route_rib (struct prefix *p, struct rib *old, struct rib *new)
{
  if (!old && new)
Rt_netlink.c (zebra):1883
    * netlink uses [prefix, tos, priority] to identify prefix.
    * Now metric is not sent to kernel, so we can just do atomic replace. */
  return netlink_route_multipath (RTM_NEWROUTE, p, new);
Rt_netlink.c (zebra):1894
  struct prefix *p;

  struct
Rt_netlink.c (zebra):1918
  addattr_l (&req.n, sizeof req, IFA_LOCAL, &p->u.prefix, bytelen);

  if (family == AF_INET && cmd == RTM_NEWADDR)
Rt_netlink.c (zebra):1925
          addattr_l (&req.n, sizeof req, IFA_BROADCAST, &p->u.prefix,
                     bytelen);
        }
Rt_socket.c (zebra):26
#include "prefix.h"
#include "sockunion.h"
#include "log.h"
Rt_socket.c (zebra):71
kernel_rtm_ipv4 (int cmd, struct prefix *p, struct rib *rib)

{
Rt_socket.c (zebra):248
kernel_rtm_ipv6 (int cmd, struct prefix *p, struct rib *rib)
{
  struct sockaddr_in6 *mask;
Rt_socket.c (zebra):367
kernel_rtm (int cmd, struct prefix *p, struct rib *rib)
{
  switch (PREFIX_FAMILY(p))
Rt_socket.c (zebra):380
kernel_route_rib (struct prefix *p, struct rib *old, struct rib *new)
{
  int route = 0;
Smux.c (lib):137
smux_oid_dump (const char *prefix, const oid *oid, size_t oid_len)
{
  unsigned int i;
Smux.c (lib):150
  zlog_debug ("%s: %s", prefix, buf);
}

Snmp.c (lib):118
  /* If the requested OID name is less than OID prefix we
     handle, adjust it to our prefix. */
  if ((oid_compare (name, *length, v->name, v->namelen)) < 0)
    {
Sockunion.c (lib):24
#include "prefix.h"
#include "vty.h"
#include "sockunion.h"
Sockunion.c (lib):556
/* If same family and same prefix return 1. */
int
sockunion_same (const union sockunion *su1, const union sockunion *su2)
Stream.c (lib):29
#include "prefix.h"
#include "log.h"

Stream.c (lib):773
/* Put prefix by nlri type format. */
int
stream_put_prefix (struct stream *s, struct prefix *p)
{
  size_t psize;
Stream.c (lib):790
  memcpy (s->data + s->endp, &p->u.prefix, psize);
  s->endp += psize;
  
Stream.h (lib):26
#include "prefix.h"

/*
Stream.h (lib):176
extern int stream_put_prefix (struct stream *, struct prefix *);

extern void stream_get (void *, struct stream *, size_t);
Table.c (lib):25
#include "prefix.h"
#include "table.h"
#include "memory.h"
Table.c (lib):60
/* Allocate new route node with prefix set. */
static struct route_node *
route_node_set (struct route_table *table, const struct prefix *prefix)
{
  struct route_node *node;
Table.c (lib):68
  prefix_copy (&node->p, prefix);
  node->table = table;

Table.c (lib):142
/* Common prefix route genaration. */
static void
route_common (const struct prefix *n, const struct prefix *p, struct prefix *new)
{
  int i;
Table.c (lib):150
  const u_char *np = (const u_char *)&n->u.prefix;
  const u_char *pp = (const u_char *)&p->u.prefix;
  u_char *newp = (u_char *)&new->u.prefix;

  for (i = 0; i < p->prefixlen / 8; i++)
Table.c (lib):180
  unsigned int bit = prefix_bit (&new->p.u.prefix, node->p.prefixlen);

  node->link[bit] = new;
Table.c (lib):205
/* Find matched prefix. */
struct route_node *
route_node_match (const struct route_table *table, const struct prefix *p)
{
  struct route_node *node;
Table.c (lib):226
      node = node->link[prefix_bit(&p->u.prefix, node->p.prefixlen)];
    }

Table.c (lib):245
  p.prefix = *addr;

  return route_node_match (table, (struct prefix *) &p);
}

Table.c (lib):260
  p.prefix = *addr;

  return route_node_match (table, (struct prefix *) &p);
}
#endif /* HAVE_IPV6 */
Table.c (lib):266
/* Lookup same prefix node.  Return NULL when we can't find route. */
struct route_node *
route_node_lookup (const struct route_table *table, const struct prefix *p)
{
  struct route_node *node;
Table.c (lib):272
  const u_char *prefix = &p->u.prefix;

  node = table->top;
Table.c (lib):282
      node = node->link[prefix_bit(prefix, node->p.prefixlen)];
    }

Table.c (lib):290
route_node_get (struct route_table *const table, const struct prefix *p)
{
  struct route_node *new;
Table.c (lib):296
  const u_char *prefix = &p->u.prefix;

  match = NULL;
Table.c (lib):307
      node = node->link[prefix_bit(prefix, node->p.prefixlen)];
    }

Table.c (lib):543
route_table_prefix_iter_cmp (struct prefix *p1, struct prefix *p2)
{
  struct prefix common_space;
  struct prefix *common = &common_space;

  if (p1->prefixlen <= p2->prefixlen)
Table.c (lib):574
   * Both prefixes are longer than the common prefix.
   *
   * We need to check the bit after the common prefixlen to determine
Table.c (lib):579
  if (prefix_bit (&p1->u.prefix, common->prefixlen))
    {

Table.c (lib):583
       * We branch to the right to get to p1 from the common prefix.
       */
      assert (!prefix_bit (&p2->u.prefix, common->prefixlen));
      return 1;
    }
Table.c (lib):590
   * We branch to the right to get to p2 from the common prefix.
   */
  assert (prefix_bit (&p2->u.prefix, common->prefixlen));
  return -1;
}
Table.c (lib):619
 * Helper function to find the node that occurs after the given prefix in
 * order of iteration.
 *
Table.c (lib):626
			       struct prefix *p)
{
  struct route_node *node, *tmp_node;
Table.c (lib):648
	       * The prefix p exists in the tree, just return the next
	       * node.
	       */
Table.c (lib):671
	  tmp_node = node->link[prefix_bit (&p->u.prefix, node->p.prefixlen)];

	  if (tmp_node)
Table.c (lib):694
       * Neither node prefix nor 'p' contains the other.
       */
      cmp = route_table_prefix_iter_cmp (&node->p, p);
Table.c (lib):709
       * Node and the subtree under it come before prefix p in
       * iteration order. Prefix p and its sub-tree are not present in
       * the tree. Go upwards and find the first node that follows the
Table.c (lib):723
 * Find the node that occurs after the given prefix in order of
 * iteration.
 */
Table.c (lib):727
route_table_get_next (const struct route_table *table, struct prefix *p)
{
  struct route_node *node;
Table.c (lib):773
       * Save the prefix that we are currently at. The next call to
       * route_table_iter_next() will return the node after this prefix
       * in the tree.
       */
Table.h (lib):74
  /* Actual prefix of this radix. */		\
  struct prefix p;				\
						\
  /* Tree link. */				\
Table.h (lib):133
   * The last prefix that the iterator processed before it was paused.
   */  
  struct prefix pause_prefix;
};

Table.h (lib):151
                                          const struct prefix *);
extern struct route_node *route_node_lookup (const struct route_table *,
                                             const struct prefix *);
extern struct route_node *route_lock_node (struct route_node *node);
extern struct route_node *route_node_match (const struct route_table *,
                                            const struct prefix *);
extern struct route_node *route_node_match_ipv4 (const struct route_table *,
						 const struct in_addr *);
Table.h (lib):167
route_table_get_next (const struct route_table *table, struct prefix *p);
extern int
route_table_prefix_iter_cmp (struct prefix *p1, struct prefix *p2);

/*
Table_test.c (tests):26
#include "prefix.h"
#include "table.h"

Table_test.c (tests):49
 * Add the given prefix (passed in as a string) to the given table.
 */
static void
Table_test.c (tests):65
  rn = route_node_get (table, (struct prefix *) &p);
  if (rn->info)
    {
Table_test.c (tests):91
  char *prefix;

  va_start (arglist, table);
Table_test.c (tests):95
  prefix = va_arg (arglist, char *);
  while (prefix)
    {
      add_node (table, prefix);
      prefix = va_arg (arglist, char *);
    }

Table_test.c (tests):199
 * Iterate over the tree to make sure that the first prefix after
 * target_pfx is the expected one. Note that target_pfx may not be
 * present in the tree.
Table_test.c (tests):205
			  struct prefix *target_pfx, struct prefix *next_pfx)
{
  route_table_iter_t iter;
Table_test.c (tests):232
 * (result) for the prefix string 'target'.
 */
static void
Table_test.c (tests):246
  rn = route_table_get_next (table, (struct prefix *) &target_pfx);
  if (rn)
    {
Table_test.c (tests):264
      verify_next_by_iterating (table, (struct prefix *) &target_pfx, NULL);
      return;
    }
Table_test.c (tests):275
  if (prefix_cmp (&rn->p, (struct prefix *) &next_pfx))
    {
      assert (0);
Table_test.c (tests):281
  verify_next_by_iterating (table, (struct prefix *) &target_pfx,
			    (struct prefix *) &next_pfx);
}

Table_test.c (tests):370
   * the target prefix contain each other.
   *
   * In first case below the node succeeds the target.
Table_test.c (tests):408
  result = route_table_prefix_iter_cmp ((struct prefix *) &p1_pfx,
					(struct prefix *) &p2_pfx);

  printf ("Verifying cmp(%s, %s) returns %d\n", p1, p2, exp_result);
Table_test.c (tests):418
  result = route_table_prefix_iter_cmp ((struct prefix *) &p2_pfx,
					(struct prefix *) &p1_pfx);

  if (exp_result)
Test_main.c (zebra):28
#include "prefix.h"
#include "log.h"
#include "privs.h"
Version.h (lib):48
#define QUAGGA_CONFIG_ARGS "--enable-vtysh --enable-user=root --enable-group=root --enable-vty-group=root --prefix=/usr --sysconfdir=/etc/quagga --localstatedir=/var/run/quagga --no-create --no-recursion"

pid_t pid_output (const char *);
Vrf.c (lib):34
#include "prefix.h"
#include "table.h"
#include "log.h"
Vrf.c (lib):127
vrf_build_key (vrf_id_t vrf_id, struct prefix *p)
{
  p->family = AF_INET;
Vrf.c (lib):138
  struct prefix p;
  struct route_node *rn;
  struct vrf *vrf;
Vrf.c (lib):190
  struct prefix p;
  struct route_node *rn;
  struct vrf *vrf = NULL;
Vrf.c (lib):341
  struct prefix p;
  struct route_node *rn;

Vty.c (lib):34
#include "prefix.h"
#include "filter.h"
#include "vty.h"
Vty.c (lib):1868
  struct prefix p;
  struct access_list *acl = NULL;
  char buf[SU_ADDRSTRLEN];
Vtysh.c (vtysh):89
/* Return true if str begins with prefix, else return false */
static int
begins_with(const char *str, const char *prefix)
{
  if (!str || !prefix)
    return 0;
  size_t lenstr = strlen(str);
  size_t lenprefix = strlen(prefix);
  if (lenprefix >  lenstr)
    return 0;
  return strncmp(str, prefix, lenprefix) == 0;
}

Vtysh.c (vtysh):1408
       "distribute-list prefix WORD (in|out)",
       "Filter networks in routing updates\n"
       "Filter prefixes in routing updates\n"
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n")
Vtysh.c (vtysh):1417
       "no distribute-list prefix WORD (in|out)",
       NO_STR
       "Filter networks in routing updates\n"
Vtysh.c (vtysh):1421
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n")
Vtysh.c (vtysh):1427
       "distribute-list prefix WORD (in|out) WORD",
       "Filter networks in routing updates\n"
       "Filter prefixes in routing updates\n"
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n"
Vtysh.c (vtysh):1437
       "no distribute-list prefix WORD (in|out) WORD",
       NO_STR
       "Filter networks in routing updates\n"
Vtysh.c (vtysh):1441
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n"
Vtysh.c (vtysh):1484
       "ipv6 distribute-list prefix WORD (in|out)",
       "Filter networks in routing updates\n"
       "Filter prefixes in routing updates\n"
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n")
Vtysh.c (vtysh):1493
       "no ipv6 distribute-list prefix WORD (in|out)",
       NO_STR
       "Filter networks in routing updates\n"
Vtysh.c (vtysh):1497
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n")
Vtysh.c (vtysh):1503
       "ipv6 distribute-list prefix WORD (in|out) WORD",
       "Filter networks in routing updates\n"
       "Filter prefixes in routing updates\n"
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n"
Vtysh.c (vtysh):1513
       "no ipv6 distribute-list prefix WORD (in|out) WORD",
       NO_STR
       "Filter networks in routing updates\n"
Vtysh.c (vtysh):1517
       "Name of an IP prefix-list\n"
       "Filter incoming routing updates\n"
       "Filter outgoing routing updates\n"
Vtysh_config.c (vtysh):234
      else if (strncmp (line, "ip prefix-list",
	       strlen ("ip prefix-list")) == 0)
	config = config_get (PREFIX_NODE, line);
      else if (strncmp (line, "ipv6 prefix-list",
	       strlen ("ipv6 prefix-list")) == 0)
	config = config_get (PREFIX_IPV6_NODE, line);
      else if (strncmp (line, "ip as-path access-list",
Zclient.c (lib):25
#include "prefix.h"
#include "stream.h"
#include "buffer.h"
Zclient.c (lib):524
  * nexthop information is provided, and the message describes a prefix
  * to blackhole or reject route.
  *
Zclient.c (lib):557
  /* Put prefix information. */
  psize = PSIZE (p->prefixlen);
  stream_putc (s, p->prefixlen);
  stream_write (s, (u_char *) & p->prefix, psize);

  /* Nexthop, ifindex, distance and metric information. */
Zclient.c (lib):623
  /* Put prefix information. */
  psize = PSIZE (p->prefixlen);
  stream_putc (s, p->prefixlen);
  stream_write (s, (u_char *)&p->prefix, psize);

  /* Nexthop, ifindex, distance and metric information. */
Zclient.c (lib):684
/* Get prefix in ZServ format; family should be filled in on prefix */
static void
zclient_stream_get_prefix (struct stream *s, struct prefix *p)
{
  size_t plen = prefix_blen (p);
Zclient.c (lib):695
  stream_get (&p->u.prefix, s, plen);
  c = stream_getc(s);
  p->prefixlen = MIN(plen * 8, c);
Zclient.c (lib):702
zebra_router_id_update_read (struct stream *s, struct prefix *rid)
{
  /* Fetch interface address. */
Zclient.c (lib):978
  struct prefix p, d, *dp;
  int plen;
  u_char ifc_flags;
Zclient.c (lib):1009
  stream_get (&d.u.prefix, s, plen);
  
  /* N.B. NULL destination pointers are encoded as all zeroes */
  dp = memconstant(&d.u.prefix,0,plen) ? NULL : &d;
  
  if (type == ZEBRA_INTERFACE_ADDRESS_ADD) 
Zclient.h (lib):26
#include "prefix.h"

/* For struct interface and struct connected. */
Zclient.h (lib):188
extern void zebra_router_id_update_read (struct stream *s, struct prefix *rid);
extern int zapi_ipv4_route (u_char, struct zclient *, struct prefix_ipv4 *, 
                            struct zapi_ipv4 *);
Zclient.h (lib):196
/* IPv6 prefix add and delete function prototype. */

struct zapi_ipv6
Zebra_fpm_dt.c (zebra):179
  struct prefix prefix;
  u_char family, nh_family;
  uint if_index;
Zebra_fpm_dt.c (zebra):196
  if (!qpb_l3_prefix_get (add_route->key->prefix, family, &prefix))
    return;

Zebra_fpm_dt.c (zebra):200
	      inet_ntop (family, &prefix.u.prefix, buf, sizeof (buf)),
	      prefix.prefixlen, add_route->metric);

  /*
Zebra_fpm_netlink.c (zebra):67
 * address in a prefix.
 */
static const char *
prefix_addr_to_a (struct prefix *prefix)
{
  if (!prefix)
    return "<No address>";

  return addr_to_a (prefix->family, &prefix->u.prefix);
}

Zebra_fpm_netlink.c (zebra):135
  struct prefix *prefix;
  uint32_t *metric;
  int num_nhs;
Zebra_fpm_netlink.c (zebra):244
  ri->prefix = rib_dest_prefix (dest);
  ri->af = rib_dest_af (dest);

Zebra_fpm_netlink.c (zebra):361
  req->r.rtm_dst_len = ri->prefix->prefixlen;
  req->r.rtm_protocol = ri->rtm_protocol;
  req->r.rtm_scope = RT_SCOPE_UNIVERSE;
Zebra_fpm_netlink.c (zebra):365
  addattr_l (&req->n, in_buf_len, RTA_DST, &ri->prefix->u.prefix, bytelen);

  req->r.rtm_type = ri->rtm_type;
Zebra_fpm_netlink.c (zebra):458
	      prefix_addr_to_a (ri->prefix), ri->prefix->prefixlen,
	      nl_rtproto_to_str (ri->rtm_protocol),
	      ri->metric ? *ri->metric : 0);
Zebra_rib.c (zebra):24
#include "prefix.h"
#include "table.h"
#include "memory.h"
Zebra_rib.c (zebra):35
#include "prefix.h"
#include "routemap.h"
#include "vrf.h"
Zebra_rib.c (zebra):86
  char prefix[PREFIX_STRLEN], buf[256];
  char msgbuf[512];
  va_list ap;
Zebra_rib.c (zebra):99
               prefix2str(&rn->p, prefix, sizeof(prefix)),
               info->safi == SAFI_MULTICAST ? " (MRIB)" : "",
               info->zvrf->vrf_id);
Zebra_rib.c (zebra):302
  /* Make lookup prefix. */
  memset (&p, 0, sizeof (struct prefix_ipv4));
  p.family = AF_INET;
Zebra_rib.c (zebra):306
  p.prefix = nexthop->gate.ipv4;

  /* Lookup table.  */
Zebra_rib.c (zebra):313
  rn = route_node_match (table, (struct prefix *) &p);
  while (rn)
    {
Zebra_rib.c (zebra):318
      /* If lookup self prefix return immediately. */
      if (rn == top)
	return 0;
Zebra_rib.c (zebra):344
	  /* If the longest prefix match for the nexthop yields
	   * a blackhole, mark it as inactive. */
	  if (CHECK_FLAG (match->flags, ZEBRA_FLAG_BLACKHOLE)
Zebra_rib.c (zebra):436
  /* Make lookup prefix. */
  memset (&p, 0, sizeof (struct prefix_ipv6));
  p.family = AF_INET6;
Zebra_rib.c (zebra):440
  p.prefix = nexthop->gate.ipv6;

  /* Lookup table.  */
Zebra_rib.c (zebra):447
  rn = route_node_match (table, (struct prefix *) &p);
  while (rn)
    {
Zebra_rib.c (zebra):452
      /* If lookup self prefix return immediately. */
      if (rn == top)
	return 0;
Zebra_rib.c (zebra):478
	  /* If the longest prefix match for the nexthop yields
	   * a blackhole, mark it as inactive. */
	  if (CHECK_FLAG (match->flags, ZEBRA_FLAG_BLACKHOLE)
Zebra_rib.c (zebra):705
  rn = route_node_lookup (table, (struct prefix *) p);

  /* No route for this prefix. */
  if (! rn)
    return NULL;
Zebra_rib.c (zebra):737
 * if specified IPv4 route record (prefix/mask -> gate) exists in
 * the whole RIB and has ZEBRA_FLAG_SELECTED set.
 *
Zebra_rib.c (zebra):764
  rn = route_node_lookup (table, (struct prefix *) p);

  /* No route for this prefix. */
  if (! rn)
    return ZEBRA_RIB_NOTFOUND;
Zebra_rib.c (zebra):831
  IPV6_ADDR_COPY (&p.prefix, addr);

  rn = route_node_match (table, (struct prefix *) &p);

  while (rn)
Zebra_rib.c (zebra):1111
   * prefix.
   */
  if (CHECK_FLAG (dest->flags, RIB_DEST_UPDATE_FPM) ||
Zebra_rib.c (zebra):1709
  /* Make it sure prefixlen is applied to the prefix. */
  apply_mask_ipv4 (p);

Zebra_rib.c (zebra):1726
  rn = route_node_get (table, (struct prefix *) p);

  /* If same type of route are installed, treat it as a implicit
Zebra_rib.c (zebra):1801
 * standard debug log. Calling function name and IP prefix in
 * question are passed as 1st and 2nd arguments.
 */
Zebra_rib.c (zebra):1808
  const struct prefix *p = pp.p;
  char straddr[PREFIX_STRLEN];
  struct nexthop *nexthop, *tnexthop;
Zebra_rib.c (zebra):1879
  rn = route_node_lookup (table, (struct prefix *) p);

  /* No route for this prefix. */
  if (! rn)
  {
Zebra_rib.c (zebra):1885
                prefix2str((struct prefix*) p, prefix_buf, sizeof(prefix_buf)));
    return;
  }
Zebra_rib.c (zebra):1922
  /* Make it sure prefixlen is applied to the prefix. */
  apply_mask_ipv4 (p);

Zebra_rib.c (zebra):1937
  rn = route_node_get (table, (struct prefix *) p);

  /* If same type of route are installed, treat it as a implicit
Zebra_rib.c (zebra):2021
  rn = route_node_lookup (table, (struct prefix *) p);
  if (! rn)
    {
Zebra_rib.c (zebra):2093
                         inet_ntop (AF_INET, &p->prefix, buf1, INET_ADDRSTRLEN),
                         p->prefixlen);
            }
Zebra_rib.c (zebra):2131
static_install_route (afi_t afi, safi_t safi, struct prefix *p, struct static_route *si)
{
  struct rib *rib;
Zebra_rib.c (zebra):2260
static_uninstall_route (afi_t afi, safi_t safi, struct prefix *p, struct static_route *si)
{
  struct route_node *rn;
Zebra_rib.c (zebra):2321
static_add_ipv4_safi (safi_t safi, struct prefix *p, struct in_addr *gate,
		      const char *ifname, u_char flags, route_tag_t tag,
		      u_char distance, vrf_id_t vrf_id)
Zebra_rib.c (zebra):2337
  /* Lookup static route prefix. */
  rn = route_node_get (stable, p);

Zebra_rib.c (zebra):2418
static_delete_ipv4_safi (safi_t safi, struct prefix *p, struct in_addr *gate,
			 const char *ifname, route_tag_t tag, u_char distance,
			 vrf_id_t vrf_id)
Zebra_rib.c (zebra):2432
  /* Lookup static route prefix. */
  rn = route_node_lookup (stable, p);
  if (! rn)
Zebra_rib.c (zebra):2510
  rn = route_node_get (table, (struct prefix *) p);

  /* If same type of route are installed, treat it as a implicit
Zebra_rib.c (zebra):2622
  rn = route_node_get (table, (struct prefix *) p);

  /* If same type of route are installed, treat it as a implicit
Zebra_rib.c (zebra):2659
      rib_dump ((struct prefix *)p, same);
    }
    rib_delnode (rn, same);
Zebra_rib.c (zebra):2694
  rn = route_node_lookup (table, (struct prefix *) p);
  if (! rn)
    {
Zebra_rib.c (zebra):2767
                         inet_ntop (AF_INET, &p->prefix, buf1, INET_ADDRSTRLEN),
                         p->prefixlen);
            }
Zebra_rib.c (zebra):2805
static_add_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
		 const char *ifname, u_char flags, route_tag_t tag,
		 u_char distance, vrf_id_t vrf_id)
Zebra_rib.c (zebra):2828
  /* Lookup static route prefix. */
  rn = route_node_get (stable, p);

Zebra_rib.c (zebra):2903
static_delete_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
		    const char *ifname, route_tag_t tag, u_char distance,
		    vrf_id_t vrf_id)
Zebra_rib.c (zebra):2916
  /* Lookup static route prefix. */
  rn = route_node_lookup (stable, p);
  if (! rn)
Zebra_rnh.c (zebra):24
#include "prefix.h"
#include "table.h"
#include "memory.h"
Zebra_rnh.c (zebra):35
#include "prefix.h"
#include "routemap.h"
#include "stream.h"
Zebra_rnh.c (zebra):71
zebra_add_rnh (struct prefix *p, vrf_id_t vrfid)
{
  struct route_table *table;
Zebra_rnh.c (zebra):90
  /* Make it sure prefixlen is applied to the prefix. */
  apply_mask (p);

Zebra_rnh.c (zebra):110
zebra_lookup_rnh (struct prefix *p, vrf_id_t vrfid)
{
  struct route_table *table;
Zebra_rnh.c (zebra):119
  /* Make it sure prefixlen is applied to the prefix. */
  apply_mask (p);

Zebra_rnh.c (zebra):207
      zlog_debug("evaluate_rnh_table: prefix table not found\n");
      return -1;
    }
Zebra_rnh.c (zebra):610
  vty_out(vty, "%s%s", inet_ntop(rn->p.family, &rn->p.u.prefix, buf, BUFSIZ),
	  VTY_NEWLINE);
  if (rnh->state)
Zebra_rnh.h (zebra):26
#include "prefix.h"
#include "vty.h"

Zebra_rnh.h (zebra):39
extern struct rnh *zebra_add_rnh(struct prefix *p, vrf_id_t vrfid);
extern struct rnh *zebra_lookup_rnh(struct prefix *p, vrf_id_t vrfid);
extern void zebra_delete_rnh(struct rnh *rnh);
extern void zebra_add_rnh_client(struct rnh *rnh, struct zserv *client, vrf_id_t vrf_id_t);
Zebra_routemap.c (zebra):25
#include "prefix.h"
#include "rib.h"
#include "routemap.h"
Zebra_routemap.c (zebra):132
route_match_interface (void *rule, struct prefix *prefix,
		       route_map_object_t type, void *object)
{
Zebra_routemap.c (zebra):253
       "match ip next-hop prefix-list WORD",
       MATCH_STR
       IP_STR
Zebra_routemap.c (zebra):257
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")
{
  return zebra_route_match_add (vty, vty->index, "ip next-hop prefix-list", argv[0]);
}

Zebra_routemap.c (zebra):265
       "no match ip next-hop prefix-list",
       NO_STR
       MATCH_STR
Zebra_routemap.c (zebra):270
       "Match entries of prefix-lists\n")
{
  if (argc == 0)
    return zebra_route_match_delete (vty, vty->index, "ip next-hop prefix-list", NULL);

  return zebra_route_match_delete (vty, vty->index, "ip next-hop prefix-list", argv[0]);
}

Zebra_routemap.c (zebra):280
       "no match ip next-hop prefix-list WORD",
       NO_STR
       MATCH_STR
Zebra_routemap.c (zebra):285
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")

DEFUN (match_ip_address,
Zebra_routemap.c (zebra):329
       "match ip address prefix-list WORD",
       MATCH_STR
       IP_STR
Zebra_routemap.c (zebra):333
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")
{
  return zebra_route_match_add (vty, vty->index, "ip address prefix-list", argv[0]);
}

Zebra_routemap.c (zebra):341
       "no match ip address prefix-list",
       NO_STR
       MATCH_STR
Zebra_routemap.c (zebra):346
       "Match entries of prefix-lists\n")
{
  if (argc == 0)
    return zebra_route_match_delete (vty, vty->index, "ip address prefix-list", NULL);

  return zebra_route_match_delete (vty, vty->index, "ip address prefix-list", argv[0]);
}

Zebra_routemap.c (zebra):356
       "no match ip address prefix-list WORD",
       NO_STR
       MATCH_STR
Zebra_routemap.c (zebra):361
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")

/* set functions */
Zebra_routemap.c (zebra):423
route_match_ip_next_hop (void *rule, struct prefix *prefix,
			route_map_object_t type, void *object)
{
Zebra_routemap.c (zebra):444
        p.prefix = nexthop->gate.ipv4;
        p.prefixlen = IPV4_MAX_BITLEN;
        break;
Zebra_routemap.c (zebra):484
/* `match ip next-hop prefix-list PREFIX_LIST' */

static route_map_result_t
route_match_ip_next_hop_prefix_list (void *rule, struct prefix *prefix,
                                    route_map_object_t type, void *object)
{
Zebra_routemap.c (zebra):508
        p.prefix = nexthop->gate.ipv4;
        p.prefixlen = IPV4_MAX_BITLEN;
        break;
Zebra_routemap.c (zebra):538
  "ip next-hop prefix-list",
  route_match_ip_next_hop_prefix_list,
  route_match_ip_next_hop_prefix_list_compile,
Zebra_routemap.c (zebra):549
route_match_ip_address (void *rule, struct prefix *prefix, 
			route_map_object_t type, void *object)
{
Zebra_routemap.c (zebra):560
      return (access_list_apply (alist, prefix) == FILTER_DENY ?
	      RMAP_NOMATCH : RMAP_MATCH);
    }
Zebra_routemap.c (zebra):590
/* `match ip address prefix-list PREFIX_LIST' */

static route_map_result_t
route_match_ip_address_prefix_list (void *rule, struct prefix *prefix, 
				    route_map_object_t type, void *object)
{
Zebra_routemap.c (zebra):604
      return (prefix_list_apply (plist, prefix) == PREFIX_DENY ?
	      RMAP_NOMATCH : RMAP_MATCH);
    }
Zebra_routemap.c (zebra):624
  "ip address prefix-list",
  route_match_ip_address_prefix_list,
  route_match_ip_address_prefix_list_compile,
Zebra_routemap.c (zebra):635
route_set_src (void *rule, struct prefix *prefix, 
		  route_map_object_t type, void *object)
{
Zebra_snmp.c (zebra):34
#include "prefix.h"
#include "command.h"
#include "smux.h"
Zebra_snmp.c (zebra):271
  if (in_addr_cmp(&(*np)->p.u.prefix, &np2->p.u.prefix) < 0)
    return;
  if (in_addr_cmp(&(*np)->p.u.prefix, &np2->p.u.prefix) > 0)
    {
      *np = np2;
Zebra_snmp.c (zebra):375
	  if (!in_addr_cmp(&(*np)->p.u.prefix, (u_char *)&dest))
	    {
	      RNODE_FOREACH_RIB (*np, *rib)
Zebra_snmp.c (zebra):395
      if (in_addr_cmp(&np2->p.u.prefix, (u_char *)&dest) > 0)
	RNODE_FOREACH_RIB (np2, rib2)
	  check_replace(np2, rib2, np, rib);
Zebra_snmp.c (zebra):399
      if (in_addr_cmp(&np2->p.u.prefix, (u_char *)&dest) == 0)
        { /* have to look at each rib individually */
	  RNODE_FOREACH_RIB (np2, rib2)
Zebra_snmp.c (zebra):426
  pnt = (u_char *) &(*np)->p.u.prefix;
  for (i = 0; i < 4; i++)
    objid[v->namelen + i] = *pnt++;
Zebra_snmp.c (zebra):475
      return &np->p.u.prefix;
      break;
    case IPFORWARDMASK:
Zebra_vty.c (zebra):26
#include "prefix.h"
#include "command.h"
#include "table.h"
Zebra_vty.c (zebra):52
  struct prefix p;
  struct in_addr gate;
  struct in_addr mask;
Zebra_vty.c (zebra):79
  /* Apply mask for given prefix. */
  apply_mask (&p);

Zebra_vty.c (zebra):164
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Nexthop address\n"
       "Nexthop interface name\n"
Zebra_vty.c (zebra):179
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Nexthop address\n"
       "Nexthop interface name\n")
Zebra_vty.c (zebra):188
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Nexthop address\n"
       "Nexthop interface name\n"
Zebra_vty.c (zebra):205
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Nexthop address\n"
       "Nexthop interface name\n"
Zebra_vty.c (zebra):215
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Nexthop address\n"
       "Nexthop interface name\n"
Zebra_vty.c (zebra):231
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Nexthop address\n"
       "Nexthop interface name\n")
Zebra_vty.c (zebra):240
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Nexthop address\n"
       "Nexthop interface name\n"
Zebra_vty.c (zebra):258
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Nexthop address\n"
       "Nexthop interface name\n"
Zebra_vty.c (zebra):265
       "ip multicast rpf-lookup-mode (urib-only|mrib-only|mrib-then-urib|lower-distance|longer-prefix)",
       IP_STR
       "Multicast options\n"
Zebra_vty.c (zebra):273
       "Lookup both, use entry with longer prefix\n")
{
  VTY_WARN_EXPERIMENTAL();
Zebra_vty.c (zebra):298
       "no ip multicast rpf-lookup-mode (urib-only|mrib-only|mrib-then-urib|lower-distance|longer-prefix)",
       NO_STR
       IP_STR
Zebra_vty.c (zebra):307
       "Lookup both, use entry with longer prefix\n")
{
  multicast_mode_ipv4_set (MCAST_NO_CONFIG);
Zebra_vty.c (zebra):467
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):481
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):497
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):514
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):529
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):547
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):565
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n")
Zebra_vty.c (zebra):578
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):593
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):610
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):625
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):643
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):661
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):677
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):695
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):714
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n")
Zebra_vty.c (zebra):728
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):744
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):762
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):777
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):794
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):812
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):828
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):846
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):865
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):879
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):895
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):912
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):928
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):946
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):966
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):985
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1005
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1022
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1037
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "Set tag for this route\n"
       "Tag value\n"
Zebra_vty.c (zebra):1054
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "Set tag for this route\n"
       "Tag value\n"
Zebra_vty.c (zebra):1073
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1088
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1105
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1123
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1135
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1149
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n")
Zebra_vty.c (zebra):1163
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1179
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1196
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1212
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1230
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1243
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1258
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n")
Zebra_vty.c (zebra):1273
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1290
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1308
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1324
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1342
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1361
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1378
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1397
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1417
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1432
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1449
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1467
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1484
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1503
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1523
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1541
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1561
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1582
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1597
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1612
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1628
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1643
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1659
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1676
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1692
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1708
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1725
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1740
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1757
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1775
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1792
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1809
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1822
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1837
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1855
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1869
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1885
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1902
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1920
       "IP destination prefix (e.g. 10.0.0.0/8)\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1936
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1954
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "IP gateway address\n"
       "IP gateway interface name\n"
Zebra_vty.c (zebra):1973
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):1990
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):2008
       "IP destination prefix\n"
       "IP destination prefix mask\n"
       "Emit an ICMP unreachable when matched\n"
       "Silently discard pkts when matched\n"
Zebra_vty.c (zebra):2502
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Show route matching the specified Network/Mask pair only\n")
{
Zebra_vty.c (zebra):2508
  struct prefix p;
  int ret;
  int first = 1;
Zebra_vty.c (zebra):2548
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Show route matching the specified Network/Mask pair only\n"
       VRF_CMD_HELP_STR)
Zebra_vty.c (zebra):2685
  rn = route_node_match (table, (struct prefix *) &p);
  if (! rn)
    {
Zebra_vty.c (zebra):2714
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  int ret;
Zebra_vty.c (zebra):2736
  rn = route_node_match (table, (struct prefix *) &p);
  if (! rn || rn->p.prefixlen != p.prefixlen)
    {
Zebra_vty.c (zebra):2758
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       VRF_CMD_HELP_STR)

Zebra_vty.c (zebra):2829
 * Implementation of the ip route summary prefix command.
 *
 * This command prints the primary prefixes that have been installed by various
Zebra_vty.c (zebra):2942
/* Show route summary prefix.  */
DEFUN (show_ip_route_summary_prefix,
       show_ip_route_summary_prefix_cmd,
       "show ip route summary prefix",
       SHOW_STR
       IP_STR
Zebra_vty.c (zebra):2969
       "show ip route summary prefix " VRF_CMD_STR,
       SHOW_STR
       IP_STR
Zebra_vty.c (zebra):3020
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Show route matching the specified Network/Mask pair only\n"
       VRF_ALL_CMD_HELP_STR)
Zebra_vty.c (zebra):3027
  struct prefix p;
  struct zebra_vrf *zvrf;
  vrf_iter_t iter;
Zebra_vty.c (zebra):3185
      rn = route_node_match (table, (struct prefix *) &p);
      if (! rn)
        continue;
Zebra_vty.c (zebra):3203
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       VRF_ALL_CMD_HELP_STR)
{
Zebra_vty.c (zebra):3226
      rn = route_node_match (table, (struct prefix *) &p);
      if (! rn)
        continue;
Zebra_vty.c (zebra):3264
       "show ip route summary prefix " VRF_ALL_CMD_STR,
       SHOW_STR
       IP_STR
Zebra_vty.c (zebra):3385
  struct prefix p;
  struct in6_addr *gate = NULL;
  struct in6_addr gate_addr;
Zebra_vty.c (zebra):3400
  /* Apply mask for given prefix. */
  apply_mask (&p);

Zebra_vty.c (zebra):3481
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n")
Zebra_vty.c (zebra):3494
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3508
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3523
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3538
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3554
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3571
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n")
Zebra_vty.c (zebra):3584
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3598
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3613
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3628
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3644
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3661
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
       "Distance value for this prefix\n")
{
  return static_ipv6_func (vty, 1, argv[0], argv[1], NULL, NULL, NULL, argv[2],
Zebra_vty.c (zebra):3675
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3680
       "Distance value for this prefix\n")
{
  return static_ipv6_func (vty, 1, argv[0], argv[1], NULL, NULL, argv[2], argv[3], NULL);
Zebra_vty.c (zebra):3690
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3695
       "Distance value for this prefix\n"
       VRF_CMD_HELP_STR)
{
Zebra_vty.c (zebra):3706
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3711
       "Distance value for this prefix\n")
{
  return static_ipv6_func (vty, 1, argv[0], argv[1], NULL, argv[2], NULL, argv[3],
Zebra_vty.c (zebra):3722
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3729
       "Distance value for this prefix\n")
{
  return static_ipv6_func (vty, 1, argv[0], argv[1], NULL, argv[2], argv[3], argv[4], NULL);
Zebra_vty.c (zebra):3739
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3746
       "Distance value for this prefix\n"
       VRF_CMD_HELP_STR)
{
Zebra_vty.c (zebra):3757
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
       "Distance value for this prefix\n")
{
  return static_ipv6_func (vty, 1, argv[0], argv[1], argv[2], NULL, NULL, argv[3],
Zebra_vty.c (zebra):3771
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3776
       "Distance value for this prefix\n")
{
  return static_ipv6_func (vty, 1, argv[0], argv[1], argv[2], NULL, argv[3], argv[4], NULL);
Zebra_vty.c (zebra):3786
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3791
       "Distance value for this prefix\n"
       VRF_CMD_HELP_STR)
{
Zebra_vty.c (zebra):3802
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3807
       "Distance value for this prefix\n")
{
  return static_ipv6_func (vty, 1, argv[0], argv[1], argv[2], argv[3], NULL, argv[4],
Zebra_vty.c (zebra):3818
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3825
       "Distance value for this prefix\n")
{
  return static_ipv6_func (vty, 1, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], NULL);
Zebra_vty.c (zebra):3835
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3842
       "Distance value for this prefix\n"
       VRF_CMD_HELP_STR)
{
Zebra_vty.c (zebra):3854
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n")
Zebra_vty.c (zebra):3868
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3883
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3899
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3911
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3925
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n")
Zebra_vty.c (zebra):3939
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3954
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3970
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3982
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):3996
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
       "Distance value for this prefix\n")
{
  return static_ipv6_func (vty, 0, argv[0], argv[1], NULL, NULL, NULL, argv[2],
Zebra_vty.c (zebra):4011
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4016
       "Distance value for this prefix\n")
{
  return static_ipv6_func (vty, 0, argv[0], argv[1], NULL, NULL, argv[2], argv[3], NULL);
Zebra_vty.c (zebra):4027
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4032
       "Distance value for this prefix\n"
       VRF_CMD_HELP_STR)
{
Zebra_vty.c (zebra):4044
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4049
       "Distance value for this prefix\n")
{
  /* We do not care about argv[2] */
Zebra_vty.c (zebra):4062
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4069
       "Distance value for this prefix\n")
{
  /* We do not care about argv[2] */
Zebra_vty.c (zebra):4081
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4088
       "Distance value for this prefix\n"
       VRF_CMD_HELP_STR)
{
Zebra_vty.c (zebra):4101
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
       "Distance value for this prefix\n")
{
  return static_ipv6_func (vty, 0, argv[0], argv[1], argv[2], NULL, NULL, argv[3],
Zebra_vty.c (zebra):4116
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4121
       "Distance value for this prefix\n")
{
  return static_ipv6_func (vty, 0, argv[0], argv[1], argv[2], NULL, argv[3], argv[4], NULL);
Zebra_vty.c (zebra):4132
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4137
       "Distance value for this prefix\n"
       VRF_CMD_HELP_STR)
{
Zebra_vty.c (zebra):4149
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4154
       "Distance value for this prefix\n")
{
  return static_ipv6_func (vty, 0, argv[0], argv[1], argv[2], argv[3], NULL, argv[4],
Zebra_vty.c (zebra):4166
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4173
       "Distance value for this prefix\n")
{
  return static_ipv6_func (vty, 0, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], NULL);
Zebra_vty.c (zebra):4184
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4191
       "Distance value for this prefix\n"
       VRF_CMD_HELP_STR)
{
Zebra_vty.c (zebra):4202
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4216
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4232
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4246
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4262
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
       "Distance value for this prefix\n"
       VRF_CMD_HELP_STR)
{
Zebra_vty.c (zebra):4277
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4282
       "Distance value for this prefix\n"
       VRF_CMD_HELP_STR)
{
Zebra_vty.c (zebra):4294
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
       "Distance value for this prefix\n"
       VRF_CMD_HELP_STR)
{
Zebra_vty.c (zebra):4309
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4314
       "Distance value for this prefix\n"
       VRF_CMD_HELP_STR)
{
Zebra_vty.c (zebra):4327
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4342
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4355
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4370
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4383
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
       "Distance value for this prefix\n"
       VRF_CMD_HELP_STR)
{
Zebra_vty.c (zebra):4399
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4404
       "Distance value for this prefix\n"
       VRF_CMD_HELP_STR)
{
Zebra_vty.c (zebra):4418
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
       "Distance value for this prefix\n"
       VRF_CMD_HELP_STR)
{
Zebra_vty.c (zebra):4434
       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
       "IPv6 gateway address\n"
       "IPv6 gateway interface name\n"
Zebra_vty.c (zebra):4439
       "Distance value for this prefix\n"
       VRF_CMD_HELP_STR)
{
Zebra_vty.c (zebra):4547
       "IPv6 prefix\n"
       "Show route matching the specified Network/Mask pair only\n")
{
Zebra_vty.c (zebra):4553
  struct prefix p;
  int ret;
  int first = 1;
Zebra_vty.c (zebra):4593
       "IPv6 prefix\n"
       "Show route matching the specified Network/Mask pair only\n"
       VRF_CMD_HELP_STR)
Zebra_vty.c (zebra):4678
  rn = route_node_match (table, (struct prefix *) &p);
  if (! rn)
    {
Zebra_vty.c (zebra):4707
       "IPv6 prefix\n")
{
  int ret;
Zebra_vty.c (zebra):4718
      vty_out (vty, "Malformed IPv6 prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Zebra_vty.c (zebra):4729
  rn = route_node_match (table, (struct prefix *) &p);
  if (! rn || rn->p.prefixlen != p.prefixlen)
    {
Zebra_vty.c (zebra):4751
       "IPv6 prefix\n"
       VRF_CMD_HELP_STR)

Zebra_vty.c (zebra):4787
/* Show ipv6 route summary prefix.  */
DEFUN (show_ipv6_route_summary_prefix,
       show_ipv6_route_summary_prefix_cmd,
       "show ipv6 route summary prefix",
       SHOW_STR
       IP_STR
Zebra_vty.c (zebra):4814
       "show ipv6 route summary prefix " VRF_CMD_STR,
       SHOW_STR
       IP_STR
Zebra_vty.c (zebra):4912
       "IPv6 prefix\n"
       "Show route matching the specified Network/Mask pair only\n"
       VRF_ALL_CMD_HELP_STR)
Zebra_vty.c (zebra):4919
  struct prefix p;
  struct zebra_vrf *zvrf;
  vrf_iter_t iter;
Zebra_vty.c (zebra):5031
      rn = route_node_match (table, (struct prefix *) &p);
      if (! rn)
        continue;
Zebra_vty.c (zebra):5049
       "IPv6 prefix\n"
       VRF_ALL_CMD_HELP_STR)
{
Zebra_vty.c (zebra):5062
      vty_out (vty, "Malformed IPv6 prefix%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
Zebra_vty.c (zebra):5072
      rn = route_node_match (table, (struct prefix *) &p);
      if (! rn)
        continue;
Zebra_vty.c (zebra):5147
       "show ipv6 route summary prefix " VRF_ALL_CMD_STR,
       SHOW_STR
       IP_STR
Zebra_vty.c (zebra):5255
             "longer-prefix",
             VTY_NEWLINE);

Zserv.c (zebra):24
#include "prefix.h"
#include "command.h"
#include "if.h"
Zserv.c (zebra):308
  struct prefix *p;

  /* Check this client need interface information. */
Zserv.c (zebra):327
  stream_put (s, &p->u.prefix, blen);

  /* 
Zserv.c (zebra):339
    stream_put (s, &p->u.prefix, blen);
  else
    stream_put (s, NULL, blen);
Zserv.c (zebra):395
 * - a "ip route"  or "ipv6 route" vty command is issued, a prefix is
 * - deleted from zebra's rib, and this info
 *   has to be redistributed to the clients 
Zserv.c (zebra):407
zsend_route_multipath (int cmd, struct zserv *client, struct prefix *p,
                       struct rib *rib)
{
Zserv.c (zebra):439
  stream_write (s, (u_char *) & p->u.prefix, psize);

  /* 
Zserv.c (zebra):696
  struct prefix p;
  u_short l = 0;
  u_char connected;
Zserv.c (zebra):712
      stream_get(&p.u.prefix, s, PSIZE(p.prefixlen));
      l += PSIZE(p.prefixlen);
      rnh = zebra_add_rnh(&p, 0);
Zserv.c (zebra):734
  struct prefix p;
  u_short l = 0;

Zserv.c (zebra):749
      stream_get(&p.u.prefix, s, PSIZE(p.prefixlen));
      l += PSIZE(p.prefixlen);
      rnh = zebra_lookup_rnh(&p, 0);
Zserv.c (zebra):780
  stream_put_in_addr (s, &p->prefix);

  if (rib)
Zserv.c (zebra):826
zsend_router_id_update (struct zserv *client, struct prefix *p,
    vrf_id_t vrf_id)
{
Zserv.c (zebra):845
  stream_put (s, &p->u.prefix, blen);
  stream_putc (s, p->prefixlen);

Zserv.c (zebra):929
  /* IPv4 prefix. */
  memset (&p, 0, sizeof (struct prefix_ipv4));
  p.family = AF_INET;
Zserv.c (zebra):933
  stream_get (&p.prefix, s, PSIZE (p.prefixlen));

  /* VRF ID */
Zserv.c (zebra):1004
/* Zebra server IPv4 prefix delete function. */
static int
zread_ipv4_delete (struct zserv *client, u_short length, vrf_id_t vrf_id)
Zserv.c (zebra):1029
  /* IPv4 prefix. */
  memset (&p, 0, sizeof (struct prefix_ipv4));
  p.family = AF_INET;
Zserv.c (zebra):1033
  stream_get (&p.prefix, s, PSIZE (p.prefixlen));

  /* Nexthop, ifindex, distance, metric. */
Zserv.c (zebra):1118
  p.prefix.s_addr = stream_get_ipv4 (client->ibuf);

  return zsend_ipv4_import_lookup (client, &p, vrf_id);
Zserv.c (zebra):1124
/* Zebra server IPv6 prefix add function. */
static int
zread_ipv6_add (struct zserv *client, u_short length, vrf_id_t vrf_id)
Zserv.c (zebra):1156
  /* IPv6 prefix. */
  memset (&p, 0, sizeof (struct prefix_ipv6));
  p.family = AF_INET6;
Zserv.c (zebra):1160
  stream_get (&p.prefix, s, PSIZE (p.prefixlen));

  /* We need to give nh-addr, nh-ifindex with the same next-hop object
Zserv.c (zebra):1242
/* Zebra server IPv6 prefix delete function. */
static int
zread_ipv6_delete (struct zserv *client, u_short length, vrf_id_t vrf_id)
Zserv.c (zebra):1263
  /* IPv4 prefix. */
  memset (&p, 0, sizeof (struct prefix_ipv6));
  p.family = AF_INET6;
Zserv.c (zebra):1267
  stream_get (&p.prefix, s, PSIZE (p.prefixlen));

  /* Nexthop, ifindex, distance, metric. */
Zserv.c (zebra):1340
  struct prefix p;

  /* Router-id information is needed. */
Zserv.h (zebra):137
extern int zsend_route_multipath (int, struct zserv *, struct prefix *, 
                                  struct rib *);
extern int zsend_router_id_update (struct zserv *, struct prefix *,
                                   vrf_id_t);

